[{"title":"Docker","url":"/2024/12/04/Docker/","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><blockquote>\n<p>比如写了一个web应用，本地调试没有问题，想发给朋友看看，或者需要部署到远程服务器上。首先需要配置相同的软件，比如数据库，web服务器，必要的插件、库等等。</p>\n</blockquote>\n<p>​\t\t一开始会想到虚拟机，但是虚拟机需要模拟硬件，运行整个操作系统，不但体积臃肿内存占用高，程序的性能也会收到影响。</p>\n<p>​\t\t这时<strong>Docker</strong>就派上用场了，Docker在概念上与虚拟机非常相似，但是却轻量很多，不会去模拟底层的硬件，只会为每一个应用提供完全隔离的运行环境，可以在环境中配置不同的工具软件，并且不同环境之间相互不影响。这个环境在Docker中也被称作container</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241204104629654.png\" alt=\"image-20241204104629654\"></p>\n<h1 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h1><h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><blockquote>\n<p>一个自动化脚本</p>\n</blockquote>\n<ul>\n<li>主要被用来创建镜像</li>\n<li>类似于列清楚了一个从操作系统到应用服务启动需要做哪些事情的清单文件</li>\n</ul>\n<h2 id=\"Container-Image\"><a href=\"#Container-Image\" class=\"headerlink\" title=\"Container Image\"></a>Container Image</h2><ul>\n<li>当运行docker build的时候，docker就会根据dockerfile的说明一行行构建环境+应用程序，最终将这个程序+环境打包成一个类似压缩包的东西，叫做容器镜像Container Image</li>\n</ul>\n<h2 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h2><ul>\n<li>在目的服务器上执行<code>docker pull</code>拿到容器镜像</li>\n<li>然后执行<code>docker run</code>命令，将这个类似压缩包的容器镜像解压缩获得一个独立的环境和应用程序并运行</li>\n<li>这样的就是容器Container</li>\n</ul>\n<h3 id=\"传统虚拟机和container的区别？\"><a href=\"#传统虚拟机和container的区别？\" class=\"headerlink\" title=\"传统虚拟机和container的区别？\"></a>传统虚拟机和container的区别？</h3><p><img data-src=\"https://img.jyhmw.cn/image-20241204110934446.png\" alt=\"image-20241204110934446\"></p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241204111258843.png\" alt=\"image-20241204111258843\"></p>\n<ul>\n<li>Container不带有像虚拟机一样的完整操作系统</li>\n<li>容器内只包含了操作系统的核心依赖库和配置文件等必要组件</li>\n<li>利用一个NameSpace的能力让它看起来就像是一个独立的操作系统</li>\n<li>再利用一个Cgroup限制它能使用的计算资源</li>\n<li>所以说容器本质上只是个自带独立运行环境的特殊进程，底层用的是宿主机的操作系统内核</li>\n</ul>\n<h2 id=\"Docker-Registry\"><a href=\"#Docker-Registry\" class=\"headerlink\" title=\"Docker Registry\"></a>Docker Registry</h2><blockquote>\n<p>负责管理镜像仓库推拉能力的服务</p>\n</blockquote>\n<ul>\n<li>docker pull 拉取镜像</li>\n</ul>\n<h1 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h1><blockquote>\n<p>经典的client-server架构</p>\n</blockquote>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><blockquote>\n<p>Client对应docker-cli<br>在命令行使用docker命令就是在使用docker  -cli</p>\n</blockquote>\n<ul>\n<li>docker-cli会解析我们的命令然后调用docker daemon守护进程提供的restful API</li>\n</ul>\n<h2 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h2><blockquote>\n<p>server对应docker daemon</p>\n</blockquote>\n<img data-src=\"https://img.jyhmw.cn/image-20241204111844145.png\" alt=\"image-20241204111844145\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>守护进程收到命令后会根据命令创建和管理各个容器</p>\n</li>\n<li><p>内部分为docker server 和 engine两层</p>\n<ul>\n<li><p>docker server本质上就是一个http服务器，负责对外提供操作容器和镜像的api接口，接收到API请求后会分发任务给engine层，engine层负责创建job，由job执行不同的工作</p>\n<img data-src=\"https://img.jyhmw.cn/image-20241204112002229.png\" alt=\"image-20241204112002229\" style=\"zoom:50%;\" />\n</li>\n<li><p>例如：如果执行的是docker-build命令job会根据docker-file执行文件</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"相关周边\"><a href=\"#相关周边\" class=\"headerlink\" title=\"相关周边\"></a>相关周边</h1><h2 id=\"docker-compose\"><a href=\"#docker-compose\" class=\"headerlink\" title=\"docker compose\"></a>docker compose</h2><blockquote>\n<p>用来部署多个容器并且对这些容器有一定顺序要求</p>\n</blockquote>\n<ul>\n<li>通过一个yaml文件写清楚要部署的容器有哪些，部署顺序是怎样的，以及这些容器占用的cpu和内存等信息</li>\n<li>通过一行docker-compose up命令解析yaml文件，将容器们进行部署</li>\n</ul>\n<h2 id=\"docker-swarm\"><a href=\"#docker-swarm\" class=\"headerlink\" title=\"docker swarm\"></a>docker swarm</h2><blockquote>\n<p>解决多个容器构成的一整套服务在多态服务器上的集群部署问题</p>\n</blockquote>\n<ul>\n<li>比如某应用在A服务器坏了就将该应用在b服务器上重新部署一套实现迁移</li>\n<li>还能根据需要对应用做扩缩容</li>\n</ul>\n","categories":["技术栈","容器"],"tags":["Docker","容器"]},{"title":"ElasticSearch","url":"/2024/12/02/ElasticSearch/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"ElasticSearch（简称ES）\"><a href=\"#ElasticSearch（简称ES）\" class=\"headerlink\" title=\"ElasticSearch（简称ES）\"></a><strong>ElasticSearch（简称ES）</strong></h2><blockquote>\n<p>是一个开源的分布式搜索和数据分析引擎，是用Java开发并且是当前最流行的开源企业级搜索引擎，能够达到近实时搜索，专门设计用于处理大规模的文本数据和实现高性能的全文搜索</p>\n</blockquote>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>分布式架构：<br>ElasticSearch是一个分布式系统，可以轻松的水平扩展，处理大规模的数据集和高并发的查询请求</li>\n<li>全文检索功能：<br>提供了强大的全文检索功能，包括分词、词项查询、模糊匹配、多字段搜索等，并支持丰富的查询语法和过滤器</li>\n<li>多语言支持：<br>支持多种语言的分词器和语言处理器，可以很好的处理不同语言的文本数据</li>\n<li>高性能：<br>使用倒排索引和缓存等技术，具有快速的搜索速度和高效的查询性能</li>\n<li>实时性：<br>支持实时索引和搜索，可以几乎实时地将文档添加到索引中，并立即可见</li>\n<li>易用性：<br>提供了简单易用的Restful API，方便进行索引管理、查询操作和数据分析</li>\n</ul>\n<p><strong>什么是倒排索引？</strong></p>\n<blockquote>\n<p>正排索引和倒排索引是全文检索中常用的两种索引结构，他们在索引和搜索的过程中扮演不同的角色</p>\n</blockquote>\n<ul>\n<li><p>正排索引</p>\n<p>正排索引是将文档按顺序排列并进行编号的索引结构。每个文档都包含了完整的文本内容，以及其他相关的属性或元数据，如标题、作者、发布日期等。在正排索引中，可以根据文档编号或其他属性快速定位和访问文档的内容。正排索引适合用于需要对文档进行整体检索和展示的场景，但对于包含大量文本内容的数据集来说，正排索引的存储和查询效率可能会受到限制。</p>\n<p>在MySQL 中通过 ID 查找就是一种正排索引的应用。</p>\n</li>\n<li><p>倒排索引</p>\n<p>倒排索引是根据单词或短语建立的索引结构。它将每个单词映射到包含该单词的文档列表中。倒排索引的建立过程是先对文档进行分词处理，然后记录每个单词在哪些文档中出现，以及出现的位置信息。通过倒排索引，可以根据关键词或短语快速找到包含这些词语的文档，并确定它们的相关性。倒排索引适用于在大规模文本数据中进行关键词搜索和相关性排序的场景，它能够快速定位文档，提高搜索效率。</p>\n<p>我们在创建文章的时候，建立一个关键词与文章的对应关系表，就可以称之为倒排索引。</p>\n</li>\n</ul>\n<h2 id=\"Kibana\"><a href=\"#Kibana\" class=\"headerlink\" title=\"Kibana\"></a>Kibana</h2><blockquote>\n<p>一个开源的数据分析和可视化平台，与ElasticSearch紧密集成</p>\n</blockquote>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li>数据可视化：通过各种图表如柱状图、折线图、饼图等）来展示 Elasticsearch 中的数据。例如，可以将网站访问日志数据在 Kibana 中以折线图的形式展示每天的访问量变化，或者以饼图展示不同来源的访问占比。</li>\n<li>仪表板创建：用户可以创建自定义的仪表板，将多个相关的可视化图表组合在一起，以便更全面地监控和分析数据。比如，在监控服务器性能时，可以在一个仪表板中同时展示 CPU 使用率、内存使用率、磁盘 I&#x2F;O 等多个指标的图表。</li>\n<li>数据探索：方便用户对存储在 Elasticsearch 中的数据进行交互式的探索。用户可以通过简单的查询操作，快速查看和分析数据的分布、趋势等情况。例如，在一个包含用户行为数据的索引中，通过 Kibana 可以轻松地探索不同用户群体的行为模式。</li>\n</ol>\n<h1 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h1><ol>\n<li><p>下载ElasticSearch<br>这里我是在官网下载的8.16.1版本</p>\n<p>官网下载连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.elastic.co/cn/downloads/elasticsearch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置环境变量</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241202174222655.png\"></p>\n</li>\n<li><p>关闭Security验证<br><img data-src=\"https://img.jyhmw.cn/image-20241202174655971.png\" alt=\"image-20241202174655971\"></p>\n</li>\n<li><p>启动脚本<br><img data-src=\"https://img.jyhmw.cn/image-20241202174754521.png\" alt=\"image-20241202174754521\"></p>\n</li>\n<li><p>访问默认端口:localhost:9200</p>\n</li>\n<li><p>安装Kibana</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.elastic.co/downloads/kibana</span><br></pre></td></tr></table></figure>\n\n<p>下载安装Kibana - 同上解压<br>修改配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port:</span> <span class=\"number\">5601</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">server.host:</span> <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">server.maxPayload:</span> <span class=\"number\">1048576</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">elasticsearch.hosts:</span> [<span class=\"string\">&quot;http://127.0.0.1:9200&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">elasticsearch.username:</span> <span class=\"string\">&quot;kibana_system&quot;</span></span><br><span class=\"line\"><span class=\"attr\">elasticsearch.password:</span> <span class=\"string\">&quot;vsrW2gnx+gcSLiGT9f8e&quot;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">i18n.locale:</span> <span class=\"string\">&quot;zh-CN&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问<a href=\"http://localhost:5601/\">http://localhost:5601/</a></p>\n</li>\n</ol>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2><p><strong>inverted index</strong></p>\n<blockquote>\n<p>结合一个例子来看</p>\n</blockquote>\n<p>比如有一个需求从id为0,1,2的文本中找到有xiaobai的文本<br><img data-src=\"https://img.jyhmw.cn/image-20241203093639869.png\" alt=\"image-20241203093639869\"></p>\n<ol>\n<li><p>分词：对每个单词进行一个切分<br><img data-src=\"https://img.jyhmw.cn/image-20241203094114078.png\" alt=\"image-20241203094114078\"></p>\n<p>切分的操作叫做分词，分词后的每个部分称为一个词项（term）<br><img data-src=\"https://img.jyhmw.cn/image-20241203094237151.png\" alt=\"image-20241203094237151\"></p>\n</li>\n<li><p>如果文本较大的话词项就会有很多很多，如何优化时间？<br>将词项按照字典序排序，使用二分查找的方法进行查找将时间复杂度优化为O(logn)<br>此时，将排好序的词项称为<code>Term Dictionary</code>，词项对应的文档ID等信息的聚合称为<code>Posting list</code><br><img data-src=\"https://img.jyhmw.cn/image-20241203094558144.png\" alt=\"image-20241203094558144\"></p>\n<p><code>Term Dictionary</code> 和 <code>Posting list</code> 共同构成了一个用于搜索的数据结构-倒排索引（inverted index）</p>\n</li>\n</ol>\n<h2 id=\"Term-Index\"><a href=\"#Term-Index\" class=\"headerlink\" title=\"Term Index\"></a>Term Index</h2><blockquote>\n<p>通过倒排索引发现一个问题，Term Dictionary数据量很大放进内存中并不现实，因此必须存放在磁盘中，但是查询磁盘是个比较缓慢的过程。想要优化就得有<strong>Term Index</strong></p>\n</blockquote>\n<ol>\n<li><p>我们发现一些词项的前缀是一致的，如果将部分term前缀提取出来复用，就能用更少的空间表达多个term</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203095204163.png\"></p>\n</li>\n<li><p>基于1的原理我们可以将term Dictionary的部分词项提取出来，用这些词项的前缀信息，构成一个精简的目录树。<br><img data-src=\"https://img.jyhmw.cn/image-20241203095412009.png\" alt=\"image-20241203095412009\"><br>目录树的节点中存放这些词项在磁盘中的偏移量，也就是指向磁盘中的位置，这个目录树结构体积小适合放在内存中，就是我们讲的term index，用来加速搜索。</p>\n</li>\n</ol>\n<h2 id=\"Stored-Fields\"><a href=\"#Stored-Fields\" class=\"headerlink\" title=\"Stored Fields\"></a>Stored Fields</h2><blockquote>\n<p>前面提到的倒排索引搜索到的是文档ID，我们还需要拿着这个ID找到文档本身才能返回给用户，因此还需要有个地方存放完整的文档内容就是<strong>Stored Fields</strong></p>\n</blockquote>\n<ul>\n<li>是一个行式存储结构<br><img data-src=\"https://img.jyhmw.cn/image-20241203095816871.png\" alt=\"image-20241203095816871\"></li>\n</ul>\n<h2 id=\"Doc-Values\"><a href=\"#Doc-Values\" class=\"headerlink\" title=\"Doc Values\"></a>Doc Values</h2><blockquote>\n<p>用户经常需要根据某个字段排序文档，比如时间、商品价格等等。而这些字段散落在文档里。<br>一般来说我们需要先获取stored fileds里面的文档，再提取出内部字段进行排序。下面我是Doc Values的解决办法</p>\n</blockquote>\n<ol>\n<li>将散落在各个文档的某个字段集中存放</li>\n<li>想对某个字段排序的时候，将这些几种存放的字段一次性读取出来。就能做到针对性的进行排序。</li>\n<li>这是一个列式的存储结构，这个结构就叫做Doc Vlaues</li>\n</ol>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203100213876.png\" alt=\"image-20241203100213876\"></p>\n<h2 id=\"Segment\"><a href=\"#Segment\" class=\"headerlink\" title=\"Segment\"></a>Segment</h2><blockquote>\n<p>上面四种结构共同组成了一个复合文件就是<strong>Segment</strong></p>\n</blockquote>\n<p><strong>是一个具备完整搜索功能的最小单元</strong></p>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><blockquote>\n<ul>\n<li>我们用多个文档生成一个segment，如果新增文档时还是写入这个segment还是写入到这个segment，就得同事更新segment内部的多个数据结构，并发读写时，性能肯定会受影响。</li>\n<li>制定一个规矩，segment一旦生成则不能再被修改，如果还有新的文本就生成新的segment。这样老的segment只负责读，新的负责写同时保证读写性能</li>\n<li>但是这样segment就变多了，不知道数据在哪个segment里，虽然能并发读多个segment但segment过多总归要耗尽文件句柄</li>\n<li>可以不定期合并多个小segment，成为<strong>段合并</strong>(Segment Merge)。</li>\n</ul>\n</blockquote>\n<p>通过以上的步骤生成的多个Segment就构成了一个单机文本检索库，一个很有名的开源基础搜索库Luence</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203101203588.png\" alt=\"image-20241203101203588\"></p>\n<h2 id=\"Lucene优化\"><a href=\"#Lucene优化\" class=\"headerlink\" title=\"Lucene优化\"></a>Lucene优化</h2><h3 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h3><blockquote>\n<p>多个调用方同时读写同一个Lucene，导致争抢计算资源，抢不到资源的进行等待-浪费时间。</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203101336261.png\" alt=\"image-20241203101336261\"></p>\n<ol>\n<li><p>对写入Lucene的数据进行分类，将不同类数据写入到不同lucene中，根据需要搜索到不同的index name<br><img data-src=\"https://img.jyhmw.cn/image-20241203101641922.png\" alt=\"image-20241203101641922\"></p>\n<p>大大降低单个index name 的压力</p>\n</li>\n<li><p>但是单个index name数据仍然可能过多，可以将单个index name的同类数据拆分成好几份，m每份是一个Shard分片，每个shard分片本质上就是一个独立的Lucene库<br><img data-src=\"https://img.jyhmw.cn/image-20241203101814167.png\" alt=\"image-20241203101814167\"></p>\n</li>\n<li><p>将读写请求分到多个shard中，提升性能</p>\n</li>\n</ol>\n<h3 id=\"高扩展\"><a href=\"#高扩展\" class=\"headerlink\" title=\"高扩展\"></a>高扩展</h3><blockquote>\n<p>随着分片变多，如果这些分片都在同一个机器上就会导致单机CPU和内存过高，影响整体系统性能，我们就可以申请更多的机器，将分片分散部署在多态机器上</p>\n</blockquote>\n<ol>\n<li>将分片分散部署在多台机器上，每台机器就是一个Node</li>\n<li>增加Node，以此缓解cpu过高带来的性能问题</li>\n</ol>\n<h3 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h3><blockquote>\n<p>如果某个Node挂了，里面的所有分片就不能用了</p>\n</blockquote>\n<ol>\n<li>给分片多加几个副本，将分片分为primary shard 和 replica shard (主分片和副本分片)</li>\n<li>主分片将数据同步给副本分片，副本分片提供读操作的同时，在主分片挂了的时候升级成新主分片</li>\n</ol>\n<h3 id=\"Node角色分化\"><a href=\"#Node角色分化\" class=\"headerlink\" title=\"Node角色分化\"></a>Node角色分化</h3><blockquote>\n<p>搜索架构需要支持的功能很多，既要负责管理集群又要储存管理数据，还要处理客户端的搜索请求，如果每个Node都支持这几个功能，当集群有数据压力需要扩容node时，就会顺带把其他能力一起扩容，如果其他能力完全够用不需要扩容就浪费了。</p>\n</blockquote>\n<ol>\n<li>将功能拆开给集群里的Node赋予角色身份呢，不同角色负责不同的功能</li>\n<li>负责管理集群的叫主节点（Master Node），负责存储管理数据的叫数据节点（Data Node），负责接受客户端搜索查询请求的叫协调节点（Coordinate Node）</li>\n</ol>\n<h3 id=\"去中心化\"><a href=\"#去中心化\" class=\"headerlink\" title=\"去中心化\"></a>去中心化</h3><blockquote>\n<p>在Node中引入raft模块，在节点间互相同步数据，让所有Node看到的集群数据状态都是一致的</p>\n</blockquote>\n<h2 id=\"构成Elastic-Search\"><a href=\"#构成Elastic-Search\" class=\"headerlink\" title=\"构成Elastic Search\"></a>构成Elastic Search</h2><p>至此一个简陋的Lucene就成了一个高性能、高扩展性、高可用支持持久化的分布式搜索引擎—ES<br><img data-src=\"https://img.jyhmw.cn/image-20241203103354491.png\" alt=\"image-20241203103354491\"></p>\n<p>对外提供HTTP接口，任何语言的客户端都可以通过HTTP接口接入ES，实现对数据的增删改查。</p>\n<h3 id=\"写入流程\"><a href=\"#写入流程\" class=\"headerlink\" title=\"写入流程\"></a>写入流程</h3><ol>\n<li>客户端发起写入请求</li>\n<li>请求先发到Coordinate节点</li>\n<li>Coordinate根据Harsh路由判断数据应写到的数据节点和分片</li>\n<li>住分片写入成功后，将数据写入到副本分片</li>\n<li>副本分片写入完成后主分片会响应Coordinate一个ACK，意思是写入完成</li>\n<li>最后协调节点响应客户端，些人完成</li>\n</ol>\n<h3 id=\"搜索流程\"><a href=\"#搜索流程\" class=\"headerlink\" title=\"搜索流程\"></a>搜索流程</h3><ul>\n<li>查询阶段 query phase<ol>\n<li>客户端发起搜索请求</li>\n<li>请求发到Coordinate节点</li>\n<li>Coordinate节点根据index name信息了解到index name被分为了几个分片，以及分片分散在哪个数据节点上</li>\n<li>将请求转发到数据节点</li>\n<li>数据节点并发搜索多个segment，获取到文档id和排序信息，将结果返回给协调节点</li>\n<li>协调节点对拿到的数据进行排序聚合，舍弃大部分不需要的数据</li>\n</ol>\n</li>\n<li>获取阶段 fetch phase<ol>\n<li>协调节点（Coordinate）再次拿着文档id请求数据节点里的分片</li>\n<li>分片底层的Lucene库会从segment内的stored fileds读出完整文档内容返回给协调节点</li>\n<li>协调节点返回给客户端</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h1><h2 id=\"ik分词器\"><a href=\"#ik分词器\" class=\"headerlink\" title=\"ik分词器\"></a>ik分词器</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ol>\n<li>下载与elasticsearch和kibana同版本的ik分词器</li>\n<li>放到elasticsearch的跟目录的.&#x2F;plugin&#x2F;ik下面</li>\n</ol>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li><p>粗粒度切分</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /_analyze</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;世界终归是你们的&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;analyzer&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;ik_smart&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203151010601.png\" alt=\"image-20241203151010601\"></p>\n</li>\n<li><p>细粒度切分</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /_analyze</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;世界终归是你们的&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;analyzer&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;ik_max_word&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203151101978.png\" alt=\"image-20241203151101978\"></p>\n</li>\n</ol>\n<h2 id=\"拓展词库\"><a href=\"#拓展词库\" class=\"headerlink\" title=\"拓展词库\"></a>拓展词库</h2><blockquote>\n<p>找到ik分词器目录中的config目录中的IKAnalyzer.cfg.xml文件</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241203151532356.png\" alt=\"image-20241203151532356\"></p>\n<ol>\n<li>里面写上要读取的文件名<br><img data-src=\"https://img.jyhmw.cn/image-20241203151901081.png\" alt=\"image-20241203151901081\"></li>\n<li>如果文件不存在创建文件，在创建的文件中加上要停用或扩展的词</li>\n</ol>\n<h2 id=\"mapping属性\"><a href=\"#mapping属性\" class=\"headerlink\" title=\"mapping属性\"></a>mapping属性</h2><blockquote>\n<p>是对索引库中文档的约束</p>\n</blockquote>\n<p>常见的mapping属性包括</p>\n<ul>\n<li>type：字段数据类型，常见的类型有<ul>\n<li>字符串：text（可分词的文本）、keybord（精确值，例如：品牌、国家、ip地址）</li>\n<li>数值：long、integer、short、byte、double、float</li>\n<li>布尔：boolean</li>\n<li>日期：date</li>\n<li>对象：object</li>\n</ul>\n</li>\n<li>index：是否创建索引，默认为true</li>\n<li>analyzer：使用那种分词器</li>\n<li>properties：该字段的子字段</li>\n</ul>\n<h2 id=\"索引库操作\"><a href=\"#索引库操作\" class=\"headerlink\" title=\"索引库操作\"></a>索引库操作</h2><h3 id=\"创建索引库\"><a href=\"#创建索引库\" class=\"headerlink\" title=\"创建索引库\"></a>创建索引库</h3><blockquote>\n<p>ES中通过Restful请求操作索引库、文档。请求内容用DSL语句来表示。创建索引库和mapping的DSL语法如下:</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">#创建索引库</span><br><span class=\"line\">PUT /jyh</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;mappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;info&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;text&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;analyzer&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ik_smart&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;email&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;keyword&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;index&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;object&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;firstName&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;lastName&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;keyword&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果出现创建索引库失败，可能是磁盘上限了可以修改磁盘上限百分比</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">#磁盘上限</span><br><span class=\"line\">PUT /_cluster/settings</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;transient&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cluster.routing.allocation.disk.watermark.low&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;90%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cluster.routing.allocation.disk.watermark.high&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;95%&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cluster.info.update.interval&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1m&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查找索引库\"><a href=\"#查找索引库\" class=\"headerlink\" title=\"查找索引库\"></a>查找索引库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET /索引名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除索引库\"><a href=\"#删除索引库\" class=\"headerlink\" title=\"删除索引库\"></a>删除索引库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DELETE /索引名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改索引库\"><a href=\"#修改索引库\" class=\"headerlink\" title=\"修改索引库\"></a>修改索引库</h3><p>添加了一个字段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">PUT /jyh/_mapping</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;age&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;integer&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文档操作\"><a href=\"#文档操作\" class=\"headerlink\" title=\"文档操作\"></a>文档操作</h2><h3 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /jyh/_doc/<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;info&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;一个普通的大学生&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;email&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;16937@xx.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;firstName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;英浩&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lastName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;景&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查询文档\"><a href=\"#查询文档\" class=\"headerlink\" title=\"查询文档\"></a>查询文档</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET /jyh/_doc/<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除文档\"><a href=\"#删除文档\" class=\"headerlink\" title=\"删除文档\"></a>删除文档</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">DELETE /jyh/_doc/<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改文档\"><a href=\"#修改文档\" class=\"headerlink\" title=\"修改文档\"></a>修改文档</h3><ol>\n<li><p>全量修改，删除旧文档，添加新文档（如果id不存在直接变成一个新增操作）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">PUT /jyh/_doc/<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;info&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;一个普通的大学生&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;email&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;46418@xx.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;firstName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;英浩&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;lastName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;景&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>局部修改（对某个字段进行修改）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST /jyh/_update/<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;doc&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;email&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1@.com&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["技术栈","搜索引擎"],"tags":["搜索引擎","ElasticSearch"]},{"title":"HTML","url":"/2024/11/13/HTML/","content":"<h1 id=\"前后端分离开发\"><a href=\"#前后端分离开发\" class=\"headerlink\" title=\"前后端分离开发\"></a>前后端分离开发</h1><blockquote>\n<p>什么是前后端分离？</p>\n<p>在前后端分离的开发模式中，后端仅返回前端所需的数据，前端负责渲染HTML⻚⾯，后端不再控制前端的效果， ⽤户看到什么样的效果，从后端请求的数据如何加载到前端中，都由前端⾃⼰决定，后端仅仅需要提供⼀套逻辑对 外提供数据即可，并且前端与后端的耦合度相对较低，在这种模式中，我们通常将后端开发的每个视图都成为⼀个 接⼝，或者API，前端通过访问接⼝来对数据进⾏增删改查。总结⼀句话，后台负责提供数据，前端负责数据展 示，职责分离，分⼯明确。对应的数据交互如下图：</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241113154701108.png\" alt=\"image-20241113154701108\"></p>\n<p>总结</p>\n<p>经典的JSP+Servlet+JavaBean的MVC时代，到SSM（Spring + SpringMVC + Mybatis）和SSH（Spring + Struts2 + Hibernate）的Java 框架时代，再到前端框架（VueJS、AngularJS、ReactJS）为主的MV*时代，然后是NodeJS引领 的全栈时代，技术和架构⼀直都在进步。虽然“基于NodeJS的全栈式开发”模式很让⼈兴奋，但是把基于Node的全 栈开发变成⼀个稳定，让⼤家都能接受的东⻄还有很多路要⾛。创新之路不会⽌步，⽆论是前后端分离模式还是 其他模式，都是为了更⽅便得解决需求，但它们都只是⼀个“中转站”。前端项⽬与后端项⽬是两个项⽬，放在两个 不同的服务器，需要独⽴部署，两个不同的⼯程，两个不同的代码库，不同的开发⼈员。前端只需要关注⻚⾯的样 式与动态数据的解析及渲染，⽽后端专注于具体业务逻辑。</p>\n<h1 id=\"大前端？\"><a href=\"#大前端？\" class=\"headerlink\" title=\"大前端？\"></a>大前端？</h1><ul>\n<li>简单来说，⼤前端就是所有前端的统称，⽐如Web、Android、iOS、Watch等，最接近⽤户的那⼀层也就是UI层， 然后将其统⼀起来，就是⼤前端。 </li>\n<li>由于node的出现，前端⼯程师不需要依赖于后端程序⽽直接运⾏，从⽽前后端分离起来。所以当开发⼀个新产品 的时候服务只需要写⼀次，但是⾯向⽤户的产品可能有很多，例如⽹站、Android客户端、iOS客户端和微信⼩程序 等。由于各个平台使⽤的技术栈都不⼀样，代码⽆法复⽤，⾮常浪费⼈⼒、物⼒。那么有没有什么技术能够解决这 ⼀痛点呢？⼤前端应运⽽⽣，其实⼤前端的主要核⼼就是跨平台技术，有了跨平台技术，各个平台的差异性就抹 平了，开发者只需要⼀套技术栈就可以开发出适⽤于多个平台的客户端。</li>\n<li>⼤前端的学习流程：HTML5&#x2F;CSS3-&gt;云服务器-&gt;JavaScript(核⼼)-&gt;jQuery-&gt;HTML5 API-&gt;ES6(核⼼)-&gt;Vue（React）-&gt;原 ⽣App&#x2F;混合式开发App&#x2F;⼩程序-&gt;NodeJs-&gt;MySQL </li>\n<li>前端开发环境的搭建  安装nodejs，Vue等   安装编译⼯具VSCode，webstrom等 </li>\n<li>web前端基础  HTML   CSS   JavaScript(ES5,ES6) </li>\n<li>web前端框架  jQuery   Vue   React   Angular   第三⽅组件库(elementUI，iView) </li>\n<li>原⽣移动端(可选)  iOS   Android </li>\n<li>混合移动端开发  ⼩程序，微信⼩程序，⽀付宝⼩程序等   ReactNative   Flutter、uni-app等 </li>\n<li>Node后端开发  CommonJS   RequireJS   Node.js</li>\n</ul>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><blockquote>\n<p>超⽂本标记语⾔（英语：HyperText Markup Language，简称：HTML）是⼀种⽤于创建⽹⻚的标准标记语⾔。 学习⽹站：<a href=\"https://www.w3school.com.cn/html/index.asp\">https://www.w3school.com.cn/html/index.asp</a> HTML5和HTML4的关系：</p>\n<ol>\n<li><p>HTML5是应⽤超⽂本标记语⾔（HTML）的第五次修改，代表html语⾔第5版本。 </p>\n</li>\n<li><p>HTML4是应⽤超⽂本标记语⾔（HTML）的第四次修改，代表html语⾔第4版本。</p>\n</li>\n<li><p>HTML4是为了适应 PC （Personal Computer）时代产⽣的，HTML5是为了适应移动互联⽹时代产⽣的。</p>\n</li>\n<li><p>HTML5和HTML4都是w3c（World Wide Web）推荐的标准语⾔.</p>\n</li>\n<li><p>HTML5在HTML4的基础上新增了⼀些特性。⽐如，让标签更具有语义化，新增了⼀些表单控件，新增了Web API等。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"文档头信息\"><a href=\"#文档头信息\" class=\"headerlink\" title=\"文档头信息\"></a>文档头信息</h2><blockquote>\n<p>使⽤VSCode⼯具可以快速⽣成⽂档头信息，在VSCode中新建1-hello.html，在该⽂件内容中输⼊英⽂!，回 ⻋即可快速⽣成完整的⽂档头信息。以.html或者.htm结尾的⽂件中使⽤!或者html:5来快速产⽣⽂档头信息。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供⼀项信息（声明），即 HTML 是⽤HTML5版本编写的。 --&gt;</span></span><br><span class=\"line\"> <span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- 语⾔是English --&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- ⽂档的头部，不在⽹⻚的视⼝区显示 --&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 元信息，字符编码UTF-8 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 元信息，设置浏览器优先使⽤什么模式来渲染⻚⾯，以下代码告诉IE浏览器，IE8/9及以后的版本都会以最⾼版</span></span><br><span class=\"line\"><span class=\"comment\">本IE来渲染⻚⾯，是针对IE浏览器的设置 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 元信息，设置可使⽤的宽度为设备的宽度，初始缩放⽐例为1 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ⽂档的标题，在选项卡上显示 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- ⽂档的体部，在⽹⻚的视⼝区显示 --&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 该内容会显示在⽹⻚中 --&gt;</span></span><br><span class=\"line\">  Hello</span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注释</strong>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--注释的内容--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><h3 id=\"标签的结构\"><a href=\"#标签的结构\" class=\"headerlink\" title=\"标签的结构\"></a>标签的结构</h3><p><img data-src=\"https://img.jyhmw.cn/image-20241113155145965.png\" alt=\"image-20241113155145965\"></p>\n<h3 id=\"常用标签\"><a href=\"#常用标签\" class=\"headerlink\" title=\"常用标签\"></a>常用标签</h3><p><strong>div</strong> 和 <strong>span</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是div标签内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是div标签内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>我是span标签内容<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>我是span标签内容<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>div是块级元素，独占⼀⾏ </p>\n<p>span是⾏内元素，与其他⾏内元素共享⼀⾏</p>\n</blockquote>\n<h3 id=\"表格标签\"><a href=\"#表格标签\" class=\"headerlink\" title=\"表格标签\"></a>表格标签</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>信息表<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>13<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>14<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>21<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>22<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>23<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>24<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>31<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>32<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>33<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>34<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>效果</strong></p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241113155319798.png\" alt=\"image-20241113155319798\"></p>\n<p>如果想要有边框和宽度</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 设置表格标签样式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">table</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 表格宽度 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 表格内⽂字⽔平对⻬⽅式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"attribute\">text-align</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">   &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 设置table标签、td标签、th标签的样式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">table</span>,</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">table</span> <span class=\"selector-tag\">td</span>,</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">table</span> <span class=\"selector-tag\">th</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 设置边框为1px的宽度、实线、颜⾊为⿊灰⾊ */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#444</span>;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"comment\">/* 表格内边框合并 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"attribute\">border-collapse</span>: collapse;</span></span><br><span class=\"line\"><span class=\"language-css\">   &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>信息表<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>列的标题<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>13<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>14<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>21<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>22<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>23<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>24<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>31<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>32<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>33<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>34<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241113155408244.png\" alt=\"image-20241113155408244\"></p>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><blockquote>\n<p>表单可以⽤来采集⽤户信息和⽤户需求的，⽤户可以在表单控件⾥输⼊或选择内容。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">⽤户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">性别：<span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;male&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;male&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;male&quot;</span>&gt;</span></span><br><span class=\"line\">男<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;female&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;female&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;female&quot;</span>&gt;</span></span><br><span class=\"line\">⼥<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">爱好：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;basketball&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;basketball&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hobby&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;basketball&quot;</span>&gt;</span></span><br><span class=\"line\">篮球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;swimming&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;swimming&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hobby&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;swimming&quot;</span>&gt;</span></span><br><span class=\"line\">游泳</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;dancing&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dancing&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hobby&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;dancing&quot;</span>&gt;</span></span><br><span class=\"line\">跳舞</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">出⽣⽇期：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;date&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;birth&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">城市：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;city&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span>请选择<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;beijing&quot;</span>&gt;</span>北京<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;shanghai&quot;</span>&gt;</span>上海<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;guangzhou&quot;</span>&gt;</span>⼴州<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">个⼈介绍：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>提交按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241113155507467.png\" alt=\"image-20241113155507467\"></p>\n<h2 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"comment\">/* 设置img标签样式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">img</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* 设置宽 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* 设置⾼ */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">img</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">src</span>=<span class=\"string\">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic.jj20.com%2Fup%2Fallimg%2F11</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\"> 14%2F0F620092Q5%2F200F6092Q5-6</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">1200.jpg&amp;refer=http%3A%2F%2Fpic.jj20.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\"> ?sec=1621259882&amp;t=62897e09599d5a6e40d740b9f865fae0&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超链接a标签\"><a href=\"#超链接a标签\" class=\"headerlink\" title=\"超链接a标签\"></a>超链接a标签</h2><p>a标签的target属性代表⽬标链接打开的⽅式，_blank代表在新⻚⾯打开</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://www.baidu.com&quot;</span> <span class=\"attr\">target</span>=<span class=\"string\">&quot;_blank&quot;</span>&gt;</span>这是⼀个链接<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"音视频\"><a href=\"#音视频\" class=\"headerlink\" title=\"音视频\"></a>音视频</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- autoplay⾃动播放 controls控制条 loop循环播放 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">controls</span> <span class=\"attr\">loop</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./images/稻⾹.mp3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 视频 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">autoplay</span> <span class=\"attr\">controls</span> <span class=\"attr\">loop</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./images/1.mp4&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"iframe标签\"><a href=\"#iframe标签\" class=\"headerlink\" title=\"iframe标签\"></a>iframe标签</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://echarts.apache.org/zh/index.html&quot;</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">&quot;0&quot;</span>&gt;</span>&lt;/iframe</span><br></pre></td></tr></table></figure>\n\n<p>使用iframe标签在当前⽹⻚内嵌⼊其他⻚⾯</p>\n<p>展示天气</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;300&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">&quot;no&quot;</span> <span class=\"attr\">hspace</span>=<span class=\"string\">&quot;0&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">src</span>=<span class=\"string\">&quot;https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=34&amp;py=chongqing&amp;icon=1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;280&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;300&quot;</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">&quot;no&quot;</span> <span class=\"attr\">hspace</span>=<span class=\"string\">&quot;0&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">src</span>=<span class=\"string\">&quot;https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=55&amp;icon=1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网页选项卡图标\"><a href=\"#网页选项卡图标\" class=\"headerlink\" title=\"网页选项卡图标\"></a>网页选项卡图标</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;icon&quot;</span> <span class=\"attr\">sizes</span>=<span class=\"string\">&quot;any&quot;</span> <span class=\"attr\">mask</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://www.baidu.com/favicon.ico&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["前端","html"],"tags":["前端","html"]},{"title":"JUC","url":"/2024/05/27/JUC%E5%B9%B6%E5%8F%91%E5%8C%85/","content":"<h1 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h1><h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><h3 id=\"线程创建的四种方式：\"><a href=\"#线程创建的四种方式：\" class=\"headerlink\" title=\"线程创建的四种方式：\"></a>线程创建的四种方式：</h3><ul>\n<li>继承Thread，重写run方法。</li>\n<li>实现Runnable接口，重写run方法</li>\n<li>实现Callable接口，重写call方法<ul>\n<li>与Runnable方法基本相同，区别是有一个返回值</li>\n<li>返回值是Future对象，可以异步获取执行结果</li>\n<li>必须搭配线程池使用</li>\n</ul>\n</li>\n<li>线程池获取</li>\n</ul>\n<h3 id=\"线程创建的设计模式\"><a href=\"#线程创建的设计模式\" class=\"headerlink\" title=\"线程创建的设计模式\"></a>线程创建的设计模式</h3><h4 id=\"静态代理模式：\"><a href=\"#静态代理模式：\" class=\"headerlink\" title=\"静态代理模式：\"></a>静态代理模式：</h4><ul>\n<li>Thread自己实现了Runnable接口，相当于代理类</li>\n<li>自己的类实现了Runnable接口，调用时需要new Thread()，参数传入我们自己的类，算是给代理类传真实对象</li>\n<li>然后代理类Thread帮我们执行相关代码</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><h4 id=\"Java线程有六个状态\"><a href=\"#Java线程有六个状态\" class=\"headerlink\" title=\"Java线程有六个状态\"></a>Java线程有六个状态</h4><ul>\n<li>NEW：线程被new就进入此状态</li>\n<li>RUNNABLE：调用start()方法进入此状态</li>\n<li>WAITING：调用了wait()， 调用了join()，调用了LockSupport.park方法</li>\n<li>TIMED_WAITING：<ul>\n<li>wait(long)</li>\n<li>sleep(long)</li>\n<li>join(long)</li>\n<li>LockSupport.parkNanos(long)</li>\n<li>LockSupport.parkUntil(long)</li>\n</ul>\n</li>\n<li>BLOCKED：获取synchorized锁对象时，拿不到锁对象</li>\n<li>TERMINATED：<ul>\n<li>执行完成</li>\n<li>调用了stop()方法，不推荐使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"从WAITING或TIMED-WAITING唤醒\"><a href=\"#从WAITING或TIMED-WAITING唤醒\" class=\"headerlink\" title=\"从WAITING或TIMED_WAITING唤醒\"></a>从WAITING或TIMED_WAITING唤醒</h4><ul>\n<li>notify()</li>\n<li>notifyAll()</li>\n<li>LockSupport.unpark()</li>\n</ul>\n<h4 id=\"RUNNABLE状态\"><a href=\"#RUNNABLE状态\" class=\"headerlink\" title=\"RUNNABLE状态\"></a>RUNNABLE状态</h4><ul>\n<li>在OS的进程，有就绪态和运行态，在Java中把这两个状态合二为一了，因为JVM设计者认为，关于线程的调度，属于CPU管理的，与Java无关</li>\n<li>处于RUNABLE状态的线程调用yield()方法可以进入Ready状态</li>\n</ul>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h4 id=\"线程池的作用\"><a href=\"#线程池的作用\" class=\"headerlink\" title=\"线程池的作用\"></a>线程池的作用</h4><ul>\n<li>方便对线程进行管理</li>\n<li>减小线程切换的开销</li>\n<li>加快响应速度</li>\n<li>控制并发量</li>\n<li>方便复用线程</li>\n</ul>\n<h4 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h4><h5 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h5><p><strong>参数</strong>:</p>\n<ul>\n<li>核心线程数corePoolSize</li>\n<li>最大线程数 maximumPoolSize(非核心线程数就是两者差maximumPoolSize -corePoolSize)</li>\n<li>线程保活时间keepAliveTime</li>\n<li>时间单位unit</li>\n<li>阻塞队列workQueue<ul>\n<li>LinkedBlockingQueue FIFO执行，没有界限大小</li>\n<li>ArrayBlockingQueue 有界限大小</li>\n<li>DelayWorkQueue</li>\n<li>SynchronousQueue</li>\n</ul>\n</li>\n<li>线程工厂threadFactory</li>\n<li>拒绝策略Handler<ul>\n<li>AbortPolicy默认的拒绝策略[直接抛出异常]</li>\n<li>CallerRunsPolicy将后续的任务交给其调用者执行[并没有拒绝]</li>\n<li>DiscardPolicy将后来的任务默默丢弃</li>\n<li>DiscardOldPolicy将最老的任务丢弃</li>\n</ul>\n</li>\n<li>线程池工作原理<ol>\n<li>创建线程池（此时池内没有线程）</li>\n<li>接到任务，立刻创建线程</li>\n<li>继续接收任务，当线程池数量达到了核心线程数量，就放入阻塞队列</li>\n<li>任务继续增加，阻塞队列满了，创建线程</li>\n<li>如果任务继续增加，达到了最大线程数量，此时根据不同的拒绝策略进行拒绝</li>\n<li>线程闲下来时，如果此时的线程数量大于核心线程数，那么多于核心线程数的线程会被销毁</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"如何执行任务\"><a href=\"#如何执行任务\" class=\"headerlink\" title=\"如何执行任务\"></a>如何执行任务</h5><ul>\n<li>execute（Runnable） 执行run方法，没有返回值</li>\n<li>submit 有三种参数，都会返回一个Future接口对象<ul>\n<li>Runnable接口</li>\n<li>Callable接口</li>\n<li>Runnable接口，T result 将结果放在result内</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"内部核心类Worker\"><a href=\"#内部核心类Worker\" class=\"headerlink\" title=\"内部核心类Worker\"></a>内部核心类Worker</h5><ul>\n<li>线程池内部的Worker类，继承了AQS，实现了Runnable</li>\n<li>线程执行Worker，Worker不断从阻塞队列里获取任务来执行</li>\n</ul>\n<h5 id=\"终止线程的四种方式\"><a href=\"#终止线程的四种方式\" class=\"headerlink\" title=\"&#x3D;&#x3D;终止线程的四种方式&#x3D;&#x3D;\"></a>&#x3D;&#x3D;终止线程的四种方式&#x3D;&#x3D;</h5><ul>\n<li>正常结束</li>\n<li>使用标志符号volatile boolean exit 循环判断exit状态</li>\n<li>interrupt<ul>\n<li>线程未阻塞状态 isInterrupted()判断，如果为true就中断</li>\n<li>线程阻塞状态捕获Interrupt异常，break退出</li>\n</ul>\n</li>\n<li>stop() 不推荐</li>\n</ul>\n<h5 id=\"非核心线程延迟死亡是如何实现的？\"><a href=\"#非核心线程延迟死亡是如何实现的？\" class=\"headerlink\" title=\"非核心线程延迟死亡是如何实现的？\"></a>非核心线程延迟死亡是如何实现的？</h5><ul>\n<li>通过阻塞队列poll()，让线程等待一段时间，如果没有取到任务，则线程死亡</li>\n</ul>\n<h5 id=\"核心线程为什么不死？\"><a href=\"#核心线程为什么不死？\" class=\"headerlink\" title=\"核心线程为什么不死？\"></a>核心线程为什么不死？</h5><ul>\n<li>通过阻塞队列take()，让线程一直等待，直到获取到任务</li>\n<li>可以使用allowCoreThreadTimeOut(true)让线程死亡</li>\n</ul>\n<h4 id=\"Java已经实现的四种线程池\"><a href=\"#Java已经实现的四种线程池\" class=\"headerlink\" title=\"Java已经实现的四种线程池\"></a>Java已经实现的四种线程池</h4><blockquote>\n<p>通过ExecutorService调用（不推荐使用）</p>\n</blockquote>\n<h5 id=\"newSingleThreadExceutor\"><a href=\"#newSingleThreadExceutor\" class=\"headerlink\" title=\"newSingleThreadExceutor\"></a>newSingleThreadExceutor</h5><ul>\n<li>核心线程数和最大线程数都为1</li>\n<li>阻塞队列为LinkedBlockingQueue</li>\n</ul>\n<h5 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h5><ul>\n<li>核心线程数自己指定</li>\n<li>最大线程数为Integer.MAX_VALUE</li>\n<li>阻塞队列为一个DelayWorkQueue</li>\n<li>返回一个ExcutorService的子类ScheduledExcutorService 调用scheduleAtFixedRate(),可以定时执行传入三个参数：初始延迟时间，执行周期，时间单位</li>\n</ul>\n<h5 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h5><ul>\n<li>核心线程数为0</li>\n<li>最大线程数为Integer.MAX_VALUE</li>\n<li>保活时间为60s</li>\n<li>阻塞队列是SynchronousQueue</li>\n</ul>\n<h5 id=\"newFixThreadPool\"><a href=\"#newFixThreadPool\" class=\"headerlink\" title=\"newFixThreadPool\"></a>newFixThreadPool</h5><ul>\n<li>核心线程数和最大线程数一样，是一个值</li>\n<li>LinkedBlockingQueue</li>\n</ul>\n<blockquote>\n<p>为什么不推荐使用（且阿里手册不推荐使用Executors）？</p>\n<ul>\n<li>FixedThreadPool和SingleThreadExecutor中的阻塞队列是无界的，如果没有适当的管理任务提交的速率，可能会导致内存溢出</li>\n<li>CachedThreadPool可以创建的线程数量是Integer.MAX_VALUE，会导致创建太多线程，导致系统资源耗尽，如操作系统能打开的文件描述符数量限制</li>\n<li>ScheduledThreadPool通常用于延迟执行或定期执行任务，如果不正确关闭，可能会导致内存泄漏（内存泄漏的可能原因之一）</li>\n<li>Executors没有提供良好的关闭机制，直接使用shutdown()或shutdownNow()可能会导致正在执行的任务被中断或者丢失</li>\n<li>参数都是定的，不灵活</li>\n</ul>\n</blockquote>\n<h4 id=\"线程池的状态\"><a href=\"#线程池的状态\" class=\"headerlink\" title=\"线程池的状态\"></a>线程池的状态</h4><blockquote>\n<p>成员变量AtomicInteger ctl 用来存储当前的线程数量及线程池状态</p>\n</blockquote>\n<h5 id=\"高3位—线程池五种状态之一\"><a href=\"#高3位—线程池五种状态之一\" class=\"headerlink\" title=\"高3位—线程池五种状态之一\"></a>高3位—线程池五种状态之一</h5><ul>\n<li>RUNNING          -1 [创建后处于的状态]</li>\n<li>SHUTDOWN      0  [线程池调用SHUTDOWN进入的状态不会接受新任务，但是会将旧任务继续执行完成]</li>\n<li>STOP                     1   [调用shutDownNow进入STOP状态，线程池不能接收新的任务，阻塞队列中的任务也会被丢弃]</li>\n<li>TIDYING             2  [所有任务终止， ctl记录任务数量为0就会变为这个状态]</li>\n<li>TERMINATED  3 [执行了terminated方法，进入此状态]</li>\n</ul>\n<h5 id=\"底29位\"><a href=\"#底29位\" class=\"headerlink\" title=\"底29位\"></a>底29位</h5><p>存储当前线程池数量</p>\n<hr>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"锁的分类\"><a href=\"#锁的分类\" class=\"headerlink\" title=\"锁的分类\"></a>锁的分类</h3><h4 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"乐观锁与悲观锁\"></a>乐观锁与悲观锁</h4><h5 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h5><ul>\n<li>认为读多写少，不会上锁</li>\n<li>CAS就是乐观锁</li>\n</ul>\n<h5 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h5><ul>\n<li>认为写多，不管是读还是写都会上锁，阻止其他线程</li>\n<li>synchronized就是悲观锁</li>\n</ul>\n<h4 id=\"公平锁与非公平锁\"><a href=\"#公平锁与非公平锁\" class=\"headerlink\" title=\"公平锁与非公平锁\"></a>公平锁与非公平锁</h4><h5 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h5><p>不允许插队，只能老老实实排队等待执行</p>\n<h5 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h5><p>可以插队，如果线程进入的同时，发现当前任务刚好处于切换状态，那么就插队，优先执行</p>\n<h4 id=\"重入锁\"><a href=\"#重入锁\" class=\"headerlink\" title=\"重入锁\"></a>重入锁</h4><p>一个线程得到锁后，执行线程自己本身的方法，不需要再去获得锁</p>\n<h4 id=\"共享锁与独占锁\"><a href=\"#共享锁与独占锁\" class=\"headerlink\" title=\"共享锁与独占锁\"></a>共享锁与独占锁</h4><h5 id=\"独占锁\"><a href=\"#独占锁\" class=\"headerlink\" title=\"独占锁\"></a>独占锁</h5><ul>\n<li>写锁</li>\n<li>悲观策略，无论读还是写都会上锁</li>\n<li>只能有一个线程占有</li>\n</ul>\n<h5 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a>共享锁</h5><ul>\n<li>读锁</li>\n<li>可以有很多个线程获取共享锁</li>\n<li>共享锁期间，不期望有写操作，如果真的有写操作，需要升级为独占锁</li>\n</ul>\n<h3 id=\"核心锁\"><a href=\"#核心锁\" class=\"headerlink\" title=\"核心锁\"></a>核心锁</h3><h4 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h4><blockquote>\n<p>（属于乐观锁、自旋锁）</p>\n</blockquote>\n<h5 id=\"比较并设置\"><a href=\"#比较并设置\" class=\"headerlink\" title=\"比较并设置\"></a>比较并设置</h5><ul>\n<li>三个参数：期望值、旧值、新值</li>\n<li>如果期望值等于旧值，就把新值赋值</li>\n</ul>\n<h5 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h5><ul>\n<li>ABA问题：CAS比较的空档期，有一个线程更改了值，但是最后又改了回来，导致CAS并没有发现其他线程变更过此值<ul>\n<li>解决：设置一个版本号或者时间戳，比较这个版本号或时间戳</li>\n<li>Java的解决方式：用AtomicStampedReference  版本号</li>\n</ul>\n</li>\n<li>循环时间长，持续占有CPU资源（因为自旋）</li>\n<li>只能保证一个变量的原子性操作问题</li>\n</ul>\n<h4 id=\"synchorized\"><a href=\"#synchorized\" class=\"headerlink\" title=\"synchorized\"></a>synchorized</h4><blockquote>\n<p>（属于悲观锁、可重入锁、非公平锁）</p>\n</blockquote>\n<h5 id=\"修饰方法\"><a href=\"#修饰方法\" class=\"headerlink\" title=\"修饰方法\"></a>修饰方法</h5><ul>\n<li>修饰静态方法：锁的是class对象，相当于全局锁</li>\n<li>修饰动态方法：锁的是实例对象，即this</li>\n</ul>\n<h5 id=\"修饰代码块\"><a href=\"#修饰代码块\" class=\"headerlink\" title=\"修饰代码块\"></a>修饰代码块</h5><ul>\n<li>锁住传入的对象</li>\n</ul>\n<h5 id=\"锁升级的过程\"><a href=\"#锁升级的过程\" class=\"headerlink\" title=\"锁升级的过程\"></a>锁升级的过程</h5><blockquote>\n<p>在JDK1.6之前全为重量级锁，在JDK1.6引入了锁升级过程</p>\n</blockquote>\n<h6 id=\"四种锁状态\"><a href=\"#四种锁状态\" class=\"headerlink\" title=\"四种锁状态\"></a>四种锁状态</h6><ul>\n<li>无锁</li>\n<li>偏向锁</li>\n<li>轻量级锁</li>\n<li>重量级锁</li>\n</ul>\n<h6 id=\"锁状态在对象头中存放\"><a href=\"#锁状态在对象头中存放\" class=\"headerlink\" title=\"锁状态在对象头中存放\"></a>锁状态在对象头中存放</h6><ul>\n<li>无锁与偏向锁都为01，偏向锁有专门的一位标识</li>\n<li>轻量级锁00</li>\n<li>重量级锁10</li>\n</ul>\n<h6 id=\"对象的结构\"><a href=\"#对象的结构\" class=\"headerlink\" title=\"对象的结构\"></a>对象的结构</h6><ul>\n<li>对象头12字节<ul>\n<li>markword 8字节<ul>\n<li>hashCode</li>\n<li>GC信息 对象分代信息</li>\n<li>锁信息</li>\n</ul>\n</li>\n<li>classpoint 4 字节</li>\n</ul>\n</li>\n<li>实例数据</li>\n<li>对齐填充</li>\n</ul>\n<h6 id=\"锁升级过程\"><a href=\"#锁升级过程\" class=\"headerlink\" title=\"锁升级过程\"></a>锁升级过程</h6><ul>\n<li>一开始为无锁状态</li>\n<li>当线程要去获取锁，将锁给他，并将锁的状态切换为偏向锁，并且将锁的状态切换为偏向锁，并且将该线程的ID记录在对象头中</li>\n<li>当线程又要锁时，判断是否为当前线程ID，是就允许进入，不是就进行一次CAS判断，替换当前线程ID操作成功就允许进入，不成功就升级为重量级锁</li>\n<li>轻量级锁能够进行多次CAS操作和自旋判断，如果还是不能满足当前的竞争状况就会升级为重量级锁</li>\n<li>重量级锁的实现是由OS的MuteX实现的</li>\n</ul>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><blockquote>\n<p>Lock的提出是为了解决synchorized锁还是太重的问题，但是一个悲观锁，锁住的时候，其他线程甚至不能进行读操作</p>\n<p>可实现公平、非公平、可重入、排它锁（默认）</p>\n</blockquote>\n<h5 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h5><ul>\n<li>lock() 若处于空闲状态获取到锁</li>\n<li>unLock 释放锁</li>\n<li>tryLock() 如果获取不到锁，不会一直等待，会继续向下执行代码</li>\n<li>newCondition() 创建一个Condition对象</li>\n<li>lockInterruptibly() 如果线程为了取锁而进入了等待状态，此时可以使用Interrupt中断其等待状态</li>\n</ul>\n<h5 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h5><blockquote>\n<p>是Lock接口的一个实现</p>\n</blockquote>\n<ul>\n<li>可重入锁、默认为非安全锁(可重入锁的非安全版本)</li>\n<li>默认是一个写锁</li>\n<li>构造是可以定是否为安全锁（即是否公平）</li>\n<li>ReentrantLock相对于synchorized<ul>\n<li>可以创建为公平锁</li>\n<li>可以创建Condition对象，绑定多个条件</li>\n<li>实现了等待可中断</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h4><blockquote>\n<p>ReentrantLockReadWriteLock</p>\n<p>将读操作和写操作分离</p>\n</blockquote>\n<h5 id=\"遵从四个原则\"><a href=\"#遵从四个原则\" class=\"headerlink\" title=\"遵从四个原则\"></a>遵从四个原则</h5><ul>\n<li>允许多个线程读</li>\n<li>只允许一个线程写</li>\n<li>读的时候不许写</li>\n<li>写的时候不许读</li>\n</ul>\n<h5 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h5><ul>\n<li>readLock() 获取读锁</li>\n<li>writeLock() 获取写锁</li>\n<li>lock()</li>\n<li>unlock()</li>\n<li>newCondition() 只有写锁可以生成条件</li>\n</ul>\n<h5 id=\"锁的升级降级\"><a href=\"#锁的升级降级\" class=\"headerlink\" title=\"锁的升级降级\"></a>锁的升级降级</h5><ul>\n<li>不支持升级  指从读锁变为写锁</li>\n<li>支持降级 从写锁变为读锁</li>\n</ul>\n<h5 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h5><blockquote>\n<p>ReentrantLock的实现依赖于内部的Sync类，继承自AQS</p>\n</blockquote>\n<p><strong>两种锁策略</strong></p>\n<ol>\n<li>公平锁<br>按照线程请求锁的顺序来分配锁</li>\n<li>非公平锁（默认）<br>使线程抢占到锁</li>\n</ol>\n<p><strong>加锁和解锁操作是通过调用AQS的acquire和release方法实现的</strong><br><strong>注意</strong></p>\n<ul>\n<li>在使用 <code>ReentrantLock</code> 时，需要注意正确管理锁的获取和释放，以避免死锁和性能问题。<ul>\n<li>应该总是在 <code>finally</code> 块中调用 <code>unlock()</code> 方法，以确保锁能够在所有情况下都被正确释放。此外，<code>ReentrantLock</code> 还提供了 <code>tryLock()</code>、<code>tryLock(long timeout, TimeUnit unit)</code> 和 <code>lockInterruptibly()</code> 等方法，以支持可中断的锁获取操作和带超时的锁获取操作</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"比较ReentrantLock和Synchronized\"><a href=\"#比较ReentrantLock和Synchronized\" class=\"headerlink\" title=\"比较ReentrantLock和Synchronized\"></a>比较ReentrantLock和Synchronized</h5><table>\n<thead>\n<tr>\n<th align=\"left\">比较方面</th>\n<th>Synchronized</th>\n<th>ReentrantLock（实现了lock接口）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">原始构成</td>\n<td>它是java语言的关键字，是原生语法层<br/>面的互斥，需要ivm实现</td>\n<td>它是JDK 1.5之后提供的API层面的互斥锁类</td>\n</tr>\n<tr>\n<td align=\"left\">实现</td>\n<td>通过JVM加锁解锁</td>\n<td>api层面的加锁解锁，需要手动释放锁</td>\n</tr>\n<tr>\n<td align=\"left\">代码编写</td>\n<td>采用synchronized不需要用户去手动释<br/>放锁，当synchronized方法或者<br/>synchronized代码块执行完之后，系统<br/>会自动让线程释放对锁的占用，更安<br/>全</td>\n<td>而ReentrantLock则必须要用户去手动释放锁，如果没有主动释放锁，就有<br/>可能导致出现死锁现象。需要lock()和unlock0方法配合tny&#x2F;finally语句块来完<br/>成</td>\n</tr>\n<tr>\n<td align=\"left\">灵活性</td>\n<td>锁的范围是整个方法或synchronized块部分</td>\n<td>Lock因为是方法调用，可以跨方法，灵活性更大</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><blockquote>\n<p>修饰变量的</p>\n</blockquote>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><ul>\n<li>即一个线程对变量的修改，其他线程是可以看到变化的</li>\n</ul>\n<h5 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h5><ul>\n<li>每次强制每一个线程对共享变量的读写写回主存</li>\n<li>缓存一致性协议，对被修饰变量的修改会发出信号通知其他线程去主存中读</li>\n</ul>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><ul>\n<li>可以保证对该变量的操作保持原来的顺序，不会被重排序</li>\n</ul>\n<h5 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h5><ul>\n<li>编译器重排序</li>\n<li>内存重排序</li>\n<li>CPU流水线重排序</li>\n</ul>\n<h5 id=\"实现原理-happens-before-原则-cpu内存屏障指令\"><a href=\"#实现原理-happens-before-原则-cpu内存屏障指令\" class=\"headerlink\" title=\"实现原理 happens before 原则 + cpu内存屏障指令\"></a>实现原理 happens before 原则 + cpu内存屏障指令</h5><blockquote>\n<p>只能保证原子操作的变化</p>\n</blockquote>\n<h3 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h3><blockquote>\n<p>是 Java 中的一个类，属于 <code>java.util.concurrent.atomic</code> 包。它提供了对基本整数类型 <code>int</code> 的原子操作。这意味着你可以在多线程环境中安全地执行对 <code>int</code> 类型的变量的增加、减少、设置和更新等操作，而不需要担心线程间的冲突</p>\n</blockquote>\n<ul>\n<li>使用一个volatile记录值</li>\n<li>更改值时使用while进行cas判断</li>\n</ul>\n<hr>\n<h2 id=\"活跃性问题\"><a href=\"#活跃性问题\" class=\"headerlink\" title=\"活跃性问题\"></a>活跃性问题</h2><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><h4 id=\"死锁四个必要条件\"><a href=\"#死锁四个必要条件\" class=\"headerlink\" title=\"死锁四个必要条件\"></a>死锁四个必要条件</h4><ul>\n<li>互斥性：一次只能有一个线程使用资源</li>\n<li>请求和保持条件：即一个线程获取到资源，还需要其他资源</li>\n<li>不可剥夺条件：线程的资源不可以被抢夺</li>\n<li>环路等待条件：形成环路，会造成死锁</li>\n</ul>\n<h4 id=\"如果解决死锁\"><a href=\"#如果解决死锁\" class=\"headerlink\" title=\"如果解决死锁\"></a>如果解决死锁</h4><ul>\n<li>互斥性是共享资源的本质，不可破坏</li>\n<li>破坏请求和保持：线程一次就获取任务所需的所有资源，一同获取，一同释放</li>\n<li>破坏不可剥夺：synchorized做不到，Lock可以做到</li>\n<li>破坏环路等待条件：给资源一个字段便于排序，两个相同的操作获取锁的顺序需要一致（但是限制了资源的增长）</li>\n</ul>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><blockquote>\n<p>线程之间相互谦让，导致谁也没有执行</p>\n<p>解决活锁：可以设置一个随机的等待时间</p>\n</blockquote>\n<h3 id=\"饥饿\"><a href=\"#饥饿\" class=\"headerlink\" title=\"饥饿\"></a>饥饿</h3><blockquote>\n<p>线程无法获取资源，无法运行</p>\n</blockquote>\n<h4 id=\"三个根源问题\"><a href=\"#三个根源问题\" class=\"headerlink\" title=\"三个根源问题\"></a>三个根源问题</h4><ul>\n<li>资源设置为无限 不可能</li>\n<li>避免持有锁的对象长时间执行 很难实现</li>\n<li>公平分配资源 公平锁</li>\n</ul>\n<hr>\n<h2 id=\"管程模型\"><a href=\"#管程模型\" class=\"headerlink\" title=\"管程模型\"></a>管程模型</h2><blockquote>\n<p>也叫Moniter,用来处理并发问题的一种模型</p>\n<p>OS使用信号量这种管程模型处理并发问题</p>\n<p>Java中封装了synchronized来处理并发问题</p>\n</blockquote>\n<h3 id=\"Synchronized-wait-notify-模型\"><a href=\"#Synchronized-wait-notify-模型\" class=\"headerlink\" title=\"Synchronized-wait-notify 模型\"></a>Synchronized-wait-notify 模型</h3><h4 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a>API</h4><ul>\n<li>wati()            移入等待队列</li>\n<li>notify()        唤醒一个等待队列中的数据</li>\n<li>notifyAll()  唤醒所有线程</li>\n</ul>\n<p><strong>若非有特殊需要，使用notifyAll()。 因为notify()是随机唤醒一个线程，很有可能唤醒的这个线程不需要这个资源，白白唤醒</strong> 。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><hr>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><blockquote>\n<p>AQS同步抽象队列 重写 tryLock、tryRelease方法</p>\n</blockquote>\n<h4 id=\"结构特点\"><a href=\"#结构特点\" class=\"headerlink\" title=\"结构特点\"></a>结构特点</h4><ul>\n<li><p>维护了一个volatile修饰的state，关于state有三个方法</p>\n<ul>\n<li>getState()</li>\n<li>setState()</li>\n<li>compareAndSetState()</li>\n</ul>\n<p><em>只能有一个线程抢到state资源进行执行，其他线程会在双向链表中等待</em></p>\n</li>\n<li><p>ReentrantLock的本质就是有一个Sync类，这个类继承了AQS</p>\n</li>\n<li><p>维护了一个双端链表</p>\n</li>\n</ul>\n<h4 id=\"实现的逻辑\"><a href=\"#实现的逻辑\" class=\"headerlink\" title=\"实现的逻辑\"></a>实现的逻辑</h4><ul>\n<li>继承AbstractQueuedSynchorizer抽象类</li>\n<li>实现tryAcquire() 方法 <em>尝试获取锁，与lock不同，该方法不会使当前线程阻塞，锁不可用立即返回false</em></li>\n<li>实现tryRelease() 方法 <em>尝试释放锁 与unlock不同，同上</em></li>\n<li>实现 isHeldExdclusively() 方法 可以知道当前执行的是否为自己的线程</li>\n</ul>\n<h4 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h4><ul>\n<li>ReentrantLock</li>\n<li>线程池的Worker</li>\n<li>JDK1.7的ConcurrenthashMap的segment数组分段锁</li>\n</ul>\n<h4 id=\"源码分析-1\"><a href=\"#源码分析-1\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p><strong>继承自AbstractOwnableSysnchronizer抽象类，并且实现了Serialable接口，可以进行序列化</strong></p>\n<h5 id=\"两个内部类类\"><a href=\"#两个内部类类\" class=\"headerlink\" title=\"两个内部类类\"></a>两个内部类类</h5><ol>\n<li>Node类（分为共享模式和独占模式）<br>其中每个被阻塞的线程都会被封装成一个Node节点，放入队列。每个节点包含了一个Thread类型的引用，每个节点都存在一个状态<ul>\n<li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li>\n<li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作</li>\n<li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中</li>\n<li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li>\n<li>值为0，表示当前节点在sync queue中，等待着获取锁。</li>\n</ul>\n</li>\n<li>ConditionObject类</li>\n</ol>\n<h5 id=\"类的属性\"><a href=\"#类的属性\" class=\"headerlink\" title=\"类的属性\"></a>类的属性</h5><p>包含了头节点head，尾结点tail，状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址</p>\n<h5 id=\"核心方法-acquire\"><a href=\"#核心方法-acquire\" class=\"headerlink\" title=\"核心方法 - acquire\"></a>核心方法 - acquire</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>以独占模式获取资源，忽略中断</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240812230642510.png\" alt=\"image-20240812230642510\"></p>\n<ul>\n<li>首先调用tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，</li>\n<li>如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。</li>\n<li>若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。</li>\n<li>调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。</li>\n</ul>\n<p><strong>addWaiter方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加等待者</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Node <span class=\"title function_\">addWaiter</span><span class=\"params\">(Node mode)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新生成一个结点，默认为独占模式</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    <span class=\"comment\">// 保存尾结点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">pred</span> <span class=\"operator\">=</span> tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 尾结点不为空，即已经被初始化</span></span><br><span class=\"line\">        <span class=\"comment\">// 将node结点的prev域连接到尾结点</span></span><br><span class=\"line\">        node.prev = pred; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123; <span class=\"comment\">// 比较pred是否为尾结点，是则将尾结点设置为node </span></span><br><span class=\"line\">            <span class=\"comment\">// 设置尾结点的next域为node</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node; <span class=\"comment\">// 返回新生成的结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node); <span class=\"comment\">// 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Node <span class=\"title function_\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">// 无限循环，确保结点能够成功入队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 保存尾结点</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 尾结点为空，即还没被初始化</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>())) <span class=\"comment\">// 头节点为空，并设置头节点为新生成的结点</span></span><br><span class=\"line\">                tail = head; <span class=\"comment\">// 头节点与尾结点都指向同一个新生结点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 尾结点不为空，即已经被初始化过</span></span><br><span class=\"line\">            <span class=\"comment\">// 将node结点的prev域连接到尾结点</span></span><br><span class=\"line\">            node.prev = t; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123; <span class=\"comment\">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class=\"line\">                <span class=\"comment\">// 设置尾结点的next域为node</span></span><br><span class=\"line\">                t.next = node; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> t; <span class=\"comment\">// 返回尾结点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>acquireQueued方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 标志</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 中断标志</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取node节点的前驱结点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor(); </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">// 前驱为头节点并且成功获得锁</span></span><br><span class=\"line\">                setHead(node); <span class=\"comment\">// 设置头节点</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>; <span class=\"comment\">// 设置标志</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>判断前驱节点是否为head，并且是否成功获取资源</li>\n<li>1满足，返回interrupt，表示没有被中断过，设置当前节点为head</li>\n<li>不满足，则判断是否需要park当前线程，如果前驱节点的状态为SIGNAL，park当前节点，否则不进行park操作</li>\n</ul>\n<p>补充：<br><strong>houldParkAfterFailedAcquire和parkAndCheckInterrupt方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取前驱结点的状态</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL) <span class=\"comment\">// 状态为SIGNAL，为-1</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">            * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以进行park操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 表示状态为CANCELLED，为1</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">            * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>); <span class=\"comment\">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 赋值pred结点的next域</span></span><br><span class=\"line\">        pred.next = node; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">            * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"comment\">// 比较并设置前驱结点的状态为SIGNAL</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不能进行park操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行park操作并且返回该线程是否被中断</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">parkAndCheckInterrupt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在许可可用之前禁用当前线程，并且设置了blocker</span></span><br><span class=\"line\">    LockSupport.park(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted(); <span class=\"comment\">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><blockquote>\n<p>让一个线程等待其他线程执行完再执行</p>\n<p>当前值不为0就一直阻塞</p>\n<p>为0就允许所有线程通过</p>\n<p><em>不用contDownLatch也可以用父子线程调用join实现</em></p>\n</blockquote>\n<h4 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li>new CountDownLatch(int) </li>\n<li>await() 进入等待状态</li>\n<li>countDown() 将值减一</li>\n</ul>\n<h3 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h3><blockquote>\n<p>两个线程之间交换资源</p>\n<p>支持泛型，参数可以传流</p>\n</blockquote>\n<h4 id=\"核心API-1\"><a href=\"#核心API-1\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li><p>new Exchanger&lt;&gt;() </p>\n</li>\n<li><p>exchange()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExchangerExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Exchanger&lt;String&gt; exchanger = <span class=\"keyword\">new</span> <span class=\"title class_\">Exchanger</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">data1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Thread1 Data&quot;</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread1 has data to exchange: &quot;</span> + data1);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">//模拟一些计算需要2秒</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">data2</span> <span class=\"operator\">=</span> exchanger.exchange(data1);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread1 received:&quot;</span> + data2);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">data2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Thread2 Data&quot;</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread2 has data to exchange: &quot;</span> + data2);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 模拟一些计算</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">data1</span> <span class=\"operator\">=</span> exchanger.exchange(data2);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread2 received: &quot;</span> + data1);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h3><blockquote>\n<p>解决CountDownLatch不可复用的问题<br>每当值变为0，自动重置</p>\n</blockquote>\n<h4 id=\"核心API-2\"><a href=\"#核心API-2\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li><p>new CyclicBarrier(int, Runnable) 一个等待的值， 一个值变为0后要执行的方法</p>\n</li>\n<li><p>await() 计数器减一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierExamples</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">numThreads</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">barrier</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(numThreads, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;All threads have reached the barrier. Let&#x27;s continue.&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(barrier));</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CyclicBarrier barrier;</span><br><span class=\"line\"></span><br><span class=\"line\">        Worker(CyclicBarrier barrier) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.barrier = barrier;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread is doing some work.&quot;</span>);</span><br><span class=\"line\">                Thread.sleep((<span class=\"type\">long</span>) (Math.random() * <span class=\"number\">3000</span>));</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread has reached the barrier.&quot;</span>);</span><br><span class=\"line\">                barrier.await(); <span class=\"comment\">// 等待其他线程到达栅栏</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread continues to do its work after the barrier.&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><blockquote>\n<p> Java 中的一个同步类，位于 <code>java.util.concurrent</code> 包中。它是一个计数信号量，用于控制同时访问特定资源的线程数量。<code>Semaphore</code> 通过维护一组许可证（permits）来实现同步，线程在访问资源之前必须先获得许可证，使用完毕后释放许可证。</p>\n</blockquote>\n<h4 id=\"核心API-3\"><a href=\"#核心API-3\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li><p>new Semaphore(int) 可共享资源的数量</p>\n</li>\n<li><p>acquire() 资源数-1 如果为0 进入等待状态</p>\n</li>\n<li><p>release() 资源数+ 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SemaphoreExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Semaphore</span> <span class=\"variable\">semaphore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 初始化一个许可证数量为2的Semaphore</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建并启动5个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Task</span>(semaphore, i));</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> taskId;</span><br><span class=\"line\"></span><br><span class=\"line\">        Task(Semaphore semaphore, <span class=\"type\">int</span> taskId) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.semaphore = semaphore;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.taskId = taskId;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Task &quot;</span> + taskId + <span class=\"string\">&quot; is trying to acquire a permit.&quot;</span>);</span><br><span class=\"line\">                semaphore.acquire(); <span class=\"comment\">// 获取一个许可证，如果没有可用的许可证，线程将被阻塞</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Task &quot;</span> + taskId + <span class=\"string\">&quot; has acquired a permit.&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 模拟任务执行</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Task &quot;</span> + taskId + <span class=\"string\">&quot; is releasing the permit.&quot;</span>);</span><br><span class=\"line\">                semaphore.release(); <span class=\"comment\">// 释放许可证</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"StampedLock\"><a href=\"#StampedLock\" class=\"headerlink\" title=\"StampedLock\"></a>StampedLock</h3><blockquote>\n<p>JDK1.8引入</p>\n<p>三种锁模式 写锁 悲观度读 乐观读</p>\n</blockquote>\n<h4 id=\"核心API-4\"><a href=\"#核心API-4\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li>WriteLock()</li>\n<li>readLock()</li>\n<li>tryOptimisticRead()  获取乐观度</li>\n<li>validate(long) 传入邮戳，查看是否被写占用</li>\n<li>tryConvertToWriteLock() 尝试锁升级，直接从读锁转换为写锁</li>\n</ul>\n<h4 id=\"与ReadWriteLock区别\"><a href=\"#与ReadWriteLock区别\" class=\"headerlink\" title=\"与ReadWriteLock区别\"></a>与ReadWriteLock区别</h4><h5 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h5><ul>\n<li>支持乐观读</li>\n<li>支持锁升级</li>\n</ul>\n<h5 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h5><ul>\n<li>不支持Condition</li>\n<li>不是可重入锁</li>\n</ul>\n<h3 id=\"Future接口\"><a href=\"#Future接口\" class=\"headerlink\" title=\"Future接口\"></a>Future接口</h3><blockquote>\n<p><code>Future</code> 接口是 Java 并发 API 中的一个关键组件，位于 <code>java.util.concurrent</code> 包中。它代表了异步计算的结果，通常与 <code>ExecutorService</code> 一起使用，以便在另一个线程中执行任务并返回结果。</p>\n</blockquote>\n<h4 id=\"核心API-5\"><a href=\"#核心API-5\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li>get()获取计算结果 调用时如果线程没有结束，阻塞调用get()的线程</li>\n<li>get(timeout, unit) 超时则不再阻塞</li>\n<li>cancel() 取消任务</li>\n<li>isCanceled() 判断当前任务是否取消</li>\n<li>isDown() 判断当前任务是否已经完成</li>\n</ul>\n<h4 id=\"FutureTask工具类\"><a href=\"#FutureTask工具类\" class=\"headerlink\" title=\"FutureTask工具类\"></a>FutureTask工具类</h4><ul>\n<li>构造方法 可传两种参数<ul>\n<li>Runnable接口， T result</li>\n<li>Callable 接口</li>\n</ul>\n</li>\n<li>核心API<ul>\n<li>使用Future接口的API</li>\n</ul>\n</li>\n<li>使用<ul>\n<li>new Therad(FutureTask)</li>\n<li>调用get() 方法等待值返回</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><blockquote>\n<p>copyOnWriteArrayList</p>\n</blockquote>\n<h4 id=\"CWO的思想\"><a href=\"#CWO的思想\" class=\"headerlink\" title=\"CWO的思想\"></a>CWO的思想</h4><p>写时复制一份，既满足了写的需求，又可以读，不需要加锁，增加了效率</p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>迭代器只支持读，不支持删改</li>\n<li>读操作进行的同时，如果还有写操作，会将此数组复制一份，旧的用来读，新的用来写。<em>所以此时读的是一个快照，读不到更新后的数据</em></li>\n</ul>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><h4 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h4><h5 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>key是无序的</li>\n<li>底层实现与HashMap一样</li>\n<li>与HashMap不一样的是，不允许key value 为null 为什么？<ul>\n<li>防止出现语义误解返回值为null，不知道是不存在这个值还是存的null值</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"JDK1-7结构\"><a href=\"#JDK1-7结构\" class=\"headerlink\" title=\"JDK1.7结构\"></a>JDK1.7结构</h5><ul>\n<li>维护一个segment数组，每一个segment元素对应着一个HashEntry数组(与HashMap结构一致)<ul>\n<li>segment与hashEntry都是ConcurrentHashMap的内部类</li>\n<li>segment继承了ReentrantLock，一个segment就是一把锁</li>\n</ul>\n</li>\n<li>维护了负载因子，默认0.75</li>\n<li>维护了并发度，默认16<ul>\n<li><em>并发度</em>：因为采用分段锁，并发度决定了分段的数量，默认是16，就是16个线程可以在16个不同的分段上进行操作，提高并发性能</li>\n</ul>\n</li>\n<li>segment数组的最小长度为2</li>\n<li>segment数组的最大长度为2^16</li>\n<li>扩容时与HashMap没什么区别，就是加了锁再扩容</li>\n</ul>\n<h5 id=\"JDK1-8结构\"><a href=\"#JDK1-8结构\" class=\"headerlink\" title=\"JDK1.8结构\"></a>JDK1.8结构</h5><h6 id=\"取消了分段锁-为什么？\"><a href=\"#取消了分段锁-为什么？\" class=\"headerlink\" title=\"取消了分段锁 为什么？\"></a>取消了分段锁 为什么？</h6><p>当有热点数据时，往往访问的是同一个分段锁下的，这样并发程度高</p>\n<h6 id=\"使用CAS-synchronized来保证线程安全\"><a href=\"#使用CAS-synchronized来保证线程安全\" class=\"headerlink\" title=\"使用CAS + synchronized来保证线程安全\"></a>使用CAS + synchronized来保证线程安全</h6><h6 id=\"put操作\"><a href=\"#put操作\" class=\"headerlink\" title=\"put操作\"></a>put操作</h6><ul>\n<li>如果放在数组上（即还没有拉链）使用CAS操作判断</li>\n<li>如果放在链表或者树上，加synchronized</li>\n</ul>\n<h6 id=\"get操作\"><a href=\"#get操作\" class=\"headerlink\" title=\"get操作\"></a>get操作</h6><p>CAS判断一次，就可以无锁的进行获取</p>\n<h6 id=\"扩容时使用并发机制\"><a href=\"#扩容时使用并发机制\" class=\"headerlink\" title=\"扩容时使用并发机制\"></a>扩容时使用并发机制</h6><ul>\n<li>使用sizeCtl控制<ul>\n<li>-1代表正在初始化</li>\n<li>-N代表正在扩容</li>\n<li>整数表示要扩容的阈值</li>\n</ul>\n</li>\n<li>最少每一个线程完成16个桶的迁移工作</li>\n<li>如果不满16个就由一个线程来完成迁移工作</li>\n<li>更快的index计算方法，只需要运算1bit</li>\n</ul>\n<h6 id=\"为什么不用HashTable保证线程安全-？\"><a href=\"#为什么不用HashTable保证线程安全-？\" class=\"headerlink\" title=\"为什么不用HashTable保证线程安全 ？\"></a>为什么不用HashTable保证线程安全 ？</h6><p>效率太低，直接加的synchronized锁 </p>\n<h4 id=\"ConcurrentSkipListMap\"><a href=\"#ConcurrentSkipListMap\" class=\"headerlink\" title=\"ConcurrentSkipListMap\"></a>ConcurrentSkipListMap</h4><ul>\n<li>Key有序</li>\n<li>底层是跳表</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><h4 id=\"copyOnWriteArraySet\"><a href=\"#copyOnWriteArraySet\" class=\"headerlink\" title=\"copyOnWriteArraySet\"></a>copyOnWriteArraySet</h4><h4 id=\"concurrentSkipListMap\"><a href=\"#concurrentSkipListMap\" class=\"headerlink\" title=\"concurrentSkipListMap\"></a>concurrentSkipListMap</h4><h3 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h3><h4 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h4><h4 id=\"ConcurrentLinkedQueue\"><a href=\"#ConcurrentLinkedQueue\" class=\"headerlink\" title=\"ConcurrentLinkedQueue\"></a>ConcurrentLinkedQueue</h4><h4 id=\"ConcurrentLinkedDeque\"><a href=\"#ConcurrentLinkedDeque\" class=\"headerlink\" title=\"ConcurrentLinkedDeque\"></a>ConcurrentLinkedDeque</h4><h4 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h4><h5 id=\"核心API-6\"><a href=\"#核心API-6\" class=\"headerlink\" title=\"核心API\"></a>核心API</h5><ul>\n<li>抛出异常<ul>\n<li>add()</li>\n<li>remove()</li>\n<li>element</li>\n</ul>\n</li>\n<li>返回特殊值<ul>\n<li>offer(long timeout, TimeUnit unit)<ul>\n<li>插入成功返回true,失败返回false</li>\n<li>也可以设置超时时间</li>\n</ul>\n</li>\n<li>poll(long timeout, TimeUnit unit)<ul>\n<li>设置超时时间</li>\n<li>用这个时间爱进行非核心线程的销毁</li>\n</ul>\n</li>\n<li>peek()</li>\n</ul>\n</li>\n<li>一直阻塞<ul>\n<li>put() 满则阻塞</li>\n<li>take() 没有元素则阻塞</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"实现类-1\"><a href=\"#实现类-1\" class=\"headerlink\" title=\"实现类\"></a>实现类</h5><ul>\n<li>ArrayBlockingQueue<ul>\n<li>实现有界的等待队列</li>\n<li>设置是否为公平锁</li>\n</ul>\n</li>\n<li>LinkedBlockingQueue 无限的阻塞队列</li>\n<li>DelayQueue设定延迟时间，延迟时间到了才能从DelayQueue中获取</li>\n<li>PorityBlockingQueue 优先阻塞队列维护优先级</li>\n<li>SynchronousQueue<ul>\n<li>没有容器存储不存储任何元素</li>\n<li>一个put必须等待一个take否则阻塞</li>\n<li>不是AQS的实现，是CAS的实现</li>\n<li>用在了newCachedThreadPool适用于短期的任务</li>\n</ul>\n</li>\n</ul>\n","categories":["八股","Java"],"tags":["Java","锁","线程"]},{"title":"JVM","url":"/2024/03/19/JVM/","content":"<h1 id=\"Java虚拟机-JVM\"><a href=\"#Java虚拟机-JVM\" class=\"headerlink\" title=\"Java虚拟机-JVM\"></a>Java虚拟机-JVM</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"为什么学习JVM？\"><a href=\"#为什么学习JVM？\" class=\"headerlink\" title=\"为什么学习JVM？\"></a>为什么学习JVM？</h3><p>项目管理、性能调优-程序员必备技能</p>\n<h3 id=\"虚拟机？\"><a href=\"#虚拟机？\" class=\"headerlink\" title=\"虚拟机？\"></a>虚拟机？</h3><ul>\n<li>虚拟机（Virtual Machine），虚拟计算机。是一款软件，具有计算机完整硬件功能的软件，大体上虚拟机可以分为系统虚拟机和程序虚拟机</li>\n<li>VMware属于系统虚拟机，完全对物理计算机的仿真，提供一个可运行完整操作系统的平台。程序虚拟机的典型代表是java虚拟机，专门为执行某个计算机程序而设计。<br>在java虚拟机中执行的指令称为java字节码指令</li>\n<li>Java虚拟机是一种执行java字节码文件的虚拟机，它拥有独立的运行机制</li>\n<li>Java技术的核心就是Java虚拟机，因为所有的java程序都要在java虚拟机内部运行</li>\n</ul>\n<h3 id=\"JVM作用？\"><a href=\"#JVM作用？\" class=\"headerlink\" title=\"JVM作用？\"></a>JVM作用？</h3><p> Java虚拟机负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器码指令执行，每一条java指令，java虚拟机中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>一次编译到处运行</li>\n<li>自动内存管理</li>\n<li>自动垃圾回收功能</li>\n</ol>\n<blockquote>\n<p>JVM不仅可以执行java字节码文件，还可以执行其他语言编译后的字节码文件，是一个跨语言平台</p>\n</blockquote>\n<h3 id=\"JVM-JRE-JDK\"><a href=\"#JVM-JRE-JDK\" class=\"headerlink\" title=\"JVM &amp; JRE &amp; JDK?\"></a>JVM &amp; JRE &amp; JDK?</h3><h4 id=\"JDK（ava-Development-Kit）\"><a href=\"#JDK（ava-Development-Kit）\" class=\"headerlink\" title=\"JDK（ava Development Kit）\"></a>JDK（ava Development Kit）</h4><ul>\n<li><strong>JRE（Java Runtime Environment）</strong>：JDK包含了一个完整的JRE，它允许Java程序运行。</li>\n<li><strong>编译器（javac）</strong>：用于将Java源代码编译成字节码的编译器。</li>\n<li><strong>开发工具</strong>：如<code>java</code>命令、<code>javap</code>（查看编译后的字节码）、<code>jdb</code>（调试器）等。</li>\n<li><strong>Java库</strong>：包含了运行Java程序所需的类库。</li>\n<li><strong>其他工具</strong>：如<code>jar</code>（打包和解包Java归档文件）、<code>javadoc</code>（生成API文档）等。</li>\n</ul>\n<h4 id=\"JRE（Java-Runtime-Environment）\"><a href=\"#JRE（Java-Runtime-Environment）\" class=\"headerlink\" title=\"JRE（Java Runtime Environment）\"></a>JRE（Java Runtime Environment）</h4><ul>\n<li>JRE是Java运行时环境，它是运行任何Java应用程序的软件包。JRE包括了JVM、核心类库和其他支持Java程序运行的必要组件。JRE不包含开发工具，因此它只用于运行Java程序，不用于开发。</li>\n</ul>\n<h4 id=\"JVM（Java-Virtual-Machine）\"><a href=\"#JVM（Java-Virtual-Machine）\" class=\"headerlink\" title=\"JVM（Java Virtual Machine）\"></a>JVM（Java Virtual Machine）</h4><ul>\n<li>本文要说的</li>\n</ul>\n<h2 id=\"JVM指令集架构\"><a href=\"#JVM指令集架构\" class=\"headerlink\" title=\"JVM指令集架构\"></a>JVM指令集架构</h2><h3 id=\"指令集架构\"><a href=\"#指令集架构\" class=\"headerlink\" title=\"指令集架构\"></a>指令集架构</h3><ul>\n<li>栈式架构<ul>\n<li>设计和实现简单，全部使用零地址指令分配</li>\n<li>不需要硬件支持，更好跨平台</li>\n<li>指令集小</li>\n<li>执行性能没寄存器架构高</li>\n</ul>\n</li>\n<li>寄存器架构：类似于X86汇编语言<ul>\n<li>依赖硬件，不同公司产的CPU可能指令集就不同，例如X86和MIPS，就是这两种指令集</li>\n</ul>\n</li>\n</ul>\n<p><strong>JVM使用了栈式架构</strong></p>\n<h2 id=\"JVM生命周期\"><a href=\"#JVM生命周期\" class=\"headerlink\" title=\"JVM生命周期\"></a>JVM生命周期</h2><ol>\n<li><p>启动<br>由引导类加载器BootStrap class loader 创建一个初始类实现JVM的启动</p>\n</li>\n<li><p>JVM的执行</p>\n<p>JVM启动的唯一原因是要执行Java程序，但对于操作系统来说，没有Java程序，运行的是JVM进程</p>\n</li>\n<li><p>虚拟机的退出<br>以下几种情况：</p>\n<ul>\n<li>正常执行结束</li>\n<li>执行过程中遇到了异常、错误而终止</li>\n<li>操作系统叫停</li>\n<li>某线程调用Runtime类或System类的exit方法，或 <code>Runtime</code> 类的 <code>halt</code> 方法，并且 Java 安全管理器也允许本次的操作</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"HotSpot\"><a href=\"#HotSpot\" class=\"headerlink\" title=\"HotSpot\"></a>HotSpot</h2><blockquote>\n<p>HotSpot到底是什么？</p>\n</blockquote>\n<ol>\n<li><p>一种 VM 实现方式：</p>\n<p>2000 年，JDK1.3 发布，Java HotSpot virtual machine 正式发布</p>\n<p>HotSpot VM 是 Sun JDK 与 Open JDK 默认的 JVM</p>\n<p><strong>采用解释器与即时编译器 JIT 并存的结构</strong></p>\n<p>目前，HotSpot VM 是广泛的 JVM 实现，主要学习的也就是这个！</p>\n</li>\n<li><p>一种技术 —— <strong>热点代码探测技术</strong></p>\n<p>Java 原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。</p>\n<p>而 <strong>HotSpot 将常用的部分代码编译为本地（原生，native）代码</strong>，这样显着提高了性能。</p>\n</li>\n</ol>\n<h2 id=\"JVM结构\"><a href=\"#JVM结构\" class=\"headerlink\" title=\"JVM结构\"></a>JVM结构</h2><p><img data-src=\"https://img.jyhmw.cn/image-20240527103226036.png\" alt=\"image-20240527103226036\"></p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240906173255463.png\" alt=\"image-20240906173255463\"></p>\n<ul>\n<li>Class Loader：类加载子系统</li>\n<li>Runtime DataAreas：运行时数据区</li>\n<li>Execution Engine：执行引擎</li>\n</ul>\n<h2 id=\"Class-Loader-类加载子系统\"><a href=\"#Class-Loader-类加载子系统\" class=\"headerlink\" title=\"Class Loader 类加载子系统\"></a>Class Loader 类加载子系统</h2><h3 id=\"Class-Loader-作用\"><a href=\"#Class-Loader-作用\" class=\"headerlink\" title=\"Class Loader 作用\"></a>Class Loader 作用</h3><ol>\n<li>负责从文件系统或网络中<strong>加载 Class 文件，生成运行时数据结构</strong></li>\n<li>只负责加载，不确保可以运行（Execution Engine 决定）</li>\n<li>加载的类信息存放在 Method Area 方法区</li>\n</ol>\n<h3 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h3><blockquote>\n<p>总共三大步：</p>\n<ol>\n<li>加载Loading</li>\n<li>链接Linking</li>\n<li>初始化Initialization</li>\n</ol>\n</blockquote>\n<h4 id=\"Loading加载\"><a href=\"#Loading加载\" class=\"headerlink\" title=\"Loading加载\"></a>Loading加载</h4><ol>\n<li>通过一个类的全限定名获得类的二进制字节流</li>\n<li>将字节流的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象</li>\n</ol>\n<blockquote>\n<p>对于加载来源的补充， <code>.class</code> 文件可以来自：本地直接加载、网络获取、zip 压缩包直接读取的（jar、war 格式的基础）、<strong>运行时自动生成</strong>（动态代理技术）、其他文件生成（例如 JSP 文件）、从加密文件中获取（防止反编译）</p>\n</blockquote>\n<h4 id=\"Linking-连接\"><a href=\"#Linking-连接\" class=\"headerlink\" title=\"Linking 连接\"></a>Linking 连接</h4><p>链接又分成三个步骤</p>\n<ol>\n<li><p>验证verify</p>\n<p>目的：为了保证<code>.class</code> 文件内容符合当前虚拟机的规范</p>\n<p>（例如我是 HotSpot VM 你不能给我 Taobao Vm 的字节码文件，这样我读不懂）</p>\n<p>包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</p>\n</li>\n<li><p>准备 Prepare<br>为<strong>类变量</strong>分配内存，并<strong>设置默认初始值</strong>（此时并不会给真正的值，初始化时才会给真正的值）<br>注意：</p>\n<ul>\n<li>对于 <code>final</code> 修饰的类变量，在编译时就分配了内存，在此阶段只是显式初始化</li>\n<li>不会为<strong>实例变量</strong>初始化，因为实例变量会随对象一起分配到<strong>堆区</strong>中</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>类变量：static修饰的变量，类变量的信息会放在方法区中</li>\n<li>实例变量：对象的变量，没有使用 static 修饰，会存放在 Java <strong>堆</strong>中</li>\n</ul>\n</blockquote>\n<ol start=\"3\">\n<li><p>解析Resolve</p>\n<p>目的：将常量池中的<strong>符号引用</strong>转换为<strong>直接引用</strong></p>\n<ul>\n<li>符号引用（Symbolic Reference）是指在编译时期或者运行时期使用的一种符号名称，它并不直接指向内存中的位置。它是一个符号，用于表示某个类或者类的成员（字段、方法）</li>\n<li>直接引用：直接引用（Direct Reference）是指直接指向内存中的位置的引用。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Initialization-初始化\"><a href=\"#Initialization-初始化\" class=\"headerlink\" title=\"Initialization 初始化\"></a>Initialization 初始化</h4><p>初始化阶段就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程（<code>&lt;clinit&gt;()</code> 被称为<strong>类构造器方法</strong>，与类的构造器完全不同）</p>\n<p>注：<code>&lt;clinit&gt;()</code> 方法<strong>不需要定义</strong>，是 <strong>javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</strong></p>\n<ul>\n<li><code>final</code> 修饰的类变量不会在 <code>&lt;clinit&gt;</code> 方法中初始化</li>\n<li>如果该类有父类，会确保父类的 <code>&lt;clinit&gt;</code> 方法先执行</li>\n<li>一个类的 <code>&lt;clinit&gt;</code> 方法只会在<strong>首次使用这个类的时候运行，只运行一次</strong>！</li>\n<li>虚拟机必须保证，一个类的 <code>&lt;clinit&gt;</code> 方法会在并发下被<strong>同步加锁</strong>（即这个方法只会运行一次）</li>\n</ul>\n<h3 id=\"类加载器的分类\"><a href=\"#类加载器的分类\" class=\"headerlink\" title=\"类加载器的分类\"></a>类加载器的分类</h3><blockquote>\n<p>JVM规范定义，所有派生自ClassLoader的类加载器都划分为自定义类加载器</p>\n</blockquote>\n<ul>\n<li>引导类加载器（BootStrap ClassLoader）：没有继承ClassLoader类</li>\n<li>自定义类加载器（User Define ClassLoader）</li>\n</ul>\n<p>常见的类加载器</p>\n<ol>\n<li>引导类加载器<ul>\n<li>使用C&#x2F;C++实现，在JVM内部</li>\n<li>用来<strong>加载 Java 核心库</strong>（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resources.jar</code>、<code>sun.boot.class.path</code> 路径下的内容，用于提供 JVM 自身运行所需要的类）（比如 String 类、Integer 类等等核心类库）</li>\n<li><strong>没有继承 ClassLoader</strong>，没有父类加载器</li>\n<li>加载另两个加载器，是他们的父类加载器</li>\n<li>出于安全考虑，只会加载包名为 <code>java, javax, sun</code> 开头的类</li>\n<li>如果一个类使用 <code>name.class.getClassLoader</code> 方法获取到为 <code>NULL</code> 说明它是由引导类加载器加载的</li>\n</ul>\n</li>\n<li>扩展类加载器（Extension ClassLoader）<ul>\n<li>Java 语言编写，是 <code>sun.misc.Launcher$ExtensionClassLoader</code> 的<strong>内部类</strong></li>\n<li>间接继承自 ClassLoader</li>\n<li>从 <code>java.ext.dirs</code> 系统属性指定的目录中加载类库，或从 JDK 的安装目录 <code>jre/lib/ext</code> 子目录下加载类库。<strong>如果我们写的 JAR 也放在这里，也会由扩展类加载器自动加载</strong>。</li>\n</ul>\n</li>\n<li>应用程序类加载器（App ClassLoader，也叫系统类加载器 System ClassLoader）<ul>\n<li>Java 语言编写，Launcher 的内部类</li>\n<li><strong>父类为扩展类加载器</strong></li>\n<li><strong>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</strong></li>\n<li>加载自定义的类，可以使用 <code>ClassLoader.getSystemClassLoader()</code> 获取</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三个类加载器之间的关系\"><a href=\"#三个类加载器之间的关系\" class=\"headerlink\" title=\"三个类加载器之间的关系\"></a>三个类加载器之间的关系</h3><p><img data-src=\"https://img.jyhmw.cn/85f3a1163cff4f8ab92a9fd2d2dd8c2f.png\" alt=\"85f3a1163cff4f8ab92a9fd2d2dd8c2f\"></p>\n<ol>\n<li>逻辑上的父子关系</li>\n<li>但是<strong>不是继承</strong>关系！！！</li>\n</ol>\n<h3 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h3><h4 id=\"什么时候用自定义类加载器？\"><a href=\"#什么时候用自定义类加载器？\" class=\"headerlink\" title=\"什么时候用自定义类加载器？\"></a>什么时候用自定义类加载器？</h4><ul>\n<li><strong>隔离加载类</strong>（防止用中间件导致命名空间冲突）</li>\n<li>修改类加载的方式</li>\n<li>扩展加载源</li>\n<li>防止源码泄露（可以对指定的字节码文件进行解密）</li>\n</ul>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>继承ClassLoader类</li>\n<li>实现findClass()方法</li>\n<li>如果没有太复杂的需求，可以继承 <code>URLClassLoader</code> 类，避免自己去编写 <code>findClass()</code> 方法及其获取字节流的方式</li>\n</ol>\n<h3 id=\"获取ClassLoader的途径\"><a href=\"#获取ClassLoader的途径\" class=\"headerlink\" title=\"获取ClassLoader的途径\"></a>获取ClassLoader的途径</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//【法一】：通过当前类的Class对象来获取</span></span><br><span class=\"line\">ToGetClassLoader.class.getClassLoader();</span><br><span class=\"line\"><span class=\"comment\">//【法二】：获取当前线程上下文的ClassLoader</span></span><br><span class=\"line\">Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\"><span class=\"comment\">//【法三】：ClassLoader获取AppClassLoader</span></span><br><span class=\"line\">ClassLoader.getSystemClassLoader();</span><br><span class=\"line\"><span class=\"comment\">//【法四】：通过获取AppClassLoader，进而获取ExtensionClassLoader</span></span><br><span class=\"line\">ClassLoader.getSystemClassLoader().getParent();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h3><blockquote>\n<p>加载 class 文件时，把加载请求逐级向上递交，上级加载器不加载此 class 时，才会交由低级的加载器加载。</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/85f3a1163cff4f8ab92a9fd2d2dd8c2f.png\" alt=\"85f3a1163cff4f8ab92a9fd2d2dd8c2f\"></p>\n<h4 id=\"面试问题\"><a href=\"#面试问题\" class=\"headerlink\" title=\"面试问题\"></a>面试问题</h4><blockquote>\n<p>如何将自己写的 <code>java.lang.String</code> 导入 JVM</p>\n</blockquote>\n<p>答：</p>\n<p> 如果是 <code>java.lang</code> 包下的内容，是无法加载的，因为双亲委派机制的存在，<code>java.lang</code> 包下的内容全部会被引导类加载器加载。</p>\n<p> 即使使用了自定义的类加载器去加载，规避双亲委派机制，但由于是 <code>java.</code> 开头的包，也会被<strong>沙箱安全机制</strong>拦截，报出安全异常。</p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ol>\n<li><p><strong>避免类的重复加载</strong></p>\n<p>一个类只会由一个加载器加载，不会出现多个加载器加载一个类的情况</p>\n</li>\n<li><p><strong>保护程序安全，防止核心 API 被随意更改</strong></p>\n</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><ol>\n<li><p>JVM 中表示 <strong>两个 class 对象是否为同一个类</strong> 的两个必要条件是什么？</p>\n<ul>\n<li>类的全限定类名必须一致</li>\n<li>加载这个类的 <code>ClassLoader</code> 必须相同</li>\n</ul>\n</li>\n<li><p>类的主动使用与被动使用（类的主动使用和被动使用<strong>区别</strong>就在于，<strong>有没有类加载过程中的初始化过程</strong>）</p>\n<ul>\n<li><p>主动使用，有七种情况：</p>\n<ul>\n<li><p>创建类的实例：通过关键字 <code>new</code> 实例化一个类</p>\n</li>\n<li><p>访问某个类或接口的静态变量，或者对静态变量赋值</p>\n</li>\n<li><p>调用类的静态方法</p>\n</li>\n<li><p>反射：使用 Java 反射机制访问类的方法或字段。</p>\n</li>\n<li><p>初始化一个类的子类</p>\n</li>\n<li><p>JVM 启动时被标明为启动类的类</p>\n</li>\n<li><p>JDK 7 开始提供的动态语言</p>\n</li>\n</ul>\n</li>\n<li><p>被动使用是指没有直接引用类，而是通过其他途径间接引用类，<strong>不会导致类的初始化，只会触发类的加载</strong>：</p>\n<ul>\n<li>访问类的常量：访问类的常量（被 <code>final</code> 修饰的基本类型或字符串类型）。</li>\n<li>使用类的数组：使用数组类型，该数组的元素类型是类，不会触发该类的初始化。</li>\n<li>通过子类引用父类的静态变量：通过子类引用父类的静态变量，不会触发子类的初始化。</li>\n<li>通过类名获取 <code>Class</code> 对象：通过 <code>Class.forName(&quot;ClassName&quot;)</code> 获取类的 <code>Class</code> 对象，不会触发该类的初始化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"Runtime-Data-Areas-运行时数据区\"><a href=\"#Runtime-Data-Areas-运行时数据区\" class=\"headerlink\" title=\"Runtime Data Areas 运行时数据区\"></a>Runtime Data Areas 运行时数据区</h2><h3 id=\"Runtime-Data-Areas-基本结构\"><a href=\"#Runtime-Data-Areas-基本结构\" class=\"headerlink\" title=\"Runtime Data Areas 基本结构\"></a>Runtime Data Areas 基本结构</h3><p>有五大部分：</p>\n<ul>\n<li><strong>方法区Method Area</strong>（在JDK1.8 后叫<strong>元数据区</strong>）</li>\n<li><strong>堆Heap</strong></li>\n<li>程序计数器 Program Count Register（PC）</li>\n<li>本地方法栈 Native Method Stack（NMS）</li>\n<li>虚拟机栈 JVM Stack（VMS）</li>\n</ul>\n<p>其中，加粗的部分为每个<strong>进程</strong>一份（即<strong>整个 JVM 只有一个方法区和堆区</strong>），其他部分每个<strong>线程</strong>各有一份，共用方法区和堆区</p>\n<p>而且 JVM 中的线程与操作系统的线程是一一映射关系的</p>\n<h3 id=\"PC\"><a href=\"#PC\" class=\"headerlink\" title=\"PC\"></a>PC</h3><blockquote>\n<p>PC程序计数寄存器：不同于CPU内的PC，而是一种模仿的抽象，也叫程序钩子</p>\n</blockquote>\n<h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎（Execution Engine）读取下一条指令。</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240321182519265.png\" alt=\"image-20240321182519265\"></p>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>小而精：占很小的一块内存，处于运行速度最快的区域</li>\n<li>线程私有，PC与线程共存亡</li>\n<li>不会发生OOM（Out of Memory）</li>\n<li>记录<strong>当前方法</strong>的 JVM 指令地址（若执行 <code>Native Method</code>，则 PC 是 undefined）</li>\n</ol>\n<blockquote>\n<p>当前方法：任何时间线程只能有一个方法在执行，这个方法就在当前<strong>虚拟机栈</strong>栈顶</p>\n</blockquote>\n<h4 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题\"></a>两个问题</h4><ol>\n<li><p>使用PC存储字节码指令地址有什么用？或者说为什么使用PC记录当前线程的执行地址？</p>\n<p>因为 CPU 会不停的切换线程，当切换回此线程时，得知道从哪儿继续任务，所以就使用 PC 这个结构来存储指令地址</p>\n</li>\n<li><p>PC 寄存器为什么要设置为线程私有？<br>如果不设置 PC 为私有，那么就得把 PC 内的值存到一个地方，这样切换线程时，需要不停的存 PC 读 PC，增大了切换线程的开销。要是给每个线程一个 PC，那么切换就消除了这个开销</p>\n</li>\n</ol>\n<h3 id=\"JVM-Stack\"><a href=\"#JVM-Stack\" class=\"headerlink\" title=\"JVM Stack\"></a>JVM Stack</h3><blockquote>\n<p>栈！！！</p>\n</blockquote>\n<h4 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p>保存程序运行期间的局部变量（8 种基本数据对象、引用对象的<strong>地址</strong>）、部分结果、参与方法的返回和调用</p>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>线程私有，与线程公存亡</li>\n<li>存储的基本单位：栈帧（Stack Frame）</li>\n<li>速度仅次于PC</li>\n<li>不存在垃圾回收问题，但是存在Stack Overflow 和 Out Of Memory 异常</li>\n<li>JVM对其有两个操作：入栈，出栈</li>\n</ul>\n<h4 id=\"栈的Stack-Overflow-与-OOM\"><a href=\"#栈的Stack-Overflow-与-OOM\" class=\"headerlink\" title=\"栈的Stack Overflow 与 OOM\"></a>栈的Stack Overflow 与 OOM</h4><p>JVM允许栈可以是固定不变的，也可以是动态增长的：</p>\n<ul>\n<li>固定不变：线程创建时就指定了具体的大小，如果此线程运行过程中，<strong>超出了最大容量</strong>，那么会报出 <strong>Stack Overflow Error 异常</strong></li>\n<li>动态增长：栈可以自己动态增长，但是在尝试扩展时，<strong>无法申请到足够的内存</strong>，或者在创建线程时，内存达不到申请的要求，就会抛出 <strong>OOM 异常</strong></li>\n</ul>\n<p>总结：超出了栈范围 -&gt; Stack Overflow，无法申请到内存 -&gt; OOM</p>\n<blockquote>\n<p>可以使用 Java 的 - Xss 参数设置栈内存大小：</p>\n<p>java -Xss1m &#x2F;&#x2F; 设置 1M 的内存；k 代表 kb ；G 代表 Gb</p>\n</blockquote>\n<h4 id=\"栈帧Stack-Frame\"><a href=\"#栈帧Stack-Frame\" class=\"headerlink\" title=\"栈帧Stack Frame\"></a>栈帧Stack Frame</h4><h5 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>每一个方法对应一个栈帧</li>\n<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>\n<li>处于栈顶的栈帧，叫做<strong>当前栈帧</strong>；对应的方法，称为<strong>当前方法</strong>；对应执行这个方法的类，就叫做<strong>当前类</strong></li>\n<li><strong>执行引擎</strong>运行的所有字节码指令只对<strong>当前栈帧</strong>进行操作</li>\n<li>若该方法调用其他方法，则会创建新的栈帧，压入栈中，待其运行完成后，出栈</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>不同线程的所含的栈帧不允许相互引用</li>\n<li>如果方法嵌套使用，内方法的返回值会传回外方法的栈帧</li>\n<li>方法有两种方式将栈帧弹出：<ul>\n<li><code>return</code> 语句</li>\n<li><code>throw</code> 抛出异常</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"栈帧的结构\"><a href=\"#栈帧的结构\" class=\"headerlink\" title=\"栈帧的结构\"></a>栈帧的结构</h5><ul>\n<li><strong>局部变量表</strong> Local Variables （LV）</li>\n<li><strong>操作数栈</strong> Oprand Stack （或叫表达式栈 OS）</li>\n<li>动态链接 Dynamic Linking （或叫 指向运行时常量池的方法引用）</li>\n<li>方法返回地址 Return Address （或叫 方法正常退出或异常退出的定义）</li>\n<li>一些附加信息</li>\n</ul>\n<p>后三个又叫<strong>帧数据区</strong></p>\n<h5 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h5><ul>\n<li>是一个<strong>数字数组</strong>（<code>int byte char short</code> 等均为数字；<code>bool</code> 转换 0 表示假，非 0 表示真；引用类型可以使用地址，也为数字）</li>\n<li>局部变量表在栈中，栈线程私有，因此不存在数据安全问题</li>\n<li>局部变量表所需的容量大小在<strong>编译期</strong>就确定下来，保存在方法的 <code>code</code> 属性的 <code>maximum local variables</code> 数据项中，在方法运行期间不会改变。</li>\n<li>方法嵌套的次数由栈的大小决定。（如果一个方法的参数和局部变量越多，使得局部变量表变大，那么嵌套次数就会变少）</li>\n<li>局部变量表只在当前方法调用中有效</li>\n</ul>\n<h6 id=\"插槽Slot\"><a href=\"#插槽Slot\" class=\"headerlink\" title=\"插槽Slot\"></a>插槽Slot</h6><blockquote>\n<p>Slot是局部变量表最基本的存储单元</p>\n</blockquote>\n<ul>\n<li><p><code>byte short char bool</code> 存储前会被转换为 <code>int</code></p>\n</li>\n<li><p>32 位以内占用一个 slot（包括<strong>引用类型</strong> 和 <code>returnAddress</code>）；64 位占用两个 slot 如 <code>long double</code></p>\n</li>\n<li><p>JVM 会给每一个槽都分配一个索引，通过这个索引则可以取到值；方法被调用时，它的<strong>方法参数</strong>和<strong>局部变量</strong>都会<strong>按照顺序</strong>被复制到局部变量表的一个 <code>slot</code> 上</p>\n</li>\n<li><p>对于<strong>构造方法</strong>和<strong>实例方法</strong>，会自动引入一个 <strong>this 变量</strong>，放在 index 为 0 的插槽（也就是第一个插槽）</p>\n</li>\n<li><p>槽也可以重用，如果过了局部变量的作用域，那么下面的变量会占用此槽</p>\n</li>\n</ul>\n<p><strong>类变量可以不给初值使用，但是局部变量不行</strong></p>\n<p>现在我们知道原因了，因为：</p>\n<p>类在加载过程中，有<strong>加载、链接、初始化</strong>三个过程，而第二步链接又有<strong>验证、准备、解析</strong>三个过程，在准备阶段，所有的类变量会被给默认值，到了初始化阶段才会将程序员给变量的值赋值给类变量。</p>\n<p>但是对于局部变量来说，一个方法的局部变量表就没这么多过程了，如果没给初始值，系统也不知道这个值是多少，也就没法使用</p>\n<ul>\n<li>对于 GC 来说，<strong>局部变量表所直接引用或间接引用的对象，都不会被回收</strong></li>\n</ul>\n<h5 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h5><p>基于<strong>数组</strong>实现的栈，也叫<strong>表达式栈</strong></p>\n<p>作用：</p>\n<ul>\n<li><p>根据字节码指令，往栈中写入数据和读出数据（即<strong>入栈与出栈</strong>）</p>\n</li>\n<li><p>保存计算的中间过程，作为运算结果的<strong>临时</strong>存储空间</p>\n</li>\n<li><p>操作数栈相当于 JVM 的<strong>临时工作区</strong>，在方法开始调用时，此栈是空的</p>\n</li>\n<li><p>操作数栈有其</p>\n<p>栈深度，在编译器就已确定，保存在 Code 属性中，为max_stack的值</p>\n<ul>\n<li>32bit 占一个栈深度，64bit 占两个栈深度</li>\n</ul>\n</li>\n<li><p>虽然是基于数组实现的，但不能直接用索引访问，只能进行入栈与出栈操作</p>\n</li>\n<li><p>如果方法<strong>有返回值</strong>，其返回值会被压入<strong>当前栈帧</strong>的<strong>操作数栈</strong>，并更新 PC，执行下一条指令</p>\n</li>\n<li><p>Java 虚拟机的解释引擎是<strong>基于栈的执行引擎</strong>，指的就是操作数栈</p>\n</li>\n</ul>\n<p><strong>了解</strong>：</p>\n<p>一个新技术：<strong>栈顶缓存技术</strong>（ToS Top-of-Stack Cashing）</p>\n<p>指：将栈顶的元素全部存储在 CPU 的寄存器当中</p>\n<p>原因：JVM 是基于栈式的指令，虽然零地址的使用简单，但是会增大入栈和出栈的次数（即增多了对内存的访问次数），所以提出了此项技术。</p>\n<h5 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h5><p>在栈帧中的一个<strong>指向运行时常量池</strong>中方法的引用</p>\n<h5 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h5><p>存放调用该方法的 PC 寄存器的值</p>\n<p>一个方法结束，<strong>本质上是当前栈帧出栈的过程</strong>：</p>\n<ul>\n<li>正常结束：调用者的 PC 的值作为返回地址</li>\n<li>出现异常退出：<strong>返回地址</strong>要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息</li>\n</ul>\n<p>两种退出方式的区别就在于，异常退出的方法不会给上层调用者返回任何的信息</p>\n<h5 id=\"附加信息\"><a href=\"#附加信息\" class=\"headerlink\" title=\"附加信息\"></a>附加信息</h5><p>为了给程序调试提供支持的信息</p>\n<h4 id=\"关于JVM栈的问题\"><a href=\"#关于JVM栈的问题\" class=\"headerlink\" title=\"关于JVM栈的问题\"></a>关于JVM栈的问题</h4><ol>\n<li><p>举例栈溢出的情况</p>\n<p>Stack Overflow 栈溢出，栈中存放栈帧，每一个栈帧代表一个方法，日常编程中，递归调用方法时，当栈帧累计增加起来，就会导致栈的大小不足，导致栈溢出</p>\n</li>\n<li><p>-Xss调整栈大小，就能不出现Stack Overflow吗？</p>\n<p>当然不能，无论调多大的栈内存，都有可能用完。不过栈越大，能跑的方法也就越多，有时候调整栈变大，会解决 Stack Overflow 的问题。</p>\n</li>\n<li><p>垃圾回收是否涉及到 JVM 栈</p>\n<p>垃圾回收不涉及 VMS，只有方法区和堆才设计 GC 操作</p>\n</li>\n<li><p>方法中定义的局部变量是否线程安全</p>\n<p>线程安全</p>\n<ul>\n<li>只有一个线程可以操作此数据，必是线程安全的；</li>\n<li>若有多个线程可以操作此数据，那这个数据就是共享数据，若没有进行同步，则存在安全问题</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Native-Method-Stack\"><a href=\"#Native-Method-Stack\" class=\"headerlink\" title=\"Native Method Stack\"></a>Native Method Stack</h3><p><code>VMS</code> 用来管理 Java 方法调用，<code>NMS</code> 来管理本地方法调用</p>\n<p>作用：登记方法中使用到的本地方法</p>\n<h4 id=\"什么是本地方法栈？\"><a href=\"#什么是本地方法栈？\" class=\"headerlink\" title=\"什么是本地方法栈？\"></a>什么是本地方法栈？</h4><p>本地方法栈与Java栈非常相似，但它专门为本地方法服务。当JVM执行本地方法时，它会在本地方法栈中创建一个栈帧，用于存储方法调用的局部变量和返回信息。每个本地方法调用都会创建一个新的栈帧，并且每个栈帧都会在方法执行完成后被移除。</p>\n<h4 id=\"本地方方法栈的作用\"><a href=\"#本地方方法栈的作用\" class=\"headerlink\" title=\"本地方方法栈的作用\"></a>本地方方法栈的作用</h4><ol>\n<li><strong>执行本地方法</strong>：本地方法栈用于执行那些通过Java Native Interface（JNI）或其他机制引入的本地方法。</li>\n<li><strong>管理本地方法的调用</strong>：它负责管理本地方法的调用过程，包括参数传递、局部变量的存储以及方法返回。</li>\n<li><strong>与Java栈的交互</strong>：在JNI调用中，本地方法栈和Java栈之间可能会有交互。例如，一个Java方法可能会调用一个本地方法，或者一个本地方法可能会调用回Java方法。</li>\n</ol>\n<h3 id=\"Java-Heap\"><a href=\"#Java-Heap\" class=\"headerlink\" title=\"Java Heap\"></a>Java Heap</h3><h4 id=\"特点-4\"><a href=\"#特点-4\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>进程共有</strong>，一个 JVM 只有一个堆内存</li>\n<li>JVM <strong>最大</strong>的一块内存空间</li>\n<li>内存<strong>大小可以调节</strong> ，<strong>物理上不必连续，逻辑上连续</strong>（使用参数 <code>-Xms10m -Xmx20m</code> 设置堆最小 10m，最大 20m）</li>\n<li>线程可以在此划分<strong>私有的缓冲区</strong>（Thread Local Allocation Buffer ，<strong>TLAB</strong>）</li>\n<li>方法结束后，堆中的对象不会被马上移除，只有 GC 时才会移除</li>\n</ul>\n<h4 id=\"堆内存结构\"><a href=\"#堆内存结构\" class=\"headerlink\" title=\"堆内存结构\"></a>堆内存结构</h4><h5 id=\"JDK1-7\"><a href=\"#JDK1-7\" class=\"headerlink\" title=\"JDK1.7\"></a>JDK1.7</h5><p>逻辑上堆分为：年轻代、老年代、永久代</p>\n<ul>\n<li>年轻代：<ul>\n<li>Eden 区</li>\n<li>Survivor 区<ul>\n<li>Survivor 0 </li>\n<li>Survivor 1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>老年代</li>\n<li>永久代：不属于堆空间的一部分，只是逻辑上分到了这一部分</li>\n</ul>\n<h5 id=\"JDK1-8\"><a href=\"#JDK1-8\" class=\"headerlink\" title=\"JDK1.8\"></a>JDK1.8</h5><p>逻辑上分为：年轻代、老年代、元空间</p>\n<p>年轻代与老年代没有变化</p>\n<ul>\n<li>元空间：物理上在内存内，不在堆中</li>\n</ul>\n<h4 id=\"堆内存设置\"><a href=\"#堆内存设置\" class=\"headerlink\" title=\"堆内存设置\"></a>堆内存设置</h4><blockquote>\n<p>堆内存在JVM建立时就确立了，可以通过参数来设置堆空间（新生代+老年代）大小：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms 堆区的起始内存 等价于 -XX:InitialHeapSize</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx 堆区的最大内存 等价于 -XX:MaxHeapSize</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果堆区内存超过设置的最大内存，就会出现OOM错误</p>\n<p>通常设置两个值为相同的值，是为了GC清理完堆区后，不需要重新分隔计算堆区的大小，从而提高性能</p>\n<p>默认的初始化值，按电脑内存不同而不同，大致关系如下</p>\n<ul>\n<li>起始内存的值 &#x3D; 电脑内存大小  &#x2F; 64</li>\n<li>最大内存的值 &#x3D; 电脑内存大小  &#x2F; 4</li>\n</ul>\n<p>查看自己JVM堆内存的Demo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HeapMem</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查看堆空间大小</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">initialMemory</span> <span class=\"operator\">=</span> Runtime.getRuntime().totalMemory();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">maxMemory</span> <span class=\"operator\">=</span> Runtime.getRuntime().maxMemory();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-Xms: &quot;</span>+ initialMemory / <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;M&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-XmX: &quot;</span>+maxMemory / <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;M&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;系统内存大小（用-Xms来计算）&quot;</span> + initialMemory * <span class=\"number\">64.0</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;G&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;系统内存大小（用-Xmx来计算）&quot;</span> + maxMemory * <span class=\"number\">4.0</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;G&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms: 245M</span><br><span class=\"line\">-XmX: 3614M</span><br><span class=\"line\">系统内存大小（用-Xms来计算）<span class=\"number\">1.</span>6089088E7G</span><br><span class=\"line\">系统内存大小（用-Xmx来计算）<span class=\"number\">1.</span>4804992E7G</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新生代与老年代\"><a href=\"#新生代与老年代\" class=\"headerlink\" title=\"新生代与老年代\"></a>新生代与老年代</h4><ul>\n<li><p>默认比例：新生代：老年代&#x3D;1:2<br>可以通过参数进行设置-XX:NewRatio&#x3D;n 其中n表示一个数字，假如为5，那么新生代与老年代比例就为1:5<br>新生代的大小可以用参数-Xmn显示指定，而且优先度大于上面的选项</p>\n</li>\n<li><p>新生代中，Eden与另外两个Survivor区的比例是8:1:1</p>\n<p>这个数值也可以调整 -XX:SurvivorRatio&#x3D;8</p>\n<p>但是去验证一下，会发现其实并不是完全的8:1:1，因为默认开启<strong>自适应</strong>，JVM 会自动进行调整（但就算显示关闭自适应，也不会是 <code>8:1:1</code>，只有显示声明参数设 <code>-XX:SurvivorRatio=8</code>，才会是 <code>8:1:1</code>）</p>\n</li>\n<li><p><strong>几乎所有</strong>的 Java 对象都在 Eden 区被 new（例外：直接 new 了一个大于 Eden 区的对象）</p>\n</li>\n<li><p><strong>绝大部分</strong> Java 对象都在新生代被销毁了</p>\n</li>\n</ul>\n<h4 id=\"对象的分配过程\"><a href=\"#对象的分配过程\" class=\"headerlink\" title=\"对象的分配过程\"></a>对象的分配过程</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240328203818973.png\" alt=\"image-20240328203818973\"></p>\n<ol>\n<li>创建一个新的对象时，首先判断Eden区是否放得下，如果放得下，就为其分配内存，放不下进行YGC（将Eden区的不再被其他对象引用的对象进行销毁，加载新的对象到Eden区）</li>\n<li>然后再判断Eden区是否放得下，放得下就放在 S0&#x2F;S1区域，每次YGC移动，对象超过阈值的时候晋升Old区</li>\n<li>如果Eden区还是放不下放入Old区，Old放不下进行FGC，放得下就放在Old区</li>\n<li>如果Old区还是放不下出现OOM异常</li>\n</ol>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>YGC会清理Eden与Survivor的游离对象；触发YGC的只能是Eden区满</li>\n<li>Survivor区满，会直接将对象promotion至老年代</li>\n<li>form区和to区是根据survivor 0 与 survivor 1 区谁满谁不满而言的，空的就是to区，另一个就是from区</li>\n<li>阈值默认为15</li>\n<li>GC频繁发生在新生代，很少发生在老年代，几乎不在永久区&#x2F;元空间收集</li>\n</ul>\n<h4 id=\"MinorGC、MajorGC、FullGC区别\"><a href=\"#MinorGC、MajorGC、FullGC区别\" class=\"headerlink\" title=\"MinorGC、MajorGC、FullGC区别\"></a>MinorGC、MajorGC、FullGC区别</h4><p>GC分为两大类型</p>\n<ul>\n<li><p>部分收集（Partial GC）</p>\n<ul>\n<li>新生代收集（Minor GC&#x2F;Young GC）：只对新生代进行垃圾收集</li>\n<li>老年代收集（Major GC&#x2F;Old GC）：只对老年代进行垃圾收集<ul>\n<li>只有 CMS GC会有只收集老年代的行为</li>\n</ul>\n</li>\n<li>混合收集（Mixed GC）：收集整个新生代及部分老年代<ul>\n<li>只有G1 GC会有Mixed GC</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</p>\n</li>\n</ul>\n<h5 id=\"GC触发时机\"><a href=\"#GC触发时机\" class=\"headerlink\" title=\"GC触发时机\"></a>GC触发时机</h5><ul>\n<li>YGC<ul>\n<li>触发时机：Eden区空间不足</li>\n<li>引发STW（Stop the world），暂停其他用户线程，只有GC结束后，才会使其继续执行</li>\n</ul>\n</li>\n<li>Major GC<ul>\n<li>触发时机：老年代空间不足，先触发YGC，如果还不足触发MajorGC</li>\n<li>STW时间更长</li>\n</ul>\n</li>\n<li>Full GC<ul>\n<li>触发时机<ul>\n<li>调用System.gc()，系统建议执行Full GC，但不一定</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>YGC后，进入老年代的平均大小大于老年代可用内存</li>\n<li>Eden、form区向to复制时，大小大于to区，也大于了老年代内存</li>\n</ul>\n</li>\n<li>Full GC应尽量避免</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"堆空间分代思想\"><a href=\"#堆空间分代思想\" class=\"headerlink\" title=\"堆空间分代思想\"></a>堆空间分代思想</h4><p>不分代也可以正常工作，只不过性能没有分代强。在 Java 程序中，70%~80% 对象都是临时对象，如果不进行分代，每次进行 GC 都需要遍历很多很多对象，这样性能肯定不会强。如果分为新生代、老年代，就可以大大加快效率</p>\n<h4 id=\"对象提升规则\"><a href=\"#对象提升规则\" class=\"headerlink\" title=\"对象提升规则\"></a>对象提升规则</h4><p>针对不同年龄段的对象分配原则如下：</p>\n<ul>\n<li>优先分配到 Eden</li>\n<li>大对象直接分配到老年代</li>\n<li>长期存活的对象分配到老年代</li>\n<li>动态对象年龄判断<ul>\n<li>如果 <code>Survivor</code> 区中<strong>相同年龄</strong>的所有对象大小的总和大于 <code>Survivor</code> 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 要求的年龄</li>\n</ul>\n</li>\n<li>空间分配担保<ul>\n<li>将 <code>Survivor</code> 区无法存放的对象放入老年代</li>\n<li><code>-XX:HandlePromotionFailure</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"TLAB\"><a href=\"#TLAB\" class=\"headerlink\" title=\"TLAB\"></a>TLAB</h4><blockquote>\n<p>Thread Local Allocation Buffer</p>\n</blockquote>\n<ul>\n<li>堆是线程共享的区域，TLAB是堆上属于线程私有的区域</li>\n<li>TLAB在Eden区，仅占Eden空间的1%，我们可以通过选项 <code>-XX:TLABWasteTargetPercent</code> 来设置 TLAB 空间所占的大小</li>\n<li>JVM 首选 <code>TLAB</code> 进行分配，如果内存不够大，会使用<strong>锁方式</strong>确保原子性，在非 <code>TLAB</code> 的 <code>Eden</code> 区域进行分配</li>\n</ul>\n<blockquote>\n<p>为什么用TLAB</p>\n</blockquote>\n<p> 为避免多个线程操作同一地址，需要使用锁机制，影响分配速度。加入 TLAB 可以直接避免线程安全问题，提高内存分配效率（这种分配方式也叫<strong>快速分配策略</strong>）</p>\n<h4 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h4><h3 id=\"Method-Areas-Metaspace\"><a href=\"#Method-Areas-Metaspace\" class=\"headerlink\" title=\"Method Areas (Metaspace)\"></a>Method Areas (Metaspace)</h3><blockquote>\n<p>JDK7之前，都叫做方法区，JDK8之后改为元空间；<br>本次以JDK8 + 元空间位标准</p>\n</blockquote>\n<h4 id=\"栈、堆、方法区\"><a href=\"#栈、堆、方法区\" class=\"headerlink\" title=\"栈、堆、方法区\"></a>栈、堆、方法区</h4><p><strong>线程私有：</strong></p>\n<ul>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>线程共享：</strong></p>\n<ul>\n<li>堆</li>\n<li>元空间</li>\n</ul>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240526201955828.png\" alt=\"image-20240526201955828\"></p>\n<p><strong>方法区存放着类型的信息</strong></p>\n<p><strong>特点</strong></p>\n<ul>\n<li>逻辑上属于堆，但其实是独立于Java堆的内存空间（No-Heap）</li>\n<li>属于共享区域</li>\n<li>物理上内存空间可以不连续</li>\n<li>大小可以固定也可以动态扩展；决定了系统可以保存多少个类</li>\n<li>如果类太多，元空间存不下，那么会出现OOM</li>\n<li>与JVM同生死</li>\n</ul>\n<h4 id=\"方法区的演进过程\"><a href=\"#方法区的演进过程\" class=\"headerlink\" title=\"方法区的演进过程\"></a>方法区的演进过程</h4><p>JDK7及之前，称方法区为永久代（方法区和永久代并不等价，仅在 hotspot vm 实现而言，<strong>两者等价</strong>）</p>\n<p>JDK8+，使用<strong>元空间取代了永久代</strong>，但有区别</p>\n<ul>\n<li>元空间不在虚拟机设置的内存中，而是<strong>直接使用本地内存</strong></li>\n<li>内部结构也进行了调整</li>\n</ul>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240526204247568.png\" alt=\"image-20240526204247568\"></p>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"GC垃圾回收-（重要）\"><a href=\"#GC垃圾回收-（重要）\" class=\"headerlink\" title=\"GC垃圾回收 （重要）\"></a>GC垃圾回收 （重要）</h2><h3 id=\"什么是垃圾？\"><a href=\"#什么是垃圾？\" class=\"headerlink\" title=\"什么是垃圾？\"></a>什么是垃圾？</h3><p>游离的对象，具体来说，就是不可达的对象</p>\n<h3 id=\"OS内存分配的两种方式\"><a href=\"#OS内存分配的两种方式\" class=\"headerlink\" title=\"OS内存分配的两种方式\"></a>OS内存分配的两种方式</h3><ul>\n<li><p>空闲列表（适用在内存不规整的情况）<br>维护一个列表，存放了内存中空闲的大小及其地址，如果要分配空间，就遍历这个表</p>\n</li>\n<li><p>指针碰撞（适用在内存规整的情况）</p>\n<p>用一个指针标记已使用内存与未使用内存的分界点，然后每次分配只需要移动这个指针即可，很快</p>\n</li>\n</ul>\n<h3 id=\"STW\"><a href=\"#STW\" class=\"headerlink\" title=\"STW\"></a>STW</h3><p>GC标记某阶段，会让所有用户线程暂停</p>\n<h3 id=\"Java的四种引用\"><a href=\"#Java的四种引用\" class=\"headerlink\" title=\"Java的四种引用\"></a>Java的四种引用</h3><ul>\n<li>强引用<br>永远不会GC，即使OOM也不会回收<br>所有可达对象都属于强引用</li>\n<li>软引用<br>快要发生OOM的时候，回收所有的软引用</li>\n<li>弱引用<br>每次GC都会被回收</li>\n<li>虚引用<br>没有实际的作用，唯一的作用就是可以在对象被回收的时候通知另一个对象</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记阶段算法\"><a href=\"#标记阶段算法\" class=\"headerlink\" title=\"标记阶段算法\"></a>标记阶段算法</h4><h5 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h5><ul>\n<li>每个对象维护一个字段，记录被引用的次数</li>\n<li>优点：实现简单，垃圾对象容易判断</li>\n<li>缺点：如果形成环，容易导致不会被GC掉</li>\n</ul>\n<h5 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h5><ul>\n<li>从GCRoots开始，依次向内遍历，标记那些可达对象</li>\n<li>GCRoots包含哪些元素？<ul>\n<li>虚拟机栈中：局部变量关联的对象</li>\n<li>本地方法栈中：引用的对象</li>\n<li>元空间中：静态变量和常量池指向的对象</li>\n<li>同步锁持有的对象</li>\n<li>Class对象，基本的异常对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"清除阶段算法\"><a href=\"#清除阶段算法\" class=\"headerlink\" title=\"清除阶段算法\"></a>清除阶段算法</h4><h5 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h5><ul>\n<li>从GC Roots开始，依次向内进行遍历，标记那些可达的对象，然后将没有标记的对象清除</li>\n<li>特点<ul>\n<li>只能用空闲列表法</li>\n<li>清楚速度中等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"标记压缩算法\"><a href=\"#标记压缩算法\" class=\"headerlink\" title=\"标记压缩算法\"></a>标记压缩算法</h5><ul>\n<li>标记清除算法执行完成后，将所有对象压缩到一端，避免内存碎片</li>\n<li>特点<ul>\n<li>可以使用指针碰撞</li>\n<li>清楚速度最慢的一种算法，因为需要进行压缩</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h5><ul>\n<li>使用两个空间，每次GC时，将所有依然存活的对象直接移入另一个空间，将此空间全部清除掉</li>\n<li>特点<ul>\n<li>需要成倍的空间</li>\n<li>速度非常快</li>\n<li>空间换时间的一种算法</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h5><ul>\n<li>将空间分代，分为新生代、老年代、永久代，然后进行不同的遍历频率，新生带的垃圾是最多的地方</li>\n</ul>\n<h5 id=\"三色标记算法\"><a href=\"#三色标记算法\" class=\"headerlink\" title=\"三色标记算法\"></a>三色标记算法</h5><ul>\n<li>使用三种颜色<ul>\n<li>白色：不可达对象</li>\n<li>黑色：可达对象</li>\n<li>灰色：还未遍历的对象</li>\n</ul>\n</li>\n<li>开始将多有对象都设为白色，然后从GCRoots开始，如果一个对象还有子引用的对象，就标记为灰色，如果没有子引用对象，标记为黑色，最后清楚所有的白色对象</li>\n<li>CMS回收器就用的这个方法后面会详细讲到</li>\n<li>缺点：无法解决漏标与浮动垃圾的问题<ul>\n<li>漏标：标记前是垃圾，但是标记完成后就不是垃圾了，错误的被GC掉</li>\n<li>浮动垃圾：原本不是垃圾，清除完成后变为垃圾的垃圾</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"分区算法\"><a href=\"#分区算法\" class=\"headerlink\" title=\"分区算法\"></a>分区算法</h5><ul>\n<li>将所有的空间进行分区，称为Region</li>\n<li>每个Region都有一个角色<ul>\n<li>Eden</li>\n<li>Survivor</li>\n<li>Old</li>\n<li>Humongous</li>\n</ul>\n</li>\n<li>会计算每一块分区垃圾对象和存活对象的比例，维护一个优先队列，每次GC优先清楚哪些回收价值大的区</li>\n<li>特点<ul>\n<li>局部看属于分区算法，总台看属于标记压缩算法</li>\n<li>G1回收器使用的一种算法</li>\n<li>需要大空间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><h4 id=\"回收器性能参考指标\"><a href=\"#回收器性能参考指标\" class=\"headerlink\" title=\"回收器性能参考指标\"></a>回收器性能参考指标</h4><ul>\n<li>吞吐量：即执行用户代码时间与总执行时间的比例</li>\n<li>暂停时间 执行GC时，STW的时间</li>\n<li>内存占用</li>\n</ul>\n<h4 id=\"年轻代回收器\"><a href=\"#年轻代回收器\" class=\"headerlink\" title=\"年轻代回收器\"></a>年轻代回收器</h4><h5 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h5><ul>\n<li>特点<ul>\n<li>第一款垃圾回收期</li>\n<li>是串行执行的，串行GC效率第一</li>\n<li>意味着GC过程中应用线程不能执行</li>\n</ul>\n</li>\n<li>GC算法 复制算法</li>\n</ul>\n<h5 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h5><ul>\n<li>特点<ul>\n<li>相当于Serial的并行版本</li>\n<li>但是尽管多个GC线程一同执行，但是用户线程还是不能执行</li>\n</ul>\n</li>\n<li>GC算法 复制算法</li>\n</ul>\n<h5 id=\"Parallel-Scavenge-GC\"><a href=\"#Parallel-Scavenge-GC\" class=\"headerlink\" title=\"Parallel Scavenge GC\"></a>Parallel Scavenge GC</h5><ul>\n<li>特点<ul>\n<li>并行GC垃圾回收器</li>\n<li>相较于ParNew，更注重吞吐量</li>\n<li>有自适应策略 可以调整年轻代、老年代之间的大小比例</li>\n<li>JDK8默认的GC回收期</li>\n</ul>\n</li>\n<li>GC算法 复制算法</li>\n</ul>\n<h4 id=\"老年代回收器\"><a href=\"#老年代回收器\" class=\"headerlink\" title=\"老年代回收器\"></a>老年代回收器</h4><h5 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h5><ul>\n<li>特点<ul>\n<li>串行回收老年代</li>\n<li>作为CMS的备胎方案</li>\n</ul>\n</li>\n<li>GC算法<ul>\n<li>标记压缩算法</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Parllel-Old-GC\"><a href=\"#Parllel-Old-GC\" class=\"headerlink\" title=\"Parllel Old GC\"></a>Parllel Old GC</h5><ul>\n<li>特点 并行回收老年代</li>\n<li>GC算法 标记压缩算法</li>\n</ul>\n<h5 id=\"CMS-GC\"><a href=\"#CMS-GC\" class=\"headerlink\" title=\"CMS GC\"></a>CMS GC</h5><ul>\n<li>特点<ul>\n<li>第一款并发GC回收器</li>\n<li>并发指用户线程可以与GC线程一同执行</li>\n<li>主打底延迟</li>\n<li>JDK14去除了CMS回收器</li>\n<li>GC可能会失败，启动被动方案Serial Old</li>\n</ul>\n</li>\n<li>GC 算法 三色标记</li>\n<li>执行过程<ul>\n<li>初始标记阶段<ul>\n<li>标记GC Roots</li>\n<li>需要STW，但是暂停时间很短</li>\n</ul>\n</li>\n<li>并发标记阶段<ul>\n<li>用户线程可以与GC线程一起执行</li>\n<li>需要执行很长时间</li>\n</ul>\n</li>\n<li>重新标记阶段<ul>\n<li>标记初始阶段不能确认的对象</li>\n<li>需要STW</li>\n</ul>\n</li>\n<li>并发清除阶段<ul>\n<li>清除没有标记的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注意<ul>\n<li>CMS不是在OOM前才进行GC的，而是达到一定的阈值就会进入GC</li>\n<li>GC的过程中用户程序还可以执行，所以存在预留的空间不够的情况  此时CMS会采用后备方案，使用Serial Old来进行GC</li>\n<li>有内存碎片，所以只能用空闲列表法   </li>\n<li>无法解决漏标、浮动垃圾的问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"新-老年代都用的\"><a href=\"#新-老年代都用的\" class=\"headerlink\" title=\"新&#x2F;老年代都用的\"></a>新&#x2F;老年代都用的</h4><h5 id=\"G1-回收器\"><a href=\"#G1-回收器\" class=\"headerlink\" title=\"G1 回收器\"></a>G1 回收器</h5><ul>\n<li>特点<ul>\n<li>JDK9开始默认的GC回收器</li>\n<li>新生代、老年代都可以回收</li>\n<li>提供三种垃圾回收方式</li>\n</ul>\n</li>\n<li>GC 算法  <ul>\n<li>分区算法</li>\n</ul>\n</li>\n<li>分区思想<ul>\n<li>将存储分为一个一个区，默认大小1-32M之间</li>\n<li>每个区都存储垃圾堆积的价值，即可以回收到的空间与总空间的比值，维护了一个优先队列，优先回收那些价值大的区域</li>\n<li>所有Region大小相同，并且运行期间角色不可以改变</li>\n<li>GC的时间可以预测！</li>\n<li>四种角色<ul>\n<li>Eden</li>\n<li>Survivor</li>\n<li>Old</li>\n<li>Humongous 用来存储大对象，如果一个不够，那就找两个连续的H区</li>\n</ul>\n</li>\n<li>每一个Region内的对象不是孤立的，那么如果有一个新生代的对象被老年代的对象引用，我们是不是得去遍历所有的老年代？<ul>\n<li>不需要这么做，每一个Region都有一个记忆集<br>记忆集就是一个集合，如果有对该Region的写操作，检查来源是不是别的Region，如果是就将对应的Region的记忆集也改一下。<br>记忆集，具体实现是一个哈希表key是该region的地址，value是一个集合，存放其他Region的索引</li>\n</ul>\n</li>\n<li>如何判断一个Region是否被引用？<ul>\n<li>每一个Region都维护了一个记忆集，具体的实现就是卡表</li>\n<li>G1的卡表和CMS的不太一样</li>\n<li>CMS的卡表是一个byte数组，只能告诉是否被引用，而不能知道是哪里引用的</li>\n<li>G1卡表是一个HashMap，key是Region的起始地址，Value是一个集合存放了引用区域的对应的地址</li>\n</ul>\n</li>\n<li>GC机制<ul>\n<li>YGC<ol>\n<li>扫描GC Roots及记忆集的外部引用作为入口</li>\n<li>更新卡表 将所有的卡表更新到最新状态（处理脏卡表）</li>\n<li>处理记忆集 识别指向Eden区的对象</li>\n<li>复制算法清理对象<ul>\n<li>达到年龄阈值，放入Old</li>\n<li>将Eden存活的对象放入Survivor</li>\n</ul>\n</li>\n<li>处理引用 清空Eden区</li>\n</ol>\n</li>\n<li>YGC + 并发标记<ol>\n<li>初始标记，会发生STW；并且会触发一次YGC</li>\n<li>区域扫描，扫描Survivor区可以直接进入Old区的对象</li>\n<li>并发标记，计算每一个Region区域的活性（存活对象的比例）；如果一个Region全是垃圾，那么会立即回收</li>\n<li>再次标记，STW</li>\n<li>独占清理，STW，将Region按回收价值排序，但不会真的去清理</li>\n<li>并发清理</li>\n</ol>\n</li>\n<li>Major GC<ul>\n<li>当越来越多的对象晋升到Old区，此时G1会选择使用Major GC，而不是YGC<br>会回收年轻代+部分老年代</li>\n</ul>\n</li>\n<li>FGC 保证措施<br>G1使用FGC作为保底机制<ul>\n<li>触发条件<ol>\n<li>Old区放不下要晋升的对象</li>\n<li>如果并发标记过程中内存不够用</li>\n<li>最大GC停顿时间太短，导致规定时间内没有GC</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a></h2>","categories":["八股","Java"],"tags":["JVM","Java虚拟机","垃圾回收","Java内存模型"]},{"title":"Java基础","url":"/2024/05/27/Java%E5%9F%BA%E7%A1%80/","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"四大特性\"><a href=\"#四大特性\" class=\"headerlink\" title=\"四大特性\"></a>四大特性</h3><h4 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h4><p>将一些实体的共同特质抽取出来，放进一个概念中（类）</p>\n<blockquote>\n<p>抽象是简化复杂现实世界问题的过程，通过创建模型来表示关键特征和行为。在面向对象编程中，抽象通常是通过类的形式实现的，类定义了一组相关的属性和方法，但不包含具体的实现细节。抽象使得程序员可以专注于问题的概念，而不是具体的实现细节，从而提高了代码的可读性和可维护性。</p>\n</blockquote>\n<p><strong>具体实现</strong>：类和接口</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>相当于一个黑盒，我们只需要知道他能干什么，而不需要知道他要去做什么</p>\n<blockquote>\n<p>封装是将对象的状态（属性）和行为（方法）结合在一起，并对外隐藏其内部实现细节的过程。这意味着对象的内部结构对外部是不可见的，只能通过对象提供的公共接口（方法）来访问和操作对象的状态。封装有助于减少系统的复杂性，并提高安全性和可维护性。</p>\n</blockquote>\n<p><strong>具体实现</strong>：private 方法</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>子类继承父类的一些特性，可以减小代码的冗余度，提高代码重用性</p>\n<blockquote>\n<p>继承是一种创建新类（子类）的方式，新类继承现有类（父类）的属性和方法。继承支持代码的重用，并允许新类扩展或修改父类的行为。通过继承，可以建立类之间的层次关系，使得子类具有父类的所有特性，同时还可以添加或覆盖父类的特性。</p>\n</blockquote>\n<p><strong>具体实现</strong>：类继承和接口实现</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>子类继承父类，但是也可以有子类自己的行为</p>\n<blockquote>\n<p>多态是指允许使用子类的对象来替代父类的对象。这意味着可以用子类特有的方法来覆盖父类的方法，当通过父类引用调用方法时，实际执行的是子类的版本。多态性提高了程序的灵活性和可扩展性，允许在运行时动态决定对象的实际类型。</p>\n</blockquote>\n<p><strong>具体实现</strong>：  可以实现多个接口<br>                        重载<br>                        重写</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><h4 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h4><ul>\n<li>byte：8位有符号的整数，范围从-128到127</li>\n<li>short：16位有符号整数，范围从-32768到32767</li>\n<li>int：32位有符号整数，范围从-2,147,483,648 到 2,147,483,647</li>\n<li>long：64位有符号整数，范围从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</li>\n</ul>\n<h4 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h4><ul>\n<li>float：32位单精度浮点数</li>\n<li>double：64位双精度浮点数</li>\n</ul>\n<h4 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h4><ul>\n<li>char：16位Unicode字符，足以表示任何标准ASCII字符</li>\n</ul>\n<h4 id=\"布尔型\"><a href=\"#布尔型\" class=\"headerlink\" title=\"布尔型\"></a>布尔型</h4><ul>\n<li>boolean：表示逻辑值true或false</li>\n</ul>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><ul>\n<li>表示创建对象的模板，对象是类的实例</li>\n</ul>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><ul>\n<li>定义了一组方法，但不提供实现。类可以实现一个或多个接口</li>\n</ul>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><ul>\n<li>表示相同类型元素的集合，可以是基本数据类型或对象类型的数组</li>\n</ul>\n<h3 id=\"大数类型\"><a href=\"#大数类型\" class=\"headerlink\" title=\"大数类型\"></a>大数类型</h3><h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>构造函数可以传入int、long、String</li>\n<li>使用构造new BigDecimal(0.1)值不为0.1，而是0.1000000000000000055511151231257827021181583404541015625</li>\n<li>如果使用String构造 new BigDecimal(“0.1”) 就是真正的0.1</li>\n<li>如果要使用double 类型构造 BigDecimal 先用Double.toString(double)，再把String传入BigDecimal的构造</li>\n</ul>\n<h3 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h3><h4 id=\"Java的四种时间类型\"><a href=\"#Java的四种时间类型\" class=\"headerlink\" title=\"Java的四种时间类型\"></a>Java的四种时间类型</h4><ul>\n<li>java.util.Date</li>\n<li>java.sql.Date</li>\n<li>java.sql.time</li>\n<li>java.sql.TimeStamp</li>\n</ul>\n<h4 id=\"对应关系\"><a href=\"#对应关系\" class=\"headerlink\" title=\"对应关系\"></a>对应关系</h4><ul>\n<li>date：对应Java的java.sql.Date类型</li>\n<li>TIME：对应Java的java.sql.Time类型</li>\n<li>DATETIME、TIMESTAMP：对应Java的java.sql.TimeStamp类型</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><h4 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h4><ul>\n<li>该类不可以被继承</li>\n<li>被final修饰的类不能被CGlib动态代理</li>\n</ul>\n<h4 id=\"修饰方法\"><a href=\"#修饰方法\" class=\"headerlink\" title=\"修饰方法\"></a>修饰方法</h4><ul>\n<li>不可以被重写</li>\n</ul>\n<h4 id=\"修饰变量\"><a href=\"#修饰变量\" class=\"headerlink\" title=\"修饰变量\"></a>修饰变量</h4><ul>\n<li>修饰基本类型 值不可以被改变</li>\n<li>修饰引用类型 引用类型的地址不可变，但是引用类型内的值可以变</li>\n</ul>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><ul>\n<li>修饰后不会被序列化</li>\n</ul>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h4 id=\"修饰类-1\"><a href=\"#修饰类-1\" class=\"headerlink\" title=\"修饰类\"></a>修饰类</h4><ul>\n<li>修饰后为静态内部类</li>\n</ul>\n<h4 id=\"修饰变量-1\"><a href=\"#修饰变量-1\" class=\"headerlink\" title=\"修饰变量\"></a>修饰变量</h4><ul>\n<li>类变量（不同于实例变量 类变量在类加载的时候就被创建 存储在Java方法区）</li>\n</ul>\n<h4 id=\"修饰方法-1\"><a href=\"#修饰方法-1\" class=\"headerlink\" title=\"修饰方法\"></a>修饰方法</h4><ul>\n<li>类方法</li>\n<li>没有this</li>\n</ul>\n<h4 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h4><ul>\n<li>用来初始化数据</li>\n</ul>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>在类加载的第三阶段初始化阶段，使用<clinit>方法进行初始化（<clinit>是编译器给的方法）</li>\n<li>static修饰的为类的成员，可以直接使用类名调用，不需要实例对象</li>\n<li>静态内部类只会在用到其时才会加载，且只加载一次，可以实现单例模式</li>\n</ul>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"不同版本接口加入了不同功能\"><a href=\"#不同版本接口加入了不同功能\" class=\"headerlink\" title=\"不同版本接口加入了不同功能\"></a>不同版本接口加入了不同功能</h3><h4 id=\"JDK1-7\"><a href=\"#JDK1-7\" class=\"headerlink\" title=\"JDK1.7\"></a>JDK1.7</h4><ul>\n<li>有常量、抽象方法</li>\n<li>常量必须使用public static final修饰，可以省略</li>\n<li>抽象方法就是abstract方法，abstract关键字可以不写</li>\n</ul>\n<h4 id=\"JDK1-8\"><a href=\"#JDK1-8\" class=\"headerlink\" title=\"JDK1.8\"></a>JDK1.8</h4><ul>\n<li>有默认方法<ul>\n<li>用default标识</li>\n<li>默认方法可以不重写</li>\n</ul>\n</li>\n<li>静态方法<ul>\n<li>用static标识</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JDK1-9\"><a href=\"#JDK1-9\" class=\"headerlink\" title=\"JDK1.9\"></a>JDK1.9</h4><ul>\n<li>私有方法</li>\n</ul>\n<h3 id=\"为什么要有接口？\"><a href=\"#为什么要有接口？\" class=\"headerlink\" title=\"为什么要有接口？\"></a>为什么要有接口？</h3><p>解决Java只能单继承的缺陷</p>\n<h3 id=\"为什么JDK1-8引入了默认方法？\"><a href=\"#为什么JDK1-8引入了默认方法？\" class=\"headerlink\" title=\"为什么JDK1.8引入了默认方法？\"></a>为什么JDK1.8引入了默认方法？</h3><p>增加了可扩展性</p>\n<h3 id=\"为什么JDK1-9引入了私有方法？\"><a href=\"#为什么JDK1-9引入了私有方法？\" class=\"headerlink\" title=\"为什么JDK1.9引入了私有方法？\"></a>为什么JDK1.9引入了私有方法？</h3><p>为了提高代码重用消除冗余代码</p>\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>接口有抽象方法<ul>\n<li>public abstract默认就存在可以省略</li>\n<li>抽象方法实现类必须实现</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"接口与类的区别\"><a href=\"#接口与类的区别\" class=\"headerlink\" title=\"接口与类的区别\"></a>接口与类的区别</h4><ul>\n<li>接口没有构造方法；所以不能new接口</li>\n<li>接口没有静态代码块</li>\n<li>一个类可以实现多个接口</li>\n</ul>\n<h2 id=\"类-1\"><a href=\"#类-1\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>可以实现构造方法</li>\n<li>一定有抽象方法 （抽象方法不能有实现体）</li>\n<li>如果子类没有重写所有的构造方法，子类还是一个抽象类</li>\n<li><strong>抽象类与接口的区别</strong>：<ol>\n<li>构造方法：接口无、抽象类有</li>\n<li>实现方法：接口默认方法可以不实现、抽象类不实现任意一个构造方法还是一个抽象类</li>\n<li>实现类：一个类只能实现一个抽象类，但是可以实现多个接口</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>嵌套类，属于类的一部分</p>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>绑定在了this即实例上面，属于实例的一部分</p>\n<h3 id=\"静态内部类与内部类的区别\"><a href=\"#静态内部类与内部类的区别\" class=\"headerlink\" title=\"静态内部类与内部类的区别\"></a>静态内部类与内部类的区别</h3><ul>\n<li>静态内部类属于类；而内部类属于实例</li>\n<li>静态内部类在没有使用到的时候，不会加载；内部类只要外部类加载就会加载</li>\n<li>内部类可以访问外部类的一切方法与变量；静态内部类只能访问外部类的静态变量</li>\n<li>内部类不能有静态方法；静态内部类可以既有普通方法，又有静态方法；</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"Throwable接口\"><a href=\"#Throwable接口\" class=\"headerlink\" title=\"Throwable接口\"></a>Throwable接口</h3><p>Java的异常类都继承自java.lang.throwable类</p>\n<blockquote>\n<p>Throwable有两个主要的子类Exception和Error</p>\n</blockquote>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><blockquote>\n<p>运行中难以预料的异常</p>\n</blockquote>\n<p>例如</p>\n<ul>\n<li>OOM<br>“OutOfMemory”通常指的是Java应用程序中的内存不足错误，导致无法分配更多的内存空间。这通常表现为java.lang.OutOfMemoryError异常</li>\n<li>SOF<br>SOF：表示栈溢出错误，表示堆栈已满，无法创建新的方法调用帧。  通常是调用递归层次过深。</li>\n</ul>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h3><blockquote>\n<p>可以预见的异常</p>\n<p>分为两大类：检查型异常和非检查型异常</p>\n</blockquote>\n<h4 id=\"检查型异常（编译时异常）\"><a href=\"#检查型异常（编译时异常）\" class=\"headerlink\" title=\"检查型异常（编译时异常）\"></a>检查型异常（编译时异常）</h4><ul>\n<li>必须显示抛出或者捕获</li>\n<li>举例<ul>\n<li>IOException</li>\n<li>InterruptedException</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>NullPointException</p>\n<h3 id=\"异常捕获\"><a href=\"#异常捕获\" class=\"headerlink\" title=\"异常捕获\"></a>异常捕获</h3><blockquote>\n<p>Try Catch Finally</p>\n</blockquote>\n<ul>\n<li>只要try的代码执行，finally的代码执行</li>\n<li>为什么finally必会执行？<ul>\n<li>try块有return，finally无return<br>当执行到try块的return时，会将要return的值存入一个临时变量，然后去执行finally，最后返回临时变量的值</li>\n<li>try块有return，finally有return<br>这种情况下，finally的return会覆盖掉try的return的临时变量的值，所以返回finally的值</li>\n</ul>\n</li>\n<li>如果finally有return，那就是返回这个值，如果没有，那么finally无论如何操作数据，都不会影响返回值</li>\n</ul>\n<h2 id=\"拆箱和装箱\"><a href=\"#拆箱和装箱\" class=\"headerlink\" title=\"拆箱和装箱\"></a>拆箱和装箱</h2><h3 id=\"什么是拆箱和装箱？\"><a href=\"#什么是拆箱和装箱？\" class=\"headerlink\" title=\"什么是拆箱和装箱？\"></a>什么是拆箱和装箱？</h3><ul>\n<li><strong>装箱</strong>：将Java的基本数据类型（如<code>int</code>、<code>double</code>等）转换为它们对应的包装类对象（如<code>Integer</code>、<code>Double</code>等）的过程</li>\n<li><strong>拆箱</strong>：将包装类对象转换回它们对应的基本数据类型的过程</li>\n</ul>\n<h3 id=\"为什么要装箱和拆箱？\"><a href=\"#为什么要装箱和拆箱？\" class=\"headerlink\" title=\"为什么要装箱和拆箱？\"></a>为什么要装箱和拆箱？</h3><ul>\n<li>装箱和拆箱使得我们可以在需要对象类型的地方使用基本数据类型，这在集合框架中尤其有用，因为集合只能存储对象</li>\n<li>自动装箱和拆箱简化了代码，使得我们可以在不显式进行类型转换的情况下在基本类型和包装类之间自由切换</li>\n</ul>\n<h3 id=\"哪些基本数据类型有对应的包装类？\"><a href=\"#哪些基本数据类型有对应的包装类？\" class=\"headerlink\" title=\"哪些基本数据类型有对应的包装类？\"></a>哪些基本数据类型有对应的包装类？</h3><ul>\n<li>Java为每个基本数据类型提供了对应的包装类：<code>Integer</code>、<code>Double</code>、<code>Float</code>、<code>Long</code>、<code>Short</code>、<code>Byte</code>、<code>Character</code>、<code>Boolean</code></li>\n</ul>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><h3 id=\"是什么？用途？\"><a href=\"#是什么？用途？\" class=\"headerlink\" title=\"是什么？用途？\"></a>是什么？用途？</h3><p><code>ThreadLocal</code>类提供了线程局部变量的实现。它允许每个线程都可以拥有自己的变量副本，这些副本对于其他线程是不可见的。这在处理线程安全问题时非常有用，尤其是当你想要避免同步或者使用全局变量时</p>\n<h3 id=\"如何解决多线程共享资源问题？\"><a href=\"#如何解决多线程共享资源问题？\" class=\"headerlink\" title=\"如何解决多线程共享资源问题？\"></a>如何解决多线程共享资源问题？</h3><p><code>ThreadLocal</code>通过为每个线程提供独立的变量副本来避免共享资源问题。这样，每个线程都可以独立地操作自己的资源，而不需要担心其他线程的干扰</p>\n<h3 id=\"工作原理？\"><a href=\"#工作原理？\" class=\"headerlink\" title=\"工作原理？\"></a>工作原理？</h3><p><code>ThreadLocal</code>内部使用<code>ThreadLocalMap</code>来存储每个线程的局部变量。当一个线程首次访问<code>ThreadLocal</code>变量时，它会在当前线程的<code>Thread</code>对象中创建一个条目，并存储变量的值。之后，同一个线程的所有访问都会返回这个线程特有的值</p>\n<h3 id=\"同步机制相比有什么优势？\"><a href=\"#同步机制相比有什么优势？\" class=\"headerlink\" title=\"同步机制相比有什么优势？\"></a>同步机制相比有什么优势？</h3><p>与同步机制相比，<code>ThreadLocal</code>避免了线程之间的竞争，因为它为每个线程提供了独立的变量副本。这可以减少锁的使用，提高程序的性能。此外，<code>ThreadLocal</code>也简化了代码，因为它不需要复杂的同步逻辑</p>\n<h3 id=\"常见的使用场景？\"><a href=\"#常见的使用场景？\" class=\"headerlink\" title=\"常见的使用场景？\"></a>常见的使用场景？</h3><ul>\n<li>为每个线程提供单独的数据库连接</li>\n<li>存储用户请求相关的数据，如会话信息</li>\n<li>缓存特定于线程的数据</li>\n<li>避免在多线程环境中传递线程不安全的实例</li>\n</ul>\n<h3 id=\"内存泄露问题？\"><a href=\"#内存泄露问题？\" class=\"headerlink\" title=\"内存泄露问题？\"></a>内存泄露问题？</h3><p><code>ThreadLocal</code>可能导致内存泄漏，因为<code>ThreadLocalMap</code>中的条目不会自动清理。如果线程的生命周期很长，或者线程对象被长时间保留，那么存储在<code>ThreadLocal</code>中的大对象可能会占用大量内存。当线程结束时，应该调用<code>ThreadLocal</code>的<code>remove</code>方法来显式清理这些条目。</p>\n<h3 id=\"如何解决内存泄漏？\"><a href=\"#如何解决内存泄漏？\" class=\"headerlink\" title=\"如何解决内存泄漏？\"></a>如何解决内存泄漏？</h3><ul>\n<li>在使用<code>ThreadLocal</code>的代码块结束后，显式调用<code>ThreadLocal</code>的<code>remove</code>方法来清理存储的数据。</li>\n<li>避免在<code>ThreadLocal</code>中存储大对象或长时间存活的对象。</li>\n<li>使用<code>WeakReference</code>来引用<code>ThreadLocal</code>变量，以便在垃圾回收时能够清除这些引用。</li>\n</ul>\n<h3 id=\"ThreadLocal与AtomicInteger-ConcurrentHashMap等并发工具类的区别？\"><a href=\"#ThreadLocal与AtomicInteger-ConcurrentHashMap等并发工具类的区别？\" class=\"headerlink\" title=\"ThreadLocal与AtomicInteger&#x2F;ConcurrentHashMap等并发工具类的区别？\"></a><code>ThreadLocal</code>与<code>AtomicInteger</code>&#x2F;<code>ConcurrentHashMap</code>等并发工具类的区别？</h3><p><code>ThreadLocal</code>提供了线程隔离的变量，而<code>AtomicInteger</code>和<code>ConcurrentHashMap</code>等并发工具类提供了线程安全的共享变量。<code>ThreadLocal</code>适用于不需要跨线程共享数据的场景，而<code>AtomicInteger</code>和<code>ConcurrentHashMap</code>适用于需要在多个线程之间同步访问共享资源的场景</p>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"String相关\"><a href=\"#String相关\" class=\"headerlink\" title=\"String相关\"></a>String相关</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>final修饰，不可继承的类</strong></li>\n<li><strong>底层使用char[]数组存，也有final修饰，值不可变（JDK1.8）</strong></li>\n<li><strong>JDK1.9使用byte[]数组存放</strong></li>\n<li><strong>为什么1.9要使用byte数组？</strong><br>为了节省内存，据调查存储的字符串70%都是拉丁字母，byte占一个字节，char占两个字节，占1个字节更省内存</li>\n</ul>\n<h4 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h4><ul>\n<li>本质 是一个固定大小的HashMap</li>\n<li>字面量会直接进入字符串常量池</li>\n<li>String对象调用intern方法也会进入字符串常量池</li>\n<li>存放的位置 <strong>JDK1.6之前存放在方法区；JDK1.7之后存放在堆区</strong></li>\n</ul>\n<h4 id=\"intern-方法\"><a href=\"#intern-方法\" class=\"headerlink\" title=\"intern()方法\"></a><strong>intern()方法</strong></h4><ul>\n<li><p>JDK1.6中</p>\n<p>如果池中没有，那么就再创建一个新的对象放在池中</p>\n</li>\n<li><p>JDK1.7后</p>\n<p>如果池中没有，就会将当前这个对象的地址复制一份，放入堆中，不用重新创建对象了</p>\n</li>\n</ul>\n<h4 id=\"new-String-“a”-会创建几个对象？\"><a href=\"#new-String-“a”-会创建几个对象？\" class=\"headerlink\" title=\"new String(“a”)会创建几个对象？\"></a>new String(“a”)会创建几个对象？</h4><ul>\n<li>2个<ul>\n<li>new String一个</li>\n<li>字面量a一个</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"String-b-new-String-“a”-“B”-会创建几个对象？\"><a href=\"#String-b-new-String-“a”-“B”-会创建几个对象？\" class=\"headerlink\" title=\"String b &#x3D; new String(“a”) + “B”;会创建几个对象？\"></a>String b &#x3D; new String(“a”) + “B”;会创建几个对象？</h4><ul>\n<li>4个对象<ul>\n<li>newString一个</li>\n<li>a</li>\n<li>b</li>\n<li>拼接用到了StringBuilder，也是一个</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h3><ul>\n<li>线程不安全</li>\n<li>但是会更快一点</li>\n<li>String之间的拼接默认就是用StringBuilder优化的</li>\n</ul>\n<h3 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h3><ul>\n<li>方法中有synchronized进程同步关键字 线程安全但是效率慢</li>\n<li>StringBuilder 和 StringBuffer 继承自AbstractStringBuilder类</li>\n</ul>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h3 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h3><blockquote>\n<p>阻塞IO 即IO会阻塞当前线程，必须等待IO完成后才能继续执行</p>\n</blockquote>\n<h4 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h4><h5 id=\"TCP通信\"><a href=\"#TCP通信\" class=\"headerlink\" title=\"TCP通信\"></a>TCP通信</h5><ul>\n<li>Socket<ul>\n<li>客户端Socket</li>\n<li>API<ul>\n<li>connect(new InetSocketAddress(“IP”, port)) 连接客户端</li>\n<li>socket.getOutputStream() 获取输出流，向服务器write数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ServerSocket<ul>\n<li>服务端Socket</li>\n<li>API<ul>\n<li>bind 监听一个本地的端口号</li>\n<li>accept 阻塞等待客户端连接，所谓的BIO在于此</li>\n<li>getInputStream 获取输入流，读入客户端数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"UDP通信\"><a href=\"#UDP通信\" class=\"headerlink\" title=\"UDP通信\"></a>UDP通信</h5><ul>\n<li>DatagramSocket <ul>\n<li>客户端服务器端都使用这个类</li>\n<li>API<ul>\n<li>new DatagramSocket (port) 绑定一个端口创建服务</li>\n<li>send(DatagramPacket) 发送数据报</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>DatagramPacket<ul>\n<li>UDP无需建立连接，每一个数据报内部传输IP+port</li>\n<li>API<ul>\n<li>atagramPacket(byte[] buf, int length, InetAddress addr, int port)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"弊端\"><a href=\"#弊端\" class=\"headerlink\" title=\"弊端\"></a>弊端</h4><p>一个Socket需要一个线程，浪费性能</p>\n<h3 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h3><blockquote>\n<p>非阻塞IO或者叫New IO</p>\n<p>IO操作是非阻塞的，即IO操作不会阻塞当前线程，需要主线程一段时间来判断一次是否IO完毕</p>\n</blockquote>\n<h4 id=\"NIO与BIO的区别\"><a href=\"#NIO与BIO的区别\" class=\"headerlink\" title=\"NIO与BIO的区别\"></a>NIO与BIO的区别</h4><ul>\n<li>BIO面向流；NIO面向缓冲区</li>\n<li>BIO单向，要么读要么写；NIO双向</li>\n<li>BIO 是阻塞的；NIO 是非阻塞的</li>\n<li>BIO只能向后读；NIO可以前后读<br>BIO 读写是面向流的，一次性只能从流中读取一个或者多个字节，并且读完之后流无法再读取，除非我们缓存起来</li>\n</ul>\n<h4 id=\"Java具体主要使用三个组件来实现NIO\"><a href=\"#Java具体主要使用三个组件来实现NIO\" class=\"headerlink\" title=\"Java具体主要使用三个组件来实现NIO\"></a>Java具体主要使用三个组件来实现NIO</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240326211804092.png\" alt=\"image-20240326211804092\"></p>\n<h5 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h5><h6 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h6><ul>\n<li>继承了SelectableChannel的类<ul>\n<li>SocketChannel TCP客户端</li>\n<li>ServerSocketChannel TCP服务器端</li>\n<li>DatagramChannel UDP数据报</li>\n</ul>\n</li>\n<li>FileChannel 不能被复用</li>\n</ul>\n<h6 id=\"特点-4\"><a href=\"#特点-4\" class=\"headerlink\" title=\"特点\"></a>特点</h6><ul>\n<li>操作是双向的</li>\n<li>异步</li>\n<li>不能直接访问数据，需要与buffer配合使用</li>\n</ul>\n<h5 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h5><ul>\n<li><p>每一个Channel都得在Selector上注册，注册后会返回一个选择键SelectionKey<br>selectionKey<br>代表Selector与Channel关系的类</p>\n<p>可以通过其获得Selector与Channel</p>\n</li>\n<li><p>每执行一次select()方法，都会返回一个当前就绪的通道的数量</p>\n</li>\n<li><p>维护三个集合</p>\n<ul>\n<li>keys 已注册键的集合</li>\n<li>selectKeys 已选择的键的集合（即就绪的键的集合）</li>\n<li>已取消的集合</li>\n</ul>\n</li>\n<li><p>建立Selector系统</p>\n<ul>\n<li>Selector.open()创建一个Selector</li>\n<li>设置通道为非阻塞</li>\n<li>通道调用register()注册在此Selector上<ul>\n<li>关心的操作有<ol>\n<li>Read</li>\n<li>Write</li>\n<li>Connect</li>\n<li>Accept</li>\n</ol>\n</li>\n<li>指向过程<ol>\n<li>检查已取消的键的集合</li>\n<li>检查已注册的键的集合</li>\n<li>返回值</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h5><blockquote>\n<p>通道的通信都需要经过Buffer来实现</p>\n</blockquote>\n<h6 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h6><ul>\n<li>allocate(long) 传入一个大小，开辟指定大小的缓存，缓存开辟在JVM的堆</li>\n<li>allocateDirect(long) 分配一个直接缓存区，开辟在JVM之外</li>\n<li>wrap(byte[]) 将一个byte数组作为一个缓存</li>\n</ul>\n<h6 id=\"直接缓冲区和非缓冲区的区别\"><a href=\"#直接缓冲区和非缓冲区的区别\" class=\"headerlink\" title=\"直接缓冲区和非缓冲区的区别\"></a>直接缓冲区和非缓冲区的区别</h6><ul>\n<li>直接缓冲区的开销少，少一次复制的过程</li>\n<li>假设给一个通道传入了一个非直接缓冲区，那么通道会先创建一个临时的直接缓冲区，将非直接缓冲区的数据复制到临时的直接缓冲区，使用这个临时的直接缓冲区去执行 IO 操作（多一次拷贝，增大了开销）</li>\n</ul>\n<h6 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h6><ul>\n<li><p>flip<br>将写模式转换为读模式，将当前的limit设置为position，然后将position设为0</p>\n</li>\n<li><p>compact</p>\n<p>压缩，将未读取的数据（position与limit之间的数据）向前移动</p>\n</li>\n<li><p>hasRemaining<br>读取时在while循环内使用hasRemaining判断，判断position与limit之间的距离</p>\n</li>\n</ul>\n<h6 id=\"维护了四个值\"><a href=\"#维护了四个值\" class=\"headerlink\" title=\"维护了四个值\"></a>维护了四个值</h6><ul>\n<li>mark 标记位置，每次reset会回到这个位置</li>\n<li>position 当前位置，每写入一个就+1（指向最新元素的下一个空白的位置）</li>\n<li>limit 第一个不能被读写的位置</li>\n<li>capacity 总容量</li>\n</ul>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"子接口\"><a href=\"#子接口\" class=\"headerlink\" title=\"子接口\"></a>子接口</h3><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><h5 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h5><blockquote>\n<p>用数组实现的列表，适合查询，不适合增删</p>\n</blockquote>\n<h6 id=\"结构特点\"><a href=\"#结构特点\" class=\"headerlink\" title=\"结构特点\"></a>结构特点</h6><ul>\n<li>由一个对象数组构成</li>\n<li>初始容量10，最大容量Integer.max - 8 | 为什么减去8？<ul>\n<li>给虚拟机预留一些数据存放对象的其他数据</li>\n</ul>\n</li>\n<li>grow() 扩容<ul>\n<li>扩容每次扩容1.5倍，扩容方式直接调用System.copyOf()</li>\n<li>ArrayList有缩容方法trimSize，但是不会去自动调用，需要执行</li>\n</ul>\n</li>\n<li>clone() 浅拷贝<br>就是创建一个对象的副本，这个对象的引用还是指向原来对象的，即新对象和原来对象共用同一个内存空间</li>\n<li>get(index)方法<br>检查是否越界，直接返回对应下标数组的数据</li>\n<li>set(index, value)方法 返回旧数据</li>\n<li>add(value) 直接添加到末尾</li>\n<li>add(index, value)<br>调用System.copy将index之后的所有数据，向后copy一格，然后把这个数据放在这里</li>\n<li>remove(index)<ul>\n<li>直接调System.copy将数据从index后覆盖前一个数据即可</li>\n<li>remove操作会更改modcount值</li>\n<li>modCount用于Fast-Fail检测<ul>\n<li>在使用迭代器遍历集合时，如果在遍历过程中有其他线程修改了集合的内容，迭代器会在下一个 next() 调用时检测到 modCount 的变化，并抛出 ConcurrentModificationException，以避免产生不一致的结果</li>\n<li>如果是fori遍历，然后remove，不会报这个错</li>\n<li>如果是迭代器或是foreach遍历，然后remove，就会报这个错</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>indexOf(value)<br>返回该值第一次出现的下标</li>\n<li>lastIndexof(value)<br>返回该值最后一次出现的下标</li>\n</ul>\n<h5 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h5><ul>\n<li>用链表实现的列表</li>\n<li>适合增删，不适合查询</li>\n<li>是一个双向队列</li>\n</ul>\n<h5 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h5><h6 id=\"子类-Stack\"><a href=\"#子类-Stack\" class=\"headerlink\" title=\"子类 Stack\"></a>子类 Stack</h6><p>用vector实现的栈，已经退出Java舞台，推荐使用Deque来代替这个类</p>\n<blockquote>\n<p>是一个线程安全类 方法上有synchronized同步关键字，实现了线程安全</p>\n</blockquote>\n<h6 id=\"结构特点-1\"><a href=\"#结构特点-1\" class=\"headerlink\" title=\"结构特点\"></a>结构特点</h6><ul>\n<li>默认大小10</li>\n<li>扩容倍数，可以自己设置，如果不设置默认成倍增长</li>\n</ul>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><h5 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h5><ul>\n<li><p>子类<br>LinkedHashSet</p>\n</li>\n<li><p>底层由一个HashMap实现</p>\n</li>\n<li><p>可以存null</p>\n</li>\n<li><p>如何实现了去重？</p>\n<ul>\n<li><code>HashSet</code>的内部结构是一个<code>HashMap</code>。当你向<code>HashSet</code>添加元素时，实际上是将元素作为键（key）放入这个内部的<code>HashMap</code>中。<code>HashMap</code>使用元素的<code>hashCode()</code>方法来计算哈希值，并根据这个哈希值将元素存储在不同的桶（bucket）中</li>\n<li>每个对象都有一个<code>hashCode</code>方法，它返回一个整数值，这个值是由对象的内容计算得到的。如果两个对象的<code>hashCode</code>相同，它们可能会存储在同一个桶中，但这并不意味着它们是相同的对象</li>\n<li>当<code>HashSet</code>尝试添加一个新元素时，它会首先调用这个元素的<code>hashCode()</code>方法来获取哈希值，然后根据哈希值找到对应的桶。在同一个桶中的元素，<code>HashSet</code>会通过调用<code>equals()</code>方法来检查是否已经存在一个相同的对象。如果<code>equals()</code>返回<code>true</code>，则认为这两个对象相同，新元素不会被添加到<code>HashSet</code>中，从而实现了去重</li>\n<li>由于<code>HashSet</code>内部使用<code>HashMap</code>，它能够提供快速的查找和插入操作。当查找一个元素是否存在时，<code>HashSet</code>会使用元素的<code>hashCode()</code>来快速定位到桶，然后在桶中通过<code>equals()</code>方法来检查元素是否存在</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><h5 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h5><ul>\n<li>底层是一个二叉堆 存储用一个Object数组来存储</li>\n<li>实现了Comparator接口，通过重写compare()方法来实现，来进行比较</li>\n<li>默认排序为从小到大</li>\n</ul>\n<h5 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h5><ul>\n<li>LinkedList</li>\n<li>ArrayList</li>\n</ul>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li>size()</li>\n<li>contains()</li>\n<li>iterator()</li>\n<li>toArray()</li>\n<li>add()</li>\n<li>remove()</li>\n<li>containsAll()</li>\n<li>addAll()</li>\n</ul>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><blockquote>\n<p>Collection继承了Interator,重写iterator方法，可以返回一个迭代器</p>\n</blockquote>\n<h4 id=\"核心API-1\"><a href=\"#核心API-1\" class=\"headerlink\" title=\"核心API\"></a>核心API</h4><ul>\n<li>hasNext()</li>\n<li>next()</li>\n<li>remove()</li>\n<li>迭代方式 使用while循环，判断条件hasNext</li>\n</ul>\n<h4 id=\"Fast-Fail-快速失败机制\"><a href=\"#Fast-Fail-快速失败机制\" class=\"headerlink\" title=\"Fast-Fail 快速失败机制\"></a>Fast-Fail 快速失败机制</h4><blockquote>\n<p>集合类都有快速失败机制，迭代遍历过程中如果对集合类内容进行了更改，就会抛出异常</p>\n</blockquote>\n<ul>\n<li>原理：通过内部定义的一个字段 modCount来判断是否更改过这个集合，如果修改了集合（add或者remove），那么modCount也会被修改，检测到modCount值不同后，就抛出一个ConcurrentModificationException</li>\n</ul>\n<h4 id=\"安全失败机制\"><a href=\"#安全失败机制\" class=\"headerlink\" title=\"安全失败机制\"></a>安全失败机制</h4><ul>\n<li>对于JUC包下的类比如CopyOnWriteArrayList，就不会抛出ConcurrentModificationException异常</li>\n<li>因为迭代器修改的是原容器的复制，而不是容器本身，这样的机制称为安全失败机制</li>\n</ul>\n<h4 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for each\"></a>for each</h4><ul>\n<li><p>Java的一个语法糖，其实内部就是使用迭代器迭代的</p>\n</li>\n<li><p>for each操作不能增删元素，会抛出异常</p>\n</li>\n</ul>\n<p>迭代进行删除操作</p>\n<ul>\n<li>可以使用for i</li>\n<li>可以使用迭代器的remove方法</li>\n</ul>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><h4 id=\"结构特点-2\"><a href=\"#结构特点-2\" class=\"headerlink\" title=\"结构特点\"></a>结构特点</h4><ul>\n<li><p>初始容量大小</p>\n</li>\n<li><p>默认负载因子0.75</p>\n<ul>\n<li>为什么负载因子是0.75?<br>根据泊松分布，0.75可以达到一个不错的散列程度</li>\n<li>负载因子有什么作用？<ol>\n<li>负载因子控制着hash数组的散列程度</li>\n<li>负载因子大，节省内存，但是会导致哈希碰撞比较严重</li>\n<li>负载因子小，查询快，但是会很浪费内存</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>链化与树化</p>\n<ul>\n<li>当链表长度大于8，且数组size达到64会将链表转化为红黑树</li>\n<li>当链表长度小于6 会将红黑树转化为链表</li>\n<li>为什么变化阈值为6和8？ 为了防止复杂度震荡</li>\n</ul>\n</li>\n<li><p>扩容大小一定是2的倍数</p>\n<p>方便查找元素 根据keyHash &amp; (size - 1)就可以快速找到下标元素</p>\n</li>\n<li><p><strong>为什么要重写equals和hashCode方法</strong></p>\n<p>当你重写了<code>equals</code>方法来定义对象的相等性时，也应该重写<code>hashCode</code>方法，以确保<code>hashCode</code>与<code>equals</code>保持一致。如果两个对象根据<code>equals</code>方法比较是相等的，那么它们应该返回相同的<code>hashCode</code>值</p>\n</li>\n<li><p>遍历</p>\n<p>可以foreach+keySet方法遍历</p>\n<p>可以用foreach+entrySet方法遍历</p>\n</li>\n<li><p>HashMap不是线程安全类，不要在并发下使用</p>\n</li>\n<li><p><strong>resize方法</strong></p>\n<ul>\n<li>承担两个任务：1 初始化Node数组 2 进行扩容操作</li>\n<li>每次扩容大小翻倍</li>\n<li>JDK1.7扩容时头插法，JDK1.8扩容时尾插法</li>\n<li>新下标：hash &amp; (newTable.length-1)<br>其实就是：要不然就是旧下标，要不然就是旧下标加上旧数组的长度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JDK1-7与JDK1-8的变化\"><a href=\"#JDK1-7与JDK1-8的变化\" class=\"headerlink\" title=\"JDK1.7与JDK1.8的变化\"></a>JDK1.7与JDK1.8的变化</h4><h5 id=\"JDK1-7-1\"><a href=\"#JDK1-7-1\" class=\"headerlink\" title=\"JDK1.7\"></a>JDK1.7</h5><ul>\n<li>由数组+链表实现</li>\n<li>hash计算直接使用hashcode</li>\n<li>头插法<ul>\n<li>扩容时会改变链表的顺序，可能会形成链表环</li>\n<li>在并发情况下，如果此时正好进行了扩容与插入，容易形成链表环，cpu占用直接100%</li>\n</ul>\n</li>\n<li>扩容在插入节点之前</li>\n<li>寻找节点下标 用indexFor()方法</li>\n<li>对于key为null有专门的操作putForNullKey<br>这个方法就是找0的桶，看看有没有key为null的对象</li>\n</ul>\n<h5 id=\"JDK1-8-1\"><a href=\"#JDK1-8-1\" class=\"headerlink\" title=\"JDK1.8\"></a>JDK1.8</h5><ul>\n<li>由数组+链表+红黑树实现<br>为了解决链表过长，引起遍历速度下降的问题<br>也是为了解决链表环的问题</li>\n<li>寻找下标，直接用keyHash &amp; (size - 1)即可，去除了indexFor方法</li>\n<li>扩容在插入结点之后</li>\n<li>尾插法<br>扩容时不会改变链表的顺序</li>\n<li><strong>哈希方法：前16位和后16位异或在运算</strong><br>将高位与低位混合，增大散列程度，使散列出来的数组更加的均匀</li>\n<li>对于key为null没有专门的操作</li>\n</ul>\n<h3 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h3><ul>\n<li>初始容量为11</li>\n<li>负载因子也是0.75</li>\n<li>线程安全，使用synchronized保证了线程安全</li>\n</ul>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><h3 id=\"三个Map的区别\"><a href=\"#三个Map的区别\" class=\"headerlink\" title=\"三个Map的区别\"></a>三个Map的区别</h3><ul>\n<li><p><strong>数据结构组成</strong></p>\n<ul>\n<li>HashMap 数组加红黑树加链表</li>\n<li>HashTable 数组加链表</li>\n<li>TreeMap 数组加红黑树</li>\n</ul>\n</li>\n<li><p><strong>是否线程安全</strong><br>HashTable线程安全，其他两个不是</p>\n</li>\n<li><p><strong>key是否可以为null</strong></p>\n<p>HashMap可以，其他两个不可以</p>\n</li>\n<li><p><strong>是否有序</strong></p>\n<p>TreeMap有序，其他两个无序</p>\n</li>\n</ul>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><blockquote>\n<p>所有类的超类</p>\n<p>所有的方法都是native方法，是由C&#x2F;C++实现的</p>\n</blockquote>\n<h3 id=\"核心API-2\"><a href=\"#核心API-2\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><p>registerNatives():该方法在static静态代码块调用，注册所有的native方法</p>\n<h4 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h4><ul>\n<li>hashCode()<ul>\n<li>获取哈希值</li>\n<li>哈希值的实现很复杂，其不仅仅是简单的返回一个地址值，分了很多种情况，具体不需要再做了解</li>\n</ul>\n</li>\n<li><strong>equals()</strong><ul>\n<li>默认就是使用&#x3D;&#x3D;判断</li>\n</ul>\n</li>\n<li>clone()<ul>\n<li>配合Cloneable接口使用，用来对一个类进行一个Copy，默认为浅拷贝</li>\n</ul>\n</li>\n<li>toString() <ul>\n<li>转化为字符串</li>\n<li>默认打印此Class对象的名称+@+哈希值</li>\n</ul>\n</li>\n<li>finalize()<ul>\n<li>类似于C++析构函数，但有所区别，其不需要我们自己调用</li>\n<li>如果我们希望一个对象被GC时可以被复活，可以在这个方法内给该对象重新指向一个位置，使该对象重新可达</li>\n<li>会被一个低优先级的线程执行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h4><ul>\n<li>getClass() 获取类对象</li>\n</ul>\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><ul>\n<li><strong>notify()</strong><ul>\n<li>随机唤醒一个在等待队列中的线程</li>\n<li>让线程进入RUNNABLE状态</li>\n</ul>\n</li>\n<li><strong>notifyAll()</strong><ul>\n<li>将等待队列中的线程全部唤醒</li>\n<li>让线程进入RUNNABLE状态</li>\n</ul>\n</li>\n<li><strong>wait()</strong><ul>\n<li>进入等待，会释放锁资源</li>\n<li>让线程进入WAITING状态</li>\n</ul>\n</li>\n<li><strong>wait(long)</strong><ul>\n<li>加了时间的等待状态</li>\n<li>让线程进入TIMED_WATING状态</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四种引用\"><a href=\"#四种引用\" class=\"headerlink\" title=\"四种引用\"></a>四种引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>比如new的对象，只要强引用存在就不会回收，即使报OOM也不会回收</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><ul>\n<li><p>java.lang.ref.SoftReference类实现</p>\n</li>\n<li><p>内存不足时会回收</p>\n</li>\n<li><p>通常用于实现内存敏感的缓存</p>\n</li>\n</ul>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><ul>\n<li><p>通过java.lang.ref.WeakReference类实现</p>\n</li>\n<li><p>不会阻止垃圾回收器回收其指向的对象</p>\n</li>\n<li><p>常用于监听对象的声明周期例如弱键WeakHashMap</p>\n</li>\n</ul>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><ul>\n<li><p>Java.lang.ref.PhantomReference类实现</p>\n</li>\n<li><p>几乎总是处于可回收状态</p>\n</li>\n<li><p>主要用于在对象被回收时接受一个系统通知或者执行一些清理操作</p>\n</li>\n<li><p>不会访问对象，而是作为对象被回收的一个信号</p>\n</li>\n</ul>\n<h3 id=\"弱-虚区别\"><a href=\"#弱-虚区别\" class=\"headerlink\" title=\"弱&#x2F;虚区别\"></a>弱&#x2F;虚区别</h3><ul>\n<li>弱引用：允许在对象被回收前访问对象</li>\n<li>虚引用：接受对象被回收的通知</li>\n</ul>\n","categories":["八股","Java"],"tags":["Java","面向对象","类","抽象类"]},{"title":"MyBatis","url":"/2024/03/20/MyBatis/","content":"<h1 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h1><h2 id=\"ORM框架\"><a href=\"#ORM框架\" class=\"headerlink\" title=\"ORM框架\"></a>ORM框架</h2><h4 id=\"什么是ORM？\"><a href=\"#什么是ORM？\" class=\"headerlink\" title=\"什么是ORM？\"></a>什么是ORM？</h4><p>Object Relation Manager对象关系映射，负责对象类型与数据库类型之间的映射处理</p>\n<h3 id=\"MyBatis-与-Hibernate的区别\"><a href=\"#MyBatis-与-Hibernate的区别\" class=\"headerlink\" title=\"MyBatis 与 Hibernate的区别\"></a>MyBatis 与 Hibernate的区别</h3><h4 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h4><ul>\n<li>半自动映射框架</li>\n<li>Sql需要自己编写，映射关系需要自己配置</li>\n</ul>\n<h4 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h4><ul>\n<li>全自动映射框架</li>\n<li>Sql需要自己写，映射关系需要自己配置</li>\n</ul>\n<h3 id=\"为什么要使用Mybatis\"><a href=\"#为什么要使用Mybatis\" class=\"headerlink\" title=\"为什么要使用Mybatis?\"></a>为什么要使用Mybatis?</h3><ul>\n<li>Hibernate虽然封装了Sql，简化了开发，但是不能优化sql，如果我们想写一个高级的sql，需要去学HQL语言（Hibernate的操控数据库的语言），增加了开发难度</li>\n<li>Hibernate还是一个全映射框架，假如你只需要查一个字段，他也会查出所有的字段，全部返回给你</li>\n</ul>\n<h2 id=\"MyBatis工作原理\"><a href=\"#MyBatis工作原理\" class=\"headerlink\" title=\"MyBatis工作原理\"></a>MyBatis工作原理</h2><blockquote>\n<p>重要</p>\n</blockquote>\n<ol>\n<li><p>读取全局配置文件 - MyBatis-config.xml</p>\n</li>\n<li><p>加载映射文件 - xxxMapper.xml</p>\n</li>\n<li><p>构造会话工厂 - SqlSessionFactory 负责生成SqlSession对象</p>\n</li>\n<li><p>创建会话对象 - 由SqlSessionFactory创建SqlSession对象，该对象中包含了执行SQL语句的所有方法</p>\n</li>\n<li><p>Executor 执行器</p>\n<blockquote>\n<p>MyBatis定义了一个Executor接口操作数据库，根据SqlSession传递的参数动态地生成需要执行的Sql语句，同时负责查询缓存的维护</p>\n</blockquote>\n</li>\n<li><p>MappedStatement对象</p>\n<blockquote>\n<p>在 <code>Executor</code> 接口的执行方法中有一个 <code>MappedStatement</code> 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息</p>\n</blockquote>\n</li>\n<li><p>输入参数映射</p>\n<blockquote>\n<p>输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 <code>preparedStatement</code> 对象设置参数的过程</p>\n</blockquote>\n</li>\n<li><p>输出参数映射</p>\n<blockquote>\n<p>输出结果类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"全局配置文件\"><a href=\"#全局配置文件\" class=\"headerlink\" title=\"全局配置文件\"></a>全局配置文件</h2><h3 id=\"根元素configuration\"><a href=\"#根元素configuration\" class=\"headerlink\" title=\"根元素configuration\"></a>根元素configuration</h3><h4 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h4><p>加载Properties外部文件配置</p>\n<h4 id=\"settings\"><a href=\"#settings\" class=\"headerlink\" title=\"settings\"></a>settings</h4><blockquote>\n<p>配置Mybatis运行时的行为</p>\n</blockquote>\n<ul>\n<li>CacheEnabled 配置二级缓存是否开启</li>\n<li>lazyLoading 配置是否可以延迟加载</li>\n<li>useColumnLable 使用列标签代替列名</li>\n<li>defaultStatemntTimeOut 默认的会话等待时间</li>\n<li>mapUnderscoreToCamelCase 下划线转为驼峰</li>\n</ul>\n<h4 id=\"typeAliases\"><a href=\"#typeAliases\" class=\"headerlink\" title=\"typeAliases\"></a>typeAliases</h4><ul>\n<li>设置别名</li>\n<li>别名部分大小写</li>\n<li>也能用注解@Alias</li>\n</ul>\n<h4 id=\"typeHandlers\"><a href=\"#typeHandlers\" class=\"headerlink\" title=\"typeHandlers\"></a>typeHandlers</h4><p>处理对象与数据库数据类型之间的映射关系</p>\n<h4 id=\"ObjectFactory\"><a href=\"#ObjectFactory\" class=\"headerlink\" title=\"ObjectFactory\"></a>ObjectFactory</h4><p>对象工厂</p>\n<h4 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h4><p>载入插件，比如拦截调用的一些插件</p>\n<h4 id=\"environments\"><a href=\"#environments\" class=\"headerlink\" title=\"environments\"></a>environments</h4><ul>\n<li>配置数据源<ul>\n<li>UNPOOLED 不使用池</li>\n<li>POOLED 使用池</li>\n<li>JNDI</li>\n</ul>\n</li>\n<li>配置事务<ul>\n<li>使用Spring事务管理，所以这里不需要管</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"databaseIdProvider\"><a href=\"#databaseIdProvider\" class=\"headerlink\" title=\"databaseIdProvider\"></a>databaseIdProvider</h4><p>用来配置不通的数据库</p>\n<h4 id=\"mappers\"><a href=\"#mappers\" class=\"headerlink\" title=\"mappers\"></a>mappers</h4><p>配置映射文件所在的位置</p>\n<h2 id=\"映射文件\"><a href=\"#映射文件\" class=\"headerlink\" title=\"映射文件\"></a>映射文件</h2><h3 id=\"mapper-xml文件\"><a href=\"#mapper-xml文件\" class=\"headerlink\" title=\"mapper.xml文件\"></a>mapper.xml文件</h3><ul>\n<li>insert <ul>\n<li>id</li>\n<li>parameterType 可以省略</li>\n<li>返回值默认有三种integer、long、boolean</li>\n</ul>\n</li>\n<li>update 同上</li>\n<li>delete  同上</li>\n<li>select <ul>\n<li>resultType<ul>\n<li>配置返回数据的类型</li>\n<li>resultType&#x3D;”map”  返回一个key为列名，value为值的一个map对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参数处理\"><a href=\"#参数处理\" class=\"headerlink\" title=\"参数处理\"></a>参数处理</h3><ul>\n<li>对于单个参数，不做特殊处理，直接返回结果</li>\n<li>对于多个参数，需要用@Param配置名称，如果不使用注解，那么需要使用param1、param2来获取</li>\n<li>如果参数很多，和POJO的类型一样，那么直接传POJO即可</li>\n<li>如果很多，也不常用，也可以传Map</li>\n<li>如果很多，经常使用，可以编写TO类</li>\n</ul>\n<h3 id=\"与-的区别\"><a href=\"#与-的区别\" class=\"headerlink\" title=\"#{}与${}的区别\"></a>#{}与${}的区别</h3><ul>\n<li><p>#{}相当于preStatement调用，可以避免Sql注入<br>preparestatement在程序第一次查询数据库之前sql语句就被数据库进行了分析、编译、优化以及具体的查询计划也都形成了，之后参数进来的时候不会被分析处理为指令</p>\n<p>简单来说就是：不让参数参与编译阶段，而是使用占位符代替，从而解决了sql注入问题</p>\n</li>\n<li><p>${}可以用在一些不能使用#{}的时候，比如排序</p>\n</li>\n</ul>\n<h3 id=\"resultmap实现高级映射\"><a href=\"#resultmap实现高级映射\" class=\"headerlink\" title=\"resultmap实现高级映射\"></a>resultmap实现高级映射</h3><ul>\n<li><strong>association</strong><ul>\n<li>实现分步查询</li>\n<li>用在一对一关系</li>\n<li>在此基础上可以实现延迟加载 即只有用到了才会执行这个Sql</li>\n</ul>\n</li>\n<li><strong>collection</strong><ul>\n<li>实现一对多关系映射</li>\n<li>也可以实现延迟加载</li>\n<li>使用ofType属性配置集合中元素的类型</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><blockquote>\n<p>缓存的本质，就是一个map对象</p>\n</blockquote>\n<h3 id=\"Mybatis有两级缓存\"><a href=\"#Mybatis有两级缓存\" class=\"headerlink\" title=\"Mybatis有两级缓存\"></a>Mybatis有两级缓存</h3><h4 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h4><ul>\n<li>属于SqlSession级别的缓存，同一次数据库会话使用同一个SqlSession</li>\n<li>失效的情况，有四种<ul>\n<li>使用两个不同的SqlSession</li>\n<li>使用相同的SqlSession<ul>\n<li>查询条件不同</li>\n<li>清除了缓存</li>\n<li>在两次查询期间执行了增删改操作</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h4><ul>\n<li>属于namespace级别的缓存，即一个mapper文件对应一个二级缓存（比如学生Mapper一个、专业Mapper一个等等）</li>\n<li>当sqlSession提交或者关闭后，它的数据就会存放在二级缓存中</li>\n</ul>\n<h3 id=\"查询顺序\"><a href=\"#查询顺序\" class=\"headerlink\" title=\"查询顺序\"></a>查询顺序</h3><p>先查二级缓存，再查一级缓存，如果一二级缓存都没有命中，查数据库</p>\n<h3 id=\"二级缓存配置cache\"><a href=\"#二级缓存配置cache\" class=\"headerlink\" title=\"二级缓存配置cache\"></a>二级缓存配置cache</h3><h4 id=\"eviction配置回收策略\"><a href=\"#eviction配置回收策略\" class=\"headerlink\" title=\"eviction配置回收策略\"></a>eviction配置回收策略</h4><ul>\n<li>LRU默认</li>\n<li>FIFO</li>\n<li>SOFT 回收软引用</li>\n<li>WEAK 回收弱引用</li>\n</ul>\n<h4 id=\"readOnly\"><a href=\"#readOnly\" class=\"headerlink\" title=\"readOnly\"></a>readOnly</h4><ul>\n<li>true mybatis认为你不会做修改操作，然后每次都会直接返回缓存中的值</li>\n<li>false （默认） mybatis认为你会做修改，所以每次返回都是返回缓存中反序列化克隆后的结果</li>\n</ul>\n<h4 id=\"flushInterval\"><a href=\"#flushInterval\" class=\"headerlink\" title=\"flushInterval\"></a>flushInterval</h4><p>配置多久时间清空一次缓存，默认不清空</p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>我们可以自己实现缓存，实现接口cache，然后将实现类的全限定类名作为type的值即可</p>\n<h2 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"#{}和${}\"></a>#{}和${}</h2><blockquote>\n<p>#{}是预编译处理，是占位符，${}是字符串替换，是拼接符</p>\n</blockquote>\n<ul>\n<li>Mybatis处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement来赋值</li>\n<li>Mybatis在处理${}时，就是把${}替换成变量的值Statement来赋值</li>\n<li>#{}的变量替换是在DBMS中，变量替换后，#{}对应的变量自动加上单引号</li>\n<li>${}的变量替换是在DBMS外，变量替换后，${}对应的变量不会加上单引号</li>\n<li>使用#{}可以有效的防止SQL注入，提高系统安全性<ol>\n<li>占位符会将输入的值视为参数数据而不是SQL代码</li>\n<li>拼接符会当做SQL代码，如果被恶意注入比如输入SELECT * FROM users WHERE username &#x3D; ‘admin’; DROP TABLE users; *–’;<em>，这里的</em>- -*是SQL语句的注释符号，会导致后面的内容被忽略</li>\n</ol>\n</li>\n</ul>\n","categories":["八股","MyBatis"],"tags":["SSM"]},{"title":"MySql","url":"/2024/03/13/MySql/","content":"<h1 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h1><h2 id=\"MySql事务\"><a href=\"#MySql事务\" class=\"headerlink\" title=\"MySql事务\"></a>MySql事务</h2><blockquote>\n<p>事务：可以理解为是一组SQL语句的集合，被当做一个单一的工作单元执行，这些操作要么都成功，要么都失败。</p>\n</blockquote>\n<h3 id=\"事务的四种隔离级别\"><a href=\"#事务的四种隔离级别\" class=\"headerlink\" title=\"事务的四种隔离级别\"></a>事务的四种隔离级别</h3><h4 id=\"读未提交-RU\"><a href=\"#读未提交-RU\" class=\"headerlink\" title=\"读未提交 RU\"></a>读未提交 RU</h4><p>允许读取未提交数据</p>\n<p>有脏读，不可重复读，幻读问题</p>\n<h4 id=\"读已提交-RC\"><a href=\"#读已提交-RC\" class=\"headerlink\" title=\"读已提交 RC\"></a>读已提交 RC</h4><blockquote>\n<p>Oracle 默认</p>\n</blockquote>\n<p>事务中的读操作只能读取到其他事务已经提交的数据。每次读操作都会生成一个新的读取视图，并读取新的行版本，以此避免脏读。</p>\n<p>由于是基于行的快照，所以有幻读，不可重复读问题。</p>\n<h4 id=\"可重复读-RR\"><a href=\"#可重复读-RR\" class=\"headerlink\" title=\"可重复读 RR\"></a>可重复读 RR</h4><blockquote>\n<p>MySql默认</p>\n</blockquote>\n<p>通过多并发版本控制(MVCC)和行级锁实现。事务开始的时候创建一个一致性视图，之后的读取操作都基于这个视图进行，保证了在同一个事务中多次读取的结果一致性，解决了不可重复读的问题。此外，InnoDB存储引擎使用Next-Key Lock来防止幻读的发生，它结合了行锁和间隙锁，锁定了记录本身和记录前面的间隙。</p>\n<p>仍然有幻读问题</p>\n<h4 id=\"串行化Serializable\"><a href=\"#串行化Serializable\" class=\"headerlink\" title=\"串行化Serializable\"></a>串行化Serializable</h4><p>没有问题</p>\n<h3 id=\"三种问题\"><a href=\"#三种问题\" class=\"headerlink\" title=\"三种问题\"></a>三种问题</h3><h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p>脏读是指一个事务读取到了另一个事务尚未提交的数据变更。如果那个事务最终回滚，那么读取到的数据将是无效的。脏读通常在最低的隔离级别（如读未提交 Read Uncommitted）下可能发生。</p>\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p>不可重复读是指在一个事务执行过程中，多次读取同一数据集合时，由于其他事务的介入，后续读取的结果与前面的读取结果不一致。这通常是由于其他事务在这两次读取之间更新了数据。</p>\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p>幻读是指在一个事务执行过程中，多次执行相同的查询，由于其他事务插入或删除了符合查询条件的数据，导致后续的查询结果包含了之前不存在的记录（幻影行）。幻读通常发生在可重复读（Repeatable Read）或更高的隔离级别下。</p>\n<p><strong>不可重复读和幻读区别通俗理解为：</strong>前者是数据变了，后者是数据的行数变了。</p>\n<h3 id=\"隐式提交\"><a href=\"#隐式提交\" class=\"headerlink\" title=\"隐式提交\"></a>隐式提交</h3><blockquote>\n<p>没有使用指令</p>\n</blockquote>\n<ul>\n<li>执行了DDL语句：create、drop、alter</li>\n<li>开启了一个新的事务</li>\n<li>使用了锁</li>\n<li>使用了加载操作</li>\n</ul>\n<h3 id=\"事务四大特性\"><a href=\"#事务四大特性\" class=\"headerlink\" title=\"事务四大特性\"></a>事务四大特性</h3><h4 id=\"A原子性\"><a href=\"#A原子性\" class=\"headerlink\" title=\"A原子性\"></a>A原子性</h4><blockquote>\n<p>即事务要么都成功，要么都失败</p>\n</blockquote>\n<ul>\n<li><p>通过undo log实现的</p>\n<p>undo log其实记录的是一个链表，链首为最新更改数据的信息，链尾为最早更改数据的信息（信息中其实就是改行所以的字段，通过不可见字段trx_id标记事务的id）</p>\n</li>\n<li><p>undo log会配合每一行记录的隐藏字段 row_ptr回滚指针实现回滚</p>\n</li>\n</ul>\n<h4 id=\"C一致性\"><a href=\"#C一致性\" class=\"headerlink\" title=\"C一致性\"></a>C一致性</h4><blockquote>\n<p>事务执行前后，数据库的完整性约束不会发生变化</p>\n</blockquote>\n<h4 id=\"I隔离性\"><a href=\"#I隔离性\" class=\"headerlink\" title=\"I隔离性\"></a>I隔离性</h4><blockquote>\n<p>事务之间相互隔离</p>\n</blockquote>\n<h4 id=\"D持久性\"><a href=\"#D持久性\" class=\"headerlink\" title=\"D持久性\"></a>D持久性</h4><blockquote>\n<p>通过redo log 两阶段提交，保证crash safe</p>\n</blockquote>\n<h5 id=\"MVCC实现（MVCC多版本并发控制）\"><a href=\"#MVCC实现（MVCC多版本并发控制）\" class=\"headerlink\" title=\"MVCC实现（MVCC多版本并发控制）\"></a>MVCC实现（MVCC多版本并发控制）</h5><ul>\n<li><p>制定了关于快照读和当前读的相关内容</p>\n<ul>\n<li><p>当前读：比如update、insert、delete以及加锁的select语句都会修改当前读</p>\n</li>\n<li><p>快照读：select语句读取的是快照读<br>快照什么时候建立？</p>\n<p>RC级别 每次快照读，都会建立新的快照<br>RR级别 第一次需要快照读的时候建立，之后会使用第一次的快照读</p>\n</li>\n</ul>\n</li>\n<li><p>如何判断一个事务A能否看见B事务的值？</p>\n<ul>\n<li><p>A事务自己的操作自己能看到</p>\n</li>\n<li><p>如果B事务没有提交看不到</p>\n</li>\n<li><p>如果B事务提交了</p>\n<ul>\n<li>如果A事务快照建立在B事务提交之前，看不到</li>\n<li>如果A事务快照建立在B事务提交之后，能看到</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySql锁\"><a href=\"#MySql锁\" class=\"headerlink\" title=\"MySql锁\"></a>MySql锁</h2><h3 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h3><blockquote>\n<p> FTWRL</p>\n<p> 命令 flush table with read lock</p>\n</blockquote>\n<ul>\n<li>给库做备份的时候用，为了哪些没有事务的存储引擎使用</li>\n<li>给库做备份也可以用Innodb开启一个事务进行备份</li>\n</ul>\n<h3 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h3><h4 id=\"表锁-1\"><a href=\"#表锁-1\" class=\"headerlink\" title=\"表锁\"></a>表锁</h4><ul>\n<li>对于没有索引的遍历，都会加表锁</li>\n<li>加锁：Lock Table</li>\n<li>解锁：Unlock Table</li>\n</ul>\n<h4 id=\"元数据锁\"><a href=\"#元数据锁\" class=\"headerlink\" title=\"元数据锁\"></a>元数据锁</h4><ul>\n<li>更改表结构的时候会自动加元数据锁</li>\n<li>加元数据锁会阻碍之后的所有操作，因此给表加字段最好加一个超时时间</li>\n</ul>\n<h4 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h4><blockquote>\n<p>为了使行锁和表锁共存（多粒度锁机制）</p>\n</blockquote>\n<ul>\n<li>加锁之前必须获取意向锁</li>\n<li>可以减小加表锁时，还需要去遍历判断是不是有行锁的开销</li>\n<li>意向共享锁IS<br>共享锁允许多个事务读取同一数据项，但不允许任何事务修改它。当事务想要在某个数据项上加共享锁时，它首先必须在该数据项上设置一个意向共享锁。这个锁告诉其他事务，有一个事务正在尝试读取这个数据项。</li>\n<li>意向排它锁IX<br>排他锁允许事务对数据项进行读取和修改，但不允许其他事务读取或修改同一个数据项。当事务想要在某个数据项上加排他锁时，它首先必须在该数据项上设置一个意向排他锁。这个锁告诉其他事务，有一个事务正在尝试修改这个数据项。</li>\n</ul>\n<h3 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h3><h4 id=\"加锁时机\"><a href=\"#加锁时机\" class=\"headerlink\" title=\"加锁时机\"></a>加锁时机</h4><blockquote>\n<p>原理 给索引加锁，因此如果有另外一个SQL在遍历时使用了该索引，那么也会进入阻塞</p>\n</blockquote>\n<p>行锁在需要的时候会自动加上，但是不需要的时候不会立即释放，只有事务提交了才会释放行锁</p>\n<h4 id=\"两种锁实现\"><a href=\"#两种锁实现\" class=\"headerlink\" title=\"两种锁实现\"></a>两种锁实现</h4><h5 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a>共享锁</h5><p>select in share mode</p>\n<h5 id=\"排它锁\"><a href=\"#排它锁\" class=\"headerlink\" title=\"排它锁\"></a>排它锁</h5><p>select..for update<br>update、insert、delete语句自动加排他锁</p>\n<p>加行锁之前都得先去获得意向锁</p>\n<h3 id=\"间隙锁\"><a href=\"#间隙锁\" class=\"headerlink\" title=\"间隙锁\"></a>间隙锁</h3><blockquote>\n<p>解决幻读问题<br>当查询的是一个范围的时候，Innodb会给所有关联内的数据加锁，就是所谓间隙锁</p>\n</blockquote>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>给一个范围加了一把锁，导致其他事务不能去操作，也就解决了幻读</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><blockquote>\n<p>如果两个事务，执行过程中分别拿了对面的锁，那么就会死锁</p>\n</blockquote>\n<h4 id=\"怎么解决？\"><a href=\"#怎么解决？\" class=\"headerlink\" title=\"怎么解决？\"></a>怎么解决？</h4><ul>\n<li>可以设定一个超时时间</li>\n<li>主动发起死锁检测，死锁后，主动回滚其中的一条事务，就可以解决（这也是Mysql的默认方式）</li>\n<li>最好的办法是从设计上解决，可以控制并发量；可以将共享的数据多分几行，然后获取总数时加起来；</li>\n</ul>\n<h2 id=\"MySql主从复制\"><a href=\"#MySql主从复制\" class=\"headerlink\" title=\"MySql主从复制\"></a>MySql主从复制</h2><h3 id=\"为什么要建立主从模型？\"><a href=\"#为什么要建立主从模型？\" class=\"headerlink\" title=\"为什么要建立主从模型？\"></a>为什么要建立主从模型？</h3><p>mysql是一个小型数据库，为了解决mysql小的问题，可以建立mysql集群，保证高并发下的稳定性</p>\n<h3 id=\"主从复制过程\"><a href=\"#主从复制过程\" class=\"headerlink\" title=\"主从复制过程\"></a>主从复制过程</h3><h4 id=\"mysql5-6之前\"><a href=\"#mysql5-6之前\" class=\"headerlink\" title=\"mysql5.6之前\"></a>mysql5.6之前</h4><h5 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h5><ol>\n<li>主库将数据写入bin log中</li>\n<li>从库有IO线程网络读取bin log日志</li>\n<li>IO会将读取的数据存放在relay log内</li>\n<li>另一个线程SQL log会去执行relay log的数据，实现主从复制</li>\n</ol>\n<h5 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h5><p>主要就是复制过程太慢，主从延迟严重，主要就是因为第四步影响了复制的速度（因为这个过程是读数据往磁盘写，而操作磁盘是最慢的操作）</p>\n<h4 id=\"mysql5-6\"><a href=\"#mysql5-6\" class=\"headerlink\" title=\"mysql5.6\"></a>mysql5.6</h4><blockquote>\n<p>实现了并行复制</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240315174255724.png\" alt=\"image-20240315174255724\"></p>\n<p>引入了协调者线程Coordinator，负责将不同库的信息分线程去执行，增快速度</p>\n<h5 id=\"存在的问题-1\"><a href=\"#存在的问题-1\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h5><p>分的粒度太粗，是库级别的，其实性能并没有提高很多</p>\n<h4 id=\"mysql5-7\"><a href=\"#mysql5-7\" class=\"headerlink\" title=\"mysql5.7\"></a>mysql5.7</h4><blockquote>\n<p>真正实现了并行复制，解决了主从复制的延迟问题</p>\n</blockquote>\n<h5 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h5><p><strong>组提交</strong>：</p>\n<ul>\n<li>每个日志都有一个序列号 LSN，这个值单调递增，一段很短的时间内，可能有多个事务，比如100,120,150，提交时将LSN&lt;150的一起提交</li>\n<li>当事务同时提交时，它们将在单个操作中写入到二进制日志中。 如果事务能同时提交成功，那么它们就不会共享任何锁，这意味着它们没有冲突，因此可以在 Slave 上并行执行。所以通过在主机上的二进制日志中添加组提交信息，这些 Slave 可以并行地安全地运行事务。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"遇到慢查询怎么处理？\"><a href=\"#遇到慢查询怎么处理？\" class=\"headerlink\" title=\"遇到慢查询怎么处理？\"></a>遇到慢查询怎么处理？</h3><ol>\n<li>重复运行几次，看看是不是每次都这么慢<br>如果不是每次都慢，说明慢的那一次是在刷脏页</li>\n<li>看是不是没索引</li>\n<li>看索引是不是用错了<br>用错了？<ul>\n<li>1、analyze table 表名 重新计算统计信息，说不定能用对索引</li>\n<li>2、新建一个索引</li>\n<li>3、force index强制使用一个索引</li>\n</ul>\n</li>\n<li>如果还慢，就要看慢查询日志，查看具体慢的原因了</li>\n</ol>\n<h3 id=\"如何选择字段建立索引？\"><a href=\"#如何选择字段建立索引？\" class=\"headerlink\" title=\"如何选择字段建立索引？\"></a>如何选择字段建立索引？</h3><ol>\n<li>小于2000行的表无需建立索引</li>\n<li>选择基数大的（区分度大的）作为索引，可以用show index查看</li>\n<li>优先用普通索引，可以利用changebuffer，将随机读变为顺序读</li>\n<li>不要选择太长的字段，因为每个辅助索引都会记录聚簇索引的值</li>\n</ol>\n<h3 id=\"什么时候刷脏页？\"><a href=\"#什么时候刷脏页？\" class=\"headerlink\" title=\"什么时候刷脏页？\"></a>什么时候刷脏页？</h3><ol>\n<li>redo log日志写满了，如果继续写会覆盖之前的内容，所以需要把之前的脏页写回磁盘</li>\n<li>Mysql当前很忙，请求很多，导致需要频繁的置换页面，当置换脏页的时候，就得写磁盘</li>\n<li>Mysql很闲的时候，判断当前很闲，就会刷脏页</li>\n<li>Mysql关闭的时候，需要把所有脏页写回磁盘</li>\n</ol>\n<h3 id=\"行记录的不可见的字段\"><a href=\"#行记录的不可见的字段\" class=\"headerlink\" title=\"行记录的不可见的字段\"></a>行记录的不可见的字段</h3><ol>\n<li>row_ptr：回滚指针，与undo log配合实现回滚操作</li>\n<li>row_id：隐藏主键，如果你没有设定主键，那么会选择唯一键当主键，如果没有唯一键，就会创建一个6字节的隐藏字段row_id作为主键</li>\n<li>trx_id：修改当前记录的事务的id号</li>\n</ol>\n<h3 id=\"如何存储emoji表情？\"><a href=\"#如何存储emoji表情？\" class=\"headerlink\" title=\"如何存储emoji表情？\"></a>如何存储emoji表情？</h3><p>使用utf-8mb4而不是utf-8，否则会乱码</p>\n<h3 id=\"行记录的不可见的字段-1\"><a href=\"#行记录的不可见的字段-1\" class=\"headerlink\" title=\"行记录的不可见的字段\"></a>行记录的不可见的字段</h3><ol>\n<li>row_ptr：回滚指针，与undo log配合实现回滚操作</li>\n<li>row_id：隐藏主键，如果你没有设定主键，那么会选择唯一键当主键，如果没有唯一键，就会创建一个6字节的隐藏字段row_id作为主键</li>\n<li>trx_id：修改当前记录的事务的id号</li>\n</ol>\n<h3 id=\"如何存储emoji表情？-1\"><a href=\"#如何存储emoji表情？-1\" class=\"headerlink\" title=\"如何存储emoji表情？\"></a>如何存储emoji表情？</h3><p>使用utf-8mb4而不是utf-8，否则会乱码</p>\n<h3 id=\"自增ID用完了会发生什么？\"><a href=\"#自增ID用完了会发生什么？\" class=\"headerlink\" title=\"自增ID用完了会发生什么？\"></a>自增ID用完了会发生什么？</h3><ol>\n<li>自己设置的非空唯一主键，如果用完了，mysql会报错</li>\n<li>如果是row_id，就会覆盖掉原本的数据</li>\n</ol>\n<h3 id=\"怎么解决自增ID用完了？\"><a href=\"#怎么解决自增ID用完了？\" class=\"headerlink\" title=\"怎么解决自增ID用完了？\"></a>怎么解决自增ID用完了？</h3><ol>\n<li>换一个索引，比方说换到邮戳类型</li>\n<li>使用bigInteger存</li>\n<li>建立联合索引，用主键和其他字段建立联合索引</li>\n<li>使用UUID或是SnowFlake</li>\n</ol>\n<h2 id=\"数据库概念\"><a href=\"#数据库概念\" class=\"headerlink\" title=\"数据库概念\"></a>数据库概念</h2><h3 id=\"码\"><a href=\"#码\" class=\"headerlink\" title=\"码\"></a>码</h3><h4 id=\"候选码\"><a href=\"#候选码\" class=\"headerlink\" title=\"候选码\"></a>候选码</h4><p>能唯一标识一个元组，而其子集不能</p>\n<h4 id=\"主属性\"><a href=\"#主属性\" class=\"headerlink\" title=\"主属性\"></a>主属性</h4><p>候选码的属性为主属性</p>\n<h4 id=\"非主属性\"><a href=\"#非主属性\" class=\"headerlink\" title=\"非主属性\"></a>非主属性</h4><p>不是主属性就是非主属性</p>\n<h3 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h3><h4 id=\"什么是依赖？\"><a href=\"#什么是依赖？\" class=\"headerlink\" title=\"什么是依赖？\"></a>什么是依赖？</h4><p>一个x可以唯一确定一个y，x -&gt;y， 就称y依赖于x</p>\n<h4 id=\"部分依赖\"><a href=\"#部分依赖\" class=\"headerlink\" title=\"部分依赖\"></a>部分依赖</h4><p>假如x -&gt; y，而且x的一个真子集x’ -&gt; y，此时称为部分依赖</p>\n<h4 id=\"完全依赖\"><a href=\"#完全依赖\" class=\"headerlink\" title=\"完全依赖\"></a>完全依赖</h4><p>假如x -&gt; y，而且x的任何一个真子集都不存在x’-&gt;y，此时就成为完全依赖</p>\n<h4 id=\"传递依赖\"><a href=\"#传递依赖\" class=\"headerlink\" title=\"传递依赖\"></a>传递依赖</h4><p>假如x-&gt;y，y-&#x2F;-&gt;x，y-&gt;z，就有x-&gt;z，则称z对x传递依赖</p>\n<h3 id=\"数据库范式\"><a href=\"#数据库范式\" class=\"headerlink\" title=\"数据库范式\"></a>数据库范式</h3><h4 id=\"第一范式\"><a href=\"#第一范式\" class=\"headerlink\" title=\"第一范式\"></a>第一范式</h4><p>列不可拆分，列是原子列</p>\n<h4 id=\"第二范式\"><a href=\"#第二范式\" class=\"headerlink\" title=\"第二范式\"></a>第二范式</h4><p>在第一范式的基础上消除了非主属性对键的部分依赖</p>\n<h4 id=\"第三范式\"><a href=\"#第三范式\" class=\"headerlink\" title=\"第三范式\"></a>第三范式</h4><p>在第二范式基础上消除了非主属性对键的传递函数依赖</p>\n<h4 id=\"BC范式\"><a href=\"#BC范式\" class=\"headerlink\" title=\"BC范式\"></a>BC范式</h4><p>在第三范式基础上，消除了主属性对键的部分</p>\n<h2 id=\"MySQL架构\"><a href=\"#MySQL架构\" class=\"headerlink\" title=\"MySQL架构\"></a>MySQL架构</h2><p><img data-src=\"https://img.jyhmw.cn/image-20240313213004762.png\" alt=\"image-20240313213004762\"></p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><h3 id=\"Server层\"><a href=\"#Server层\" class=\"headerlink\" title=\"Server层\"></a>Server层</h3><h4 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h4><ul>\n<li>与客户端连接</li>\n<li>验证权限</li>\n</ul>\n<h4 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h4><ul>\n<li>将查询结果存放至查询缓存</li>\n<li>很容易过期，在最新版本mysql已经去除查询缓存</li>\n<li>适合存放长期不会改变的数据</li>\n</ul>\n<h4 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h4><p>分析sql语句、是否有语病</p>\n<h4 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h4><ul>\n<li>生成执行计划<ul>\n<li>决定用什么索引</li>\n<li>决定join时表的连接方式</li>\n</ul>\n</li>\n<li>优化Sql语句</li>\n</ul>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>操作存储引擎</p>\n<h3 id=\"存储引擎层\"><a href=\"#存储引擎层\" class=\"headerlink\" title=\"存储引擎层\"></a>存储引擎层</h3><h4 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h4><ul>\n<li>B+树结构辅助索引存放主索引的地址</li>\n<li>只有表锁</li>\n<li>O(1)级别count</li>\n</ul>\n<h4 id=\"Innodb\"><a href=\"#Innodb\" class=\"headerlink\" title=\"Innodb\"></a>Innodb</h4><ul>\n<li>支持外键</li>\n<li>支持事务</li>\n<li>B+树结构辅助索引存放主索引的值</li>\n<li>引入了行锁</li>\n<li>Innodb三大特性<ul>\n<li>插入缓冲：<ul>\n<li>优化了普通索引，引入了change buffer</li>\n<li>先判断插入的普通索引页是否存在缓冲池中，如果在就可以直接插入，如果不在就先放到change buffer中，然后进行change buffer 和普通索引的合并操作，可以将多个插入合并到一个操作中，提高普通索引的插入性能</li>\n</ul>\n</li>\n<li>两次写：防止实例宕机时，innoDB发生数据页部分写的问题</li>\n<li>自适应哈希：innoDB有一个机制可以监控索引的搜索，如果innoDB注意到查询可以通过建立索引得到优化就会自动完成这件事</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>MyISAM</th>\n<th>Innodb</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>外键</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>事务</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>行表锁</td>\n<td>表锁，即使操作一条数据也会锁住整个表</td>\n<td>行锁，操作时可以只锁住某一行；适合高并发</td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>只缓存索引，不缓存真实数据</td>\n<td>不仅缓存索引，还会缓存真实数据；对内存要求高</td>\n</tr>\n<tr>\n<td>表空间</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>关注点</td>\n<td>性能</td>\n<td>事务</td>\n</tr>\n</tbody></table>\n<h4 id=\"memcache\"><a href=\"#memcache\" class=\"headerlink\" title=\"memcache\"></a>memcache</h4><p>存储结构为HashMap</p>\n<h2 id=\"MySQL基本操作\"><a href=\"#MySQL基本操作\" class=\"headerlink\" title=\"MySQL基本操作\"></a>MySQL基本操作</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li># 注释内容</li>\n<li>- - 注释内容</li>\n</ul>\n<h3 id=\"DDL\"><a href=\"#DDL\" class=\"headerlink\" title=\"DDL\"></a>DDL</h3><blockquote>\n<p>数据定义语言，用来创建数据库</p>\n</blockquote>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><h5 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h5><ul>\n<li><p>操作库</p>\n<ul>\n<li><p>create database 库名</p>\n</li>\n<li><p>create database if not exists 库名</p>\n<p>create database 库名 character set utf8</p>\n</li>\n</ul>\n</li>\n<li><p>操作表</p>\n<ul>\n<li>create table 表名(列名1 数据类型1, 列名2 数据类型2…)</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"alter\"><a href=\"#alter\" class=\"headerlink\" title=\"alter\"></a>alter</h5><ul>\n<li>基本语法 alter database 库名称 character set utf8</li>\n</ul>\n<h5 id=\"drop\"><a href=\"#drop\" class=\"headerlink\" title=\"drop\"></a>drop</h5><ul>\n<li>操作库 drop database 库名</li>\n<li>操作表 drop table 库名</li>\n</ul>\n<h3 id=\"DML\"><a href=\"#DML\" class=\"headerlink\" title=\"DML\"></a>DML</h3><blockquote>\n<p>数据操作语言</p>\n</blockquote>\n<h4 id=\"关键字-1\"><a href=\"#关键字-1\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><h5 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h5><p>insert into 表名(列名1, 列名2, …, 列名n) values (值1, 值2, 值n)</p>\n<h5 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h5><ul>\n<li>delete drop truncat的区别<ul>\n<li>delete 不加where条件删除所有数据，会保留自增主键，速度较慢</li>\n<li>drop 删除所有数据会将表结构也一起删除</li>\n<li>truncate 如果要删除表的所有数据使用此命令，速度很快 自增主键会被重置</li>\n</ul>\n</li>\n<li>delete from 表 where条件</li>\n</ul>\n<h5 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h5><p>update表名 set 列名1&#x3D;值1，列名2&#x3D;值2 where条件</p>\n<h3 id=\"DCL\"><a href=\"#DCL\" class=\"headerlink\" title=\"DCL\"></a>DCL</h3><blockquote>\n<p>数据控制语言</p>\n</blockquote>\n<h4 id=\"关键字-2\"><a href=\"#关键字-2\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><h5 id=\"grant\"><a href=\"#grant\" class=\"headerlink\" title=\"grant\"></a>grant</h5><h5 id=\"revoke\"><a href=\"#revoke\" class=\"headerlink\" title=\"revoke\"></a>revoke</h5><h3 id=\"DQL-☆\"><a href=\"#DQL-☆\" class=\"headerlink\" title=\"DQL ☆\"></a>DQL ☆</h3><blockquote>\n<p>数据查询语言</p>\n<p>select</p>\n</blockquote>\n<h4 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><p>select 字段 from 表 where 条件 group by 字段 having 条件 order by 条件 limit 几个</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><h5 id=\"查询不要使用\"><a href=\"#查询不要使用\" class=\"headerlink\" title=\"查询不要使用*\"></a>查询不要使用*</h5><p>会增加分析器解析成本，无用的字段会增加网络消耗</p>\n<h5 id=\"DISTINCT\"><a href=\"#DISTINCT\" class=\"headerlink\" title=\"DISTINCT\"></a>DISTINCT</h5><ul>\n<li>select distinct 字段 from表</li>\n<li>去除重复数据</li>\n<li>如果有多个null值，不会合并为一个</li>\n<li>如果有多个字段，只有所有的字段都相同才会去重（不是标在谁前面就去重谁）</li>\n</ul>\n<h5 id=\"AS\"><a href=\"#AS\" class=\"headerlink\" title=\"AS\"></a>AS</h5><p>给字段加别名</p>\n<h4 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h4><h5 id=\"大小运算符\"><a href=\"#大小运算符\" class=\"headerlink\" title=\"大小运算符\"></a>大小运算符</h5><ul>\n<li>&gt; &gt;&#x3D;</li>\n<li>&lt; &lt;&#x3D;</li>\n<li>&lt;&gt; !&#x3D;</li>\n</ul>\n<h5 id=\"范围查询\"><a href=\"#范围查询\" class=\"headerlink\" title=\"范围查询\"></a>范围查询</h5><ul>\n<li>between A and B 闭区间 相当于 &gt;&#x3D; &amp;&amp; &lt;&#x3D;</li>\n<li>IN(A, B, C) 多个or并列使用</li>\n</ul>\n<h5 id=\"逻辑判断\"><a href=\"#逻辑判断\" class=\"headerlink\" title=\"逻辑判断\"></a>逻辑判断</h5><ul>\n<li>and &amp;&amp;</li>\n<li>or ||</li>\n<li>not !</li>\n</ul>\n<h5 id=\"是否为null\"><a href=\"#是否为null\" class=\"headerlink\" title=\"是否为null\"></a>是否为null</h5><p>IS NULL 判断是不是null最正确的方式</p>\n<h5 id=\"模糊查询-like\"><a href=\"#模糊查询-like\" class=\"headerlink\" title=\"模糊查询 like\"></a>模糊查询 like</h5><ul>\n<li>使用通配符 <ul>\n<li>% 匹配0个或者多个 <ul>\n<li>不会匹配null</li>\n<li>不要用在开头，这样不会用索引，影响性能</li>\n</ul>\n</li>\n<li>_匹配1个</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"group-by\"><a href=\"#group-by\" class=\"headerlink\" title=\"group by\"></a>group by</h4><ul>\n<li>分组之后查询的字段必须是该分组字段或者聚合函数</li>\n<li>HAVING<ul>\n<li>分组后增加判断条件</li>\n<li>having 与 where的区别<ul>\n<li>where是在分组前进行筛选；having在分组后筛选</li>\n<li>where不能使用聚集函数，having可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"order-by\"><a href=\"#order-by\" class=\"headerlink\" title=\"order by\"></a>order by</h4><blockquote>\n<p>ASC升序；DESC降序 默认是升序</p>\n</blockquote>\n<h5 id=\"可以接多个字段进行排序\"><a href=\"#可以接多个字段进行排序\" class=\"headerlink\" title=\"可以接多个字段进行排序\"></a>可以接多个字段进行排序</h5><p>select id, price, name, from product order by price, name</p>\n<p><em>表示先按price排序，再按name排序</em></p>\n<p><em>这条语句会选择<code>product</code>表中的<code>id</code>、<code>price</code>和<code>name</code>列，并且首先根据<code>price</code>列进行排序，如果<code>price</code>相同，则根据<code>name</code>列进行次级排序。这意味着，你会得到一个结果集，其中的记录首先是按照<code>price</code>升序排列的（如果没有指定<code>ASC</code>或<code>DESC</code>，默认为升序），如果<code>price</code>相同，则这些记录会进一步按照<code>name</code>升序排列。</em></p>\n<h5 id=\"升序降序一起使用\"><a href=\"#升序降序一起使用\" class=\"headerlink\" title=\"升序降序一起使用\"></a>升序降序一起使用</h5><p>select id, price, name from product order by price DESC, name</p>\n<p><em>表示按price逆序，再按name升序 前面主要 后面次要</em>  </p>\n<h5 id=\"排序默认不区分大小写，但是可以设置\"><a href=\"#排序默认不区分大小写，但是可以设置\" class=\"headerlink\" title=\"排序默认不区分大小写，但是可以设置\"></a>排序默认不区分大小写，但是可以设置</h5><h5 id=\"排序详解\"><a href=\"#排序详解\" class=\"headerlink\" title=\"排序详解\"></a>排序详解</h5><blockquote>\n<p>MySql 会分配一个内存 排序 叫做 sort buffer ，但整个排序过程不一定在sort buffer 中执行，如果大小不足会在外存进行排序（归并排序，生成多个文件进行排序）</p>\n</blockquote>\n<h6 id=\"order-by-两种排序方式\"><a href=\"#order-by-两种排序方式\" class=\"headerlink\" title=\"order by 两种排序方式\"></a>order by 两种排序方式</h6><ul>\n<li>全字段排序 <ul>\n<li>将所有字段读入sort_buffer</li>\n<li>按指定字段排序</li>\n<li>返回结果</li>\n</ul>\n</li>\n<li>rowId排序（如果排序的字段内容单行长度就很大）<ul>\n<li>将row_id与指定字段读入 sort buffer</li>\n<li>按照指定字段排序，得到排序后的row_id</li>\n<li>用row_id读取数据返回</li>\n</ul>\n</li>\n</ul>\n<p><em>区别在于rowid会读取两次数据，比全字段排序慢一点</em></p>\n<h4 id=\"limit\"><a href=\"#limit\" class=\"headerlink\" title=\"limit\"></a>limit</h4><blockquote>\n<p>limit m, n</p>\n</blockquote>\n<ul>\n<li>m从第几行开始 默认从0开始， n表示读几行</li>\n<li>limit 10 从第一行开始读10行</li>\n<li>limit 10, 10 从11行开始读10行</li>\n<li>limit(pageNum - 1) * pageSize, pageSize 实现分页</li>\n</ul>\n<h3 id=\"聚集函数\"><a href=\"#聚集函数\" class=\"headerlink\" title=\"聚集函数\"></a>聚集函数</h3><h4 id=\"count相关\"><a href=\"#count相关\" class=\"headerlink\" title=\"count相关\"></a>count相关</h4><ul>\n<li>对于MyISAM引擎，总数就是一个表的字段，所以MyISAM返回count(*)非常快</li>\n<li>但是Innodb没有这个字段，就得遍历表，挨个搜<ul>\n<li>为什么Innodb不设置这个字段？<br>是因为Innodb支持了事务，如果有这个字段，那么多个事务增删完数据就得更改这个共享的字段，实现又得加锁，很复杂</li>\n<li>为什么不用统计信息table_rows那个字段？<br>只是个估计值</li>\n</ul>\n</li>\n<li>Mysql对Count(<em>)的优化<br>mysql在执行count(</em>)这个语句的时候，mysql会去找这个表最小的索引树去遍历</li>\n<li>count()统计null吗？<ul>\n<li>如果为count(*)或count(1)  会统计null</li>\n<li>如果为count(列)                      不会统计null</li>\n</ul>\n</li>\n<li>count之间的速度排序<ul>\n<li>count(*) &#x3D;&#x3D; count(1) &gt; count(主键) &gt; count(列)</li>\n</ul>\n</li>\n<li>表越来越大，count()的速度会越来越慢，如何解决？<br>自己计数 使用 Redis 存放表的数量信息</li>\n</ul>\n<h3 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h3><ul>\n<li>union <ul>\n<li>左右表的个数需要一致</li>\n<li>相同的字段会合并</li>\n</ul>\n</li>\n<li>inner join（只写join和这个一样）<br>理解为“有效连接”，两张表中都有的数据才会显示</li>\n<li>left join 理解为“有左显示”，比如on a.field&#x3D;b.field，则显示a表中存在的全部数据及a、b中都有的数据，a中有、b中没有的数据以null显示</li>\n<li>right join 理解为“有右显示”，比如on a.field&#x3D;b.field，则显示b表中存在的全部数据及a、b中都有的数据，b中有、a中没有的数据以null显示</li>\n<li>full join 返回两个表中的行：left join + right join（重合部分的相等数据只保留一份）</li>\n<li>cross join 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li>\n<li>使用on和where的区别<ul>\n<li>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户</li>\n<li>on决定了这张临时表的生成</li>\n<li>where是在临时表生成后才去筛选过滤</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySql数据类型\"><a href=\"#MySql数据类型\" class=\"headerlink\" title=\"MySql数据类型\"></a>MySql数据类型</h2><h3 id=\"char与varchar\"><a href=\"#char与varchar\" class=\"headerlink\" title=\"char与varchar\"></a>char与varchar</h3><h4 id=\"char不可变字符串\"><a href=\"#char不可变字符串\" class=\"headerlink\" title=\"char不可变字符串\"></a>char不可变字符串</h4><p>char(10)就分配10个字符的空间，小于10个字符就会自动填充空格</p>\n<h4 id=\"varchar可变字符串\"><a href=\"#varchar可变字符串\" class=\"headerlink\" title=\"varchar可变字符串\"></a>varchar可变字符串</h4><p>varchar(10)表示最大为10个字符，实际占用的字符为实际长度(实际会多一个字节来标识长度)</p>\n<h3 id=\"utf8与utf8mb4\"><a href=\"#utf8与utf8mb4\" class=\"headerlink\" title=\"utf8与utf8mb4\"></a>utf8与utf8mb4</h3><ul>\n<li>mysql中的utf8并不是实际上的utf8</li>\n<li>如果要存储emoji就得使用utf8mb4</li>\n<li>utf8mb4才是真正使用四字节存储的数据库</li>\n</ul>\n<h3 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h3><blockquote>\n<p>DateTime与TimeStamp的区别</p>\n</blockquote>\n<h4 id=\"时间范围\"><a href=\"#时间范围\" class=\"headerlink\" title=\"时间范围\"></a>时间范围</h4><ul>\n<li>DateTime没有时间范围</li>\n<li>TimeStamp有时间范围1970-2038年<ul>\n<li>到了2038年 mysql迁移到64bit 使用 datetime类型</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"时区问题\"><a href=\"#时区问题\" class=\"headerlink\" title=\"时区问题\"></a>时区问题</h4><ul>\n<li>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；</li>\n<li>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</li>\n</ul>\n<h2 id=\"MySql索引\"><a href=\"#MySql索引\" class=\"headerlink\" title=\"MySql索引\"></a>MySql索引</h2><h3 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h3><blockquote>\n<p>B+树</p>\n</blockquote>\n<h4 id=\"为什么使用B-树？\"><a href=\"#为什么使用B-树？\" class=\"headerlink\" title=\"为什么使用B+树？\"></a>为什么使用B+树？</h4><p><strong>有一个发展过程</strong></p>\n<ul>\n<li>最开始使用HashMap存储<ul>\n<li>HashMap必须一次性全部放入内存</li>\n<li>HashMap存在哈希碰撞问题，严重会使查询效率下降</li>\n<li>HashMap不支持范围查询</li>\n</ul>\n</li>\n<li>然后使用二叉树<ul>\n<li>BST 树 不能保证平衡</li>\n<li>AVL 树 虽然实现了平衡，但是增删的速度优点慢</li>\n<li>红黑树 平衡了增删与查询，但是存在一个问题，就是树高会很高</li>\n</ul>\n</li>\n<li>多叉树<ul>\n<li>B树      索引与数据存放在同一数据块中，这样会使树很高</li>\n<li>B+树   引入内部结点与外部节点，内部结点全部存放索引，外部节点全部存放数据</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"B树相对B-树的优势\"><a href=\"#B树相对B-树的优势\" class=\"headerlink\" title=\"B树相对B+树的优势\"></a>B树相对B+树的优势</h4><ul>\n<li>B树相较于B+树更适合小数据量</li>\n<li>B树的某些优化，可以让查询频率高的数据更靠近根节点，从而优化的更快。而B+树必须要遍历到叶子结点</li>\n</ul>\n<h3 id=\"两种存储引擎存放的结构\"><a href=\"#两种存储引擎存放的结构\" class=\"headerlink\" title=\"两种存储引擎存放的结构\"></a>两种存储引擎存放的结构</h3><h4 id=\"MyISAM索引\"><a href=\"#MyISAM索引\" class=\"headerlink\" title=\"MyISAM索引\"></a>MyISAM索引</h4><p>辅助索引的叶子结点存放的是聚集索引的地址</p>\n<h4 id=\"Innodb索引\"><a href=\"#Innodb索引\" class=\"headerlink\" title=\"Innodb索引\"></a>Innodb索引</h4><p>辅助索引的叶子结点存放的是聚集索引的值</p>\n<blockquote>\n<p>所以我们选择主索引一定要选那些短的索引</p>\n</blockquote>\n<h3 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h3><ul>\n<li><p>单列索引</p>\n<ul>\n<li><p>主键索引<br><em>是数据库中的一种特殊类型的索引，它基于表的主键（Primary Key）创建。主键是表中每一行记录的唯一标识符，因此主键索引的主要目的是确保数据的唯一性和快速检索。</em></p>\n</li>\n<li><p>唯一索引<br><em>唯一索引（Unique Index）是数据库中的一种索引类型，它的作用是确保一个或多个列（索引列）的组合在表中是唯一的。这意味着，任何尝试插入或更新记录，如果会导致违反唯一性约束，都将被数据库拒绝。</em></p>\n</li>\n<li><p>普通索引</p>\n<p>是数据库中最基本的索引类型，它允许在表的一个或多个列上创建，以加快数据检索速度。与唯一索引不同，普通索引不强制要求索引列的值是唯一的，因此相同的索引值可以在表中出现多次。</p>\n</li>\n</ul>\n</li>\n<li><p>联合索引<br><em>是数据库中一种特殊的索引类型，它包含两个或更多列的组合。这种索引允许数据库引擎在查询时更高效地定位数据，因为它同时考虑了多个列的值。联合索引对于优化涉及多个列的查询特别有用，尤其是当这些列经常一起出现在查询条件中时。</em></p>\n</li>\n<li><p>全文索引<br><em>全文索引是专门为了提高文本数据检索的效率和精度而设计的索引。它通常用于大型文本数据的搜索，如文章、博客帖子、评论等。全文索引的工作原理是将文本分解成单词或短语（称为“token”），然后对这些token建立索引。这样，当用户进行搜索时，数据库可以快速找到包含这些单词或短语的记录。</em></p>\n</li>\n<li><p>前缀索引</p>\n<ul>\n<li>用字段的一部分作为索引</li>\n<li>特点<ul>\n<li>节省内存</li>\n<li>查询的次数比一般索引多</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引查询特性\"><a href=\"#索引查询特性\" class=\"headerlink\" title=\"索引查询特性\"></a>索引查询特性</h3><h4 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h4><blockquote>\n<p>我们在搜索的时候定了很多列，而辅助索引中不完全包含这些列，就会从辅助索引查到主键索引找到完整的行去找。这就</p>\n</blockquote>\n<h4 id=\"索引覆盖\"><a href=\"#索引覆盖\" class=\"headerlink\" title=\"索引覆盖\"></a>索引覆盖</h4><ul>\n<li>当你查询的数据只是辅助索引和主键的值时，只需要查辅助索引的B+树即可</li>\n<li>可以用来优化sql<ul>\n<li>这里id是聚集索引，value是普通索引</li>\n<li>优化前：select * from table1 where value &#x3D; 100 limit 300000,10<br><em>从为value建立的索引上找到300010条value&#x3D;100的记录的id，再拿这300010个id去主键索引找到对应的叶子结点，拿到每个id对应的数据返回。这种方式下，sql的执行非常耗时</em></li>\n<li>优化后：select id from table1 where value &#x3D; 100 and id &gt; xxx and xxx …. limit 10</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"索引下堆\"><a href=\"#索引下堆\" class=\"headerlink\" title=\"索引下堆\"></a>索引下堆</h4><blockquote>\n<p>ICP<br>index condition pushdown</p>\n</blockquote>\n<ul>\n<li><p>低版本的Mysql遇到多个索引时，是拿一个索引查，剩下的索引用来筛选<br>会回表</p>\n</li>\n<li><p>Mysql5.7后，会使用多个索引直接去存储引擎查</p>\n</li>\n<li><p>具体来说，在没有使用ICP的情况下，MySQL的查询过程为：</p>\n<ol>\n<li>存储引擎读取索引记录；</li>\n<li>根据索引中的主键值，定位并读取完整的行记录；</li>\n<li>存储索引把记录交给Server层去检测该记录是否满足WHERE条件。</li>\n</ol>\n</li>\n<li><p>使用ICP后的查询过程：</p>\n<ol>\n<li><p>存储引擎读取索引记录（不是完整的行记录）</p>\n</li>\n<li><p>判断WHERE条件部分能否用索引中的列来进行检查，如果条件不满足，则处理下一行索引记录</p>\n</li>\n<li><p>条件满足，使用索引中的主键去定位，并读取完整的行记录。</p>\n</li>\n<li><p>存储引擎把记录交给Server层，Server层检测该记录是否满足Where条件的其余部分。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>当你使用联合索引查询时，会优先考虑最左边的索引值</p>\n</blockquote>\n<ul>\n<li><p>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p>\n<ul>\n<li><p>为什么&gt;就会断开，&gt;&#x3D;却依然可以？</p>\n<p>假设是where a &gt;&#x3D; 1 and b &#x3D; 2<br>对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的</p>\n</li>\n</ul>\n</li>\n<li><p>分多种情况，假设有联合索引ABC</p>\n<ul>\n<li>ABC都给了准确的值 会使用ABC的索引去查</li>\n<li>AB给了值，但是C没有 只会使用A的索引去查</li>\n<li>AC给了值，但是B没有 只会使用A的索引去查</li>\n<li>使用到了字符串通配符匹配，当%不为开头时，可以使用索引</li>\n<li>对A进行了范围查询 可以使用索引</li>\n<li>对BC进行了范围查询  不能使用索引</li>\n<li>对ABC任意两个及以上进行范围查询 不能使用索引</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引的选择法则\"><a href=\"#索引的选择法则\" class=\"headerlink\" title=\"索引的选择法则\"></a>索引的选择法则</h3><ul>\n<li>表的记录较小，小于2000，不需要建立索引</li>\n<li>索引最好选择与业务无关的自增字段  与业务无关的自增字段可以保证减少B+树为了自平衡的一些操作</li>\n<li>聚集索引不要选择很长的字段 因为所有的索引都会存储聚集索引的值</li>\n<li>如果业务没有需求，请尽量使用普通索引而不是唯一索引<ul>\n<li>普通索引可以使用缓存池中的change buffer，加快随机写磁盘的速度</li>\n<li>唯一索引每次都要读所有数据保证唯一性</li>\n</ul>\n</li>\n<li>选择区别度大的字段作为索引，可以根据基数判断   命令 show index from 表</li>\n</ul>\n<h2 id=\"MySql日志\"><a href=\"#MySql日志\" class=\"headerlink\" title=\"MySql日志\"></a>MySql日志</h2><p>Mysql 三种日志：<code>bin log</code>、<code>redo log</code>、<code>undo log</code></p>\n<blockquote>\n<p>WAL（Write Ahead Logging）：先写日志，再写磁盘</p>\n</blockquote>\n<p>这里先做一个简单的介绍：</p>\n<ul>\n<li><code>bin log</code>：存放所有的更新操作(逻辑存储)</li>\n<li><code>redo log</code>：配合 <code>bin log</code> 使用，也是存放所有更新操作(物理存储)</li>\n<li><code>undo log</code>：负责事务的原子性，保证可以回滚</li>\n</ul>\n<p>其中 <code>bin log</code> 属于 Mysql Server 层级别、<code>redo log</code> 与 <code>undo log</code> 属于 Innodb 存储引擎级别</p>\n<h3 id=\"bin-log-redo-log\"><a href=\"#bin-log-redo-log\" class=\"headerlink\" title=\"bin log redo log\"></a>bin log redo log</h3><p><code>bin log</code> 与 <code>redo log</code> 会一起使用，<code>bin log</code> 相当于总账本，而 <code>redo log</code> 想当于记录今天流水的账本，之后 Mysql 会将 <code>redo Log</code> 的内容写到 <code>bin log</code> 内（<strong>二阶段提交</strong>，下文会介绍）</p>\n<p>注意：</p>\n<ul>\n<li><code>bin log</code> 与 <code>redo log</code> 大小固定</li>\n<li><code>redo log</code> 可以设置为一组四个文件，每个文件大小为 1GB</li>\n</ul>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240911105839822.png\" alt=\"image-20240911105839822\"></p>\n<p><code>checkpoint</code>：擦除的位置，<code>checkpoint</code> 之前的数据将数据更新到数据文件</p>\n<p><code>write pos</code>：记录当前位置</p>\n<p>两个指针都是循环写，即写到最后，又从头开始，循环使用这一部分空间</p>\n<ul>\n<li><code>redo log</code> 实现了 <code>crash safe</code></li>\n</ul>\n<blockquote>\n<p>crash safe：保证 Mysql 出现故障后，之前的数据也不会丢失的能力</p>\n</blockquote>\n<h4 id=\"基本作用\"><a href=\"#基本作用\" class=\"headerlink\" title=\"基本作用\"></a>基本作用</h4><p><code>binlog(binary log)</code>：记录对数据库的修改操作（增删改、表结构修改），会校验事务的完整性（事务 <code>begin commit</code>），也有备份点用于还原数据。主库可以使用 binlog 去备份出从库</p>\n<p><code>redolog</code>：WAL 写前日志，在写入 binlog 数据前，先写入 redolog，作为 crash safe 的安全保障手段，redolog 可以恢复在断点时那些没能刷回磁盘的数据。</p>\n<blockquote>\n<p>为什么要有 redolog？</p>\n</blockquote>\n<p>数据写入的过程是：先写入内存，缓存够一部分后，再刷脏页刷入磁盘中</p>\n<p>内存的数据是易失的，如果发生断电，那么缓存的数据就会丢失掉，因此引入的解决办法是<strong>写前日志 WAL</strong></p>\n<p>写入 binlog 前，先写 redolog，这样可以减少数据丢失</p>\n<h3 id=\"bin-redo区别\"><a href=\"#bin-redo区别\" class=\"headerlink\" title=\"bin redo区别\"></a>bin redo区别</h3><p>三大区别：</p>\n<ol>\n<li>级别不同：<code>redo log</code> 是 <code>InnoDB</code> 引擎特有的；<code>binlog</code> 是 <code>MySQL</code> 的 <code>Server</code> 层实现的，所有引擎都可以使用。</li>\n<li>存储内容不同：<code>redo log</code> 是<strong>物理日志</strong>，记录的是 “在某个数据页上做了什么修改”；<code>binlog</code> 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如 “给 ID&#x3D;2 这一行的 c 字段加 1”。</li>\n<li>写的方式不同：<code>redo log</code> 是<strong>循环写</strong>的，空间固定会用完；<code>binlog</code> 是可以<strong>追加写</strong>入的。“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，<strong>并不会覆盖以前的日志</strong>。</li>\n</ol>\n<h3 id=\"bin-redo-如何联系\"><a href=\"#bin-redo-如何联系\" class=\"headerlink\" title=\"bin redo 如何联系\"></a>bin redo 如何联系</h3><p>它们有一个共同的数据字段，叫 <strong>XID</strong>。</p>\n<p>崩溃恢复的时候，会按顺序扫描 redo log：</p>\n<ul>\n<li>如果碰到既有 <code>prepare</code>、又有 <code>commit</code> 的 <code>redo log</code>，就直接提交</li>\n<li>如果碰到只有 <code>prepare</code>、而没有 <code>commit</code> 的 <code>redo log</code>，就拿着 XID 去 <code>binlog</code> 找对应的事务</li>\n</ul>\n<h3 id=\"rodolog-如何判断崩溃？\"><a href=\"#rodolog-如何判断崩溃？\" class=\"headerlink\" title=\"rodolog 如何判断崩溃？\"></a>rodolog 如何判断崩溃？</h3><p>两阶段提交</p>\n<ul>\n<li>如果redo log内事务为commit 直接提交</li>\n<li>如果redo log 事务为prepare <ul>\n<li>bin log事务存在且完整 提交</li>\n<li>bin log 事务不存在或不完整 回滚</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bin-log-如何判断完整性？\"><a href=\"#bin-log-如何判断完整性？\" class=\"headerlink\" title=\"bin log 如何判断完整性？\"></a>bin log 如何判断完整性？</h3><p>对于不同的数据，bin log有不同的标识其结束的标志</p>\n<h3 id=\"二阶段提交\"><a href=\"#二阶段提交\" class=\"headerlink\" title=\"二阶段提交\"></a>二阶段提交</h3><p>由来：由于 <code>bin log</code> 与 <code>redo log</code> 属于不同的级别（<code>bin log</code> 属于 mysql</p>\n<p>级别，而 <code>redo log</code> 与 <code>undo log</code> 属于 Innodb 级别），</p>\n<p> <strong>为了保证数据同步，就得保证这两个文件一致</strong>，所以有了二阶段提交的概念</p>\n<blockquote>\n<p>两状态提交：有两个状态 <code>prepare</code> 与 <code>commit</code></p>\n<p>数据要进行更新时，会先写日志，再去更改数据，这个过程会先去写 <code>redo log</code>，将状态设置为 <code>prepare</code> 状态；</p>\n<p>（咔嚓～～～～如果此时断电，因为 <code>binlog</code> 数据还没有写入，所以会丢弃 <code>redo log</code> 中的 <code>prepare</code> 这部分数据，并且进行回滚）</p>\n<p>然后再写 <code>bin log</code>；</p>\n<p>（咔嚓～～～～如果此时断电，因为 <code>bin log</code> 已经写入，判断 <code>redo log</code> 中也存在，只不过状态是 <code>prepare</code>，依然可以继续进行）</p>\n<p>提交事务，将状态改为 <code>commit</code></p>\n</blockquote>\n<p>二阶段提交过程：（这个图也能帮我们了解清楚，一条更新语句的执行过程）</p>\n<p><a href=\"http://img.yesmylord.cn//image-20210813103310740.png\"><img data-src=\"https://img.jyhmw.cn/image-20210813103310740.png\" alt=\"二阶段提交过程\"></a></p>\n<p><a href=\"http://img.yesmylord.cn//image-20210813103310740.png\">二阶段提交过程</a></p>\n<p><strong>调换顺序存在的问题：</strong></p>\n<ul>\n<li><p>情况 1：<strong>假设先写 <code>redo log</code> 再写 <code>bin log</code>：</strong></p>\n<p>假如写完 <code>redo log</code> 后 mysql 崩溃重启，由于写了 <code>redo log</code>，所以会恢复这个数据，但是 <code>bin log</code> 没有写入，所以如果之后使用 <code>bin log</code> 恢复数据，就会与原库不同</p>\n</li>\n<li><p>情况 2：<strong>假设先写 <code>bin log</code> 再写 <code>redo log</code>：</strong></p>\n<p>假如写完 <code>bin log</code> 后 mysql 崩溃重启，由于还没写 <code>redo log</code>，崩溃后恢复，两个文件不一致，判断此事务无效；虽然原库虽然会无此数据，但使用 <code>bin log</code> 恢复后，新的数据与原库不同；</p>\n</li>\n</ul>\n<h3 id=\"双一规则\"><a href=\"#双一规则\" class=\"headerlink\" title=\"双一规则\"></a>双一规则</h3><blockquote>\n<p>写redolog和写binlog，都需要先write进内存中的文件，再等待fsync刷回磁盘</p>\n</blockquote>\n<ul>\n<li><p>双一规则就是Mysql提供了两个参数，控制write和fsync的次数</p>\n<ul>\n<li><p>sync_binlog&#x3D;1 ： binlog每一次write都进行一次fsync</p>\n</li>\n<li><p>innodb_flush_log_at_trx_commit&#x3D;1： redolog事务每提交一次就刷一次盘</p>\n</li>\n</ul>\n</li>\n<li><p>为了减少刷磁盘的IO次数，使用了组提交</p>\n<ul>\n<li>redolog有一个记录事务的时序的标志LSN，假设有三个事务，第一个事务就是LSN&#x3D;10，第二个就可能是LSN&#x3D;60，第三个可能是LSN&#x3D;120</li>\n<li>在fsync时，会判断LSN，将LSN&lt;&#x3D;120的全部刷回磁盘，以减小IO次数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分库分表\"><a href=\"#分库分表\" class=\"headerlink\" title=\"分库分表\"></a>分库分表</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ol>\n<li><p>分库</p>\n<p>分库是指在表数量不变的情况下对库进行切分<br>举例：如下图，数据库A中存放了user和order两张表，将两张表切分到两个数据库中，user表放到database A，order表放到database B<br><img data-src=\"https://img.jyhmw.cn/image-20240605125228332.png\" alt=\"image-20240605125228332\"></p>\n</li>\n<li><p>分表<br>分表是指在库数量不变的情况下对表进行切分<br>举例：如下图，数据库A中存放了user表，将user表切分成user1 和 user2两张表并放到database A中</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240605125442246.png\" alt=\"image-20240605125442246\"></p>\n</li>\n<li><p>分库分表<br>分库分表是指库和表都切分，数量都发生变化<br>举例：如下图，数据库 A 中存放了 user表，将 user表切分成 user1、user2、user3、user4 四张表，user1 和 user2 放到 database A中，user3 和 user4 放到 database B 中<br><img data-src=\"https://img.jyhmw.cn/image-20240605125519061.png\" alt=\"image-20240605125519061\"></p>\n</li>\n</ol>\n<h3 id=\"如何切分库-表？\"><a href=\"#如何切分库-表？\" class=\"headerlink\" title=\"如何切分库&#x2F;表？\"></a>如何切分库&#x2F;表？</h3><blockquote>\n<p>主流的切分方式有3种：水平切分、垂直切分和混合切分</p>\n</blockquote>\n<h4 id=\"水平切分\"><a href=\"#水平切分\" class=\"headerlink\" title=\"水平切分\"></a><strong>水平切分</strong></h4><ol>\n<li><p>水平分表<br>水平分表结构不变，将单表数据切分成多表。切分后的结果：</p>\n<ul>\n<li>每个表解结构一样</li>\n<li>每个表的数据不一样</li>\n<li>所有表的数据并集为全量数据</li>\n</ul>\n<p>切分抽象图：<br><img data-src=\"https://img.jyhmw.cn/image-20240605125813722.png\" alt=\"image-20240605125813722\"></p>\n<p>举例：如下图，order表，按照 oder_id 的数据范围水平切分后变成了 order1 和 order2 表，两个表的结构一样，数据不同<br><img data-src=\"https://img.jyhmw.cn/image-20240605125834895.png\" alt=\"image-20240605125834895\"></p>\n</li>\n<li><p>水平分库<br>水平分库是指，将表水平切分后分到不同数据库，使得每个库具有相同的表，表中数据不相同，水平分库一般是伴随水平分表<br><img data-src=\"https://img.jyhmw.cn/image-20240605130041639.png\" alt=\"image-20240605130041639\"></p>\n</li>\n</ol>\n<h4 id=\"垂直切分\"><a href=\"#垂直切分\" class=\"headerlink\" title=\"垂直切分\"></a>垂直切分</h4><ol>\n<li><p>垂直分表</p>\n<p>垂直分表指将存在一张表中的字段切分到多张表。切分后的结果：</p>\n<ul>\n<li>每个表的结构不一样；</li>\n<li>每个表的数据不一样；</li>\n<li>所有表的字段并集是原表的字段；</li>\n</ul>\n<p>切分抽象图：<br><img data-src=\"https://img.jyhmw.cn/image-20240605130131319.png\" alt=\"image-20240605130131319\"></p>\n<p>举例如下图，order表，根据字段垂直切分，切分后order_base表包含一部分字段的数据和order_info表包含另一部分字段的数据<br><img data-src=\"https://img.jyhmw.cn/image-20240605130221137.png\" alt=\"image-20240605130221137\"></p>\n</li>\n<li><p>垂直分库</p>\n<p>垂直分库指的是，将单个库中的表分到多个库，每个库包含的表不一样。</p>\n<p>举例：如下图，database A 中的 order 表 和 user表，垂直分库为 database A 包含 order表，database B 包含 user 表。<br><img data-src=\"https://img.jyhmw.cn/image-20240605130250421.png\" alt=\"image-20240605130250421\"></p>\n</li>\n</ol>\n<h4 id=\"混合切分\"><a href=\"#混合切分\" class=\"headerlink\" title=\"混合切分\"></a>混合切分</h4><p>混合切分其实就是水平切分和垂直切分的组合，切分抽象图如下：<br><img data-src=\"https://img.jyhmw.cn/image-20240605130322948.png\" alt=\"image-20240605130322948\"></p>\n<p>举例：如下图，order表，按照 oder_id数据范围做了水平切分，并且按照表字段做了垂直切分<br><img data-src=\"https://img.jyhmw.cn/image-20240605130349453.png\" alt=\"image-20240605130349453\"></p>\n<h2 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h2><blockquote>\n<p>多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p>\n</blockquote>\n<p>MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁</p>\n<ul>\n<li><p>聚簇索引记录中有两个必要的隐藏列：<br><strong>trx_id</strong>：用来存储每次对某条聚簇索引记录进行修改时候的事务id</p>\n<p><strong>roll_pointer</strong>：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。</p>\n</li>\n</ul>\n<p>而读已提交和可重复读的区别就在于它们生成ReadView的策略不同</p>\n<ul>\n<li>开始事务时创建readView，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组</li>\n<li>访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比readView:<ul>\n<li>如果在readView的左边（比readView都小），可以访问（在左边意味着事务已经提交）</li>\n<li>如果在readView的右边（比readView都大）或者就在readView中，不可以访问，获取roll_pointer，取上一版本重新对比（在右边意味着，该事务在readView生成之后出现，在readView中意味着该事务还未提交）</li>\n</ul>\n</li>\n<li><strong>读已提交</strong>隔离级别下的事务在每次查询的开始都会生成一个独立的readView，而<strong>可重复读</strong>隔离级别则在第一次读的时候生成一个readView，之后的读都复用之前的readView</li>\n</ul>\n<p>这就是Mysql的MVCC，通过版本链，实现多版本，可并发读-写，写-读。通过readView生成策略的不同实现不同的隔离级别</p>\n<h2 id=\"MySql执行计划\"><a href=\"#MySql执行计划\" class=\"headerlink\" title=\"MySql执行计划\"></a>MySql执行计划</h2><blockquote>\n<p>MySQL中，执行计划（Execution Plan）是数据库查询优化器生成的一份报告，它详细描述了数据库如何执行一个特定的SQL查询。通过分析执行计划，开发者和数据库管理可以了解查询的执行效率，并据此进行优化</p>\n</blockquote>\n<p><strong>使用<code>EXPLAIN</code>语句</strong></p>\n<p>几个常见的主要字段</p>\n<ol>\n<li>id：查询的序列号，表示执行的顺序</li>\n<li>select_type：查询类型，如SIMPLE、PRIMARY、SUBQUERY、DERIVED等<ul>\n<li>SIMPLE：简单查询不包含子查询</li>\n<li>PRIMARY：在包含子查询的所有查询中，最外层的查询</li>\n<li>SUBQUERY：子查询中的第一个SELECT</li>\n<li>DERIVED：派生表，即FROM子句中的子查询</li>\n</ul>\n</li>\n<li>table：正在访问的表或衍生表</li>\n<li>partitions：匹配的分区</li>\n<li>type：连接类型，如ALL、INDEX、RANGE、REF、EQ_REF、CONST、SYSTEM等<ul>\n<li>SYSTEM：表示只有一行，这是最好的连接类型</li>\n<li>CONST：表中只有一行匹配，通常因为主键或唯一索引的查找</li>\n<li>EQ_REF：使用主键或唯一索引查找，返回行数为1</li>\n<li>REF：使用普通索引进行查找</li>\n<li>FULLTEXT：使用全文索引进行查找</li>\n<li>INDEX：全索引查找</li>\n</ul>\n</li>\n<li>possbile：可能使用的索引</li>\n<li>key：实际使用的索引</li>\n<li>key_len：使用的索引的长度</li>\n<li>ref：索引列上使用的列或常量</li>\n<li>rows：估计需要检查的行数</li>\n<li>filitered：估计需要检查的行数</li>\n<li>Extra：额外的信息<ul>\n<li>Using filesort：MySQL需要额外的排序操作</li>\n<li>Using temporary：MySQL需要创建临时表来存储结果</li>\n<li>Using index：查询直接使用了索引</li>\n<li>Using Where：Where条件在索引查找中被使用</li>\n<li>Using index condition：索引下堆</li>\n</ul>\n</li>\n</ol>\n","categories":["八股","数据库"],"tags":["MySql","数据库"]},{"title":"RPC和HTTP","url":"/2024/04/17/RPC%E5%92%8CHTTP/","content":"<h1 id=\"RPC和HTTP的区别\"><a href=\"#RPC和HTTP的区别\" class=\"headerlink\" title=\"RPC和HTTP的区别\"></a>RPC和HTTP的区别</h1><h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><blockquote>\n<p>远程过程调用协议</p>\n<p>RPC机制是根据语言的API来定义的，而不是根据网络的应用来定义的</p>\n</blockquote>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><blockquote>\n<p>超文本传输协议</p>\n</blockquote>\n<h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>它是一种用于分布式、协作式和超媒体信息系统的应用层协议，是万维网的数据通信的基础，也是互联网应用最为广泛的一种网络传输协议。HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织所发起，标准制定由万维网协会进行协调，HTTP协议中最广泛使用的版本是HTTP 1.1。</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><h3 id=\"功能层面\"><a href=\"#功能层面\" class=\"headerlink\" title=\"功能层面\"></a>功能层面</h3><ul>\n<li>HTTP是应用层超文本传输协议，主要服务在网页端和服务端之间的数据传输上</li>\n<li>RPC是一个远程过程调用协议，定位在实现不同计算机应用之间的数据通信，屏蔽了通讯的底层复杂度</li>\n</ul>\n<h3 id=\"实现层面\"><a href=\"#实现层面\" class=\"headerlink\" title=\"实现层面\"></a>实现层面</h3><ul>\n<li>HTTP是一个已经实现并且成熟的应用层协议，定义了通信报文的格式，比如请求头请求体，响应体等等</li>\n<li>RPC只是一种通信协议的规范，并没有具体的实现，只有按照RPC通信协议规范去实现的通信框架才是协议的具体实现。比如RPC也可以使用HTTP协议来实现</li>\n</ul>\n<h2 id=\"常见的RPC框架\"><a href=\"#常见的RPC框架\" class=\"headerlink\" title=\"常见的RPC框架\"></a>常见的RPC框架</h2><h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li>由阿里巴巴开发</li>\n<li>支持Java语言</li>\n<li>特点：高性能、高可用、透明化调用远程服务</li>\n<li>底层实现：使用Netty作为底层通信框架，支持多种序列化协议，如Hessian、Kryo等</li>\n</ul>\n<h3 id=\"Motan\"><a href=\"#Motan\" class=\"headerlink\" title=\"Motan\"></a>Motan</h3><ul>\n<li>由新浪微博开发</li>\n<li>支持Java语言</li>\n<li>特点：轻量级、高可用、透明化调用远程服务</li>\n<li>底层实现：Motan的架构与Dubbo类似，支持多种服务注册和发现机制</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><ul>\n<li>由Google开源</li>\n<li>跨语言支持多种语言</li>\n<li>特点：基于HTTP&#x2F;2协议设计，支持双向流头部压缩等特性</li>\n<li>底层实现：使用Protocol Buffers作为接口定义语言，Netty作为通信框架。</li>\n</ul>\n<h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><ul>\n<li>开发者：由Pivotal公司开源。</li>\n<li>语言支持：主要支持Java语言。</li>\n<li>特点：提供了丰富的生态组件，支持微服务架构中的多种场景。</li>\n<li>底层实现：Spring Cloud OpenFeign是其中用于简化HTTP客户端开发的工具。</li>\n</ul>\n","categories":["技术栈"],"tags":["RPC","HTTP"]},{"title":"RPC","url":"/2024/04/07/RPC/","content":"<h1 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h1><h2 id=\"RPC是什么？\"><a href=\"#RPC是什么？\" class=\"headerlink\" title=\"RPC是什么？\"></a>RPC是什么？</h2><blockquote>\n<p>RPC，Remote Procedure Call，远程过程调用</p>\n<p>过程：就是业务处理、计算任务、也就是程序，像调用本地方法一样调用远程方法</p>\n</blockquote>\n<h2 id=\"RPC原理\"><a href=\"#RPC原理\" class=\"headerlink\" title=\"RPC原理\"></a>RPC原理</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本地</span></span><br><span class=\"line\"><span class=\"type\">UserService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> service.findById(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RPC</span></span><br><span class=\"line\"><span class=\"type\">UserService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Rpcfx.create(UserService.class, url);</span><br><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> service.findById(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img.jyhmw.cn/image-20240407161928531.png\" alt=\"image-20240407161928531\"></p>\n<ol>\n<li>客户端处理过程中调用Client stub（就像调用本地方法一样），传递参数</li>\n<li>Client stub将参数编组为消息，然后通过系统调用向服务端发送消息</li>\n<li>客户端本地操作系统将消息从客户端机器发送到服务端机器</li>\n<li>服务端操作系统将接收到的数据包传递给Server stub</li>\n<li>Server stub解组消息为参数</li>\n<li>Server stub再调用服务端的过程，过程结果以反方向的相同步骤响应给客户端</li>\n</ol>\n<p><strong>核心</strong>是代理机制：</p>\n<ol>\n<li>本地代理存根Stub，通过动态代理或 AOP 拦截请求</li>\n<li>本地序列化反序列化</li>\n<li>网络通信</li>\n<li>远程序列化反序列化</li>\n<li>远程服务存根Skeleton</li>\n<li>调用实际业务服务</li>\n<li>原路返回服务结果</li>\n<li>返回给本地调用方</li>\n</ol>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240407162652843.png\" alt=\"image-20240407162652843\"></p>\n<h2 id=\"RPC协议\"><a href=\"#RPC协议\" class=\"headerlink\" title=\"RPC协议\"></a>RPC协议</h2><p>RPC调用过程中需要将参数编组为消息进行发送，接收方需要解组消息为参数，过程处理结果同样需要经编组、解组。</p>\n<p>消息由哪些部分构成及消息的表示形式就构成了消息协议。 <code>RPC调用过程中采用的消息协议称为RPC协议。</code></p>\n<p>RPC协议规定请求、响应消息的格式在TCP (网络传输控制协议)上可选用或自定义消息协议来完成RPC消息交互</p>\n<p>我们可以选用通用的标准协议(如: http、 https) ，也可根据自身的需要定义自己的消息协议!</p>\n<ul>\n<li>常见的RPC协议<ul>\n<li><img data-src=\"https://img.jyhmw.cn/image-20240407163012087.png\" alt=\"image-20240407163012087\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"RPC框架\"><a href=\"#RPC框架\" class=\"headerlink\" title=\"RPC框架\"></a>RPC框架</h2><p>封装好参数编组、消息解组、底层网络通信的RPC框架，让我们站在巨人肩膀上，只需专注过程代码的编写。</p>\n<h3 id=\"传统的webservice框架\"><a href=\"#传统的webservice框架\" class=\"headerlink\" title=\"传统的webservice框架\"></a>传统的webservice框架</h3><ul>\n<li>Apache CXF</li>\n<li>Apache Axis2</li>\n<li>Java自带的 JAX-WS</li>\n</ul>\n<blockquote>\n<p>webService框架大多基于标准的SOAP协议</p>\n</blockquote>\n<h3 id=\"新兴的微服务框架\"><a href=\"#新兴的微服务框架\" class=\"headerlink\" title=\"新兴的微服务框架\"></a>新兴的微服务框架</h3><ul>\n<li>Dubbo</li>\n<li>Spring Cloud alibaba</li>\n<li>Apache Thrift</li>\n</ul>\n<h3 id=\"为何使用RPC\"><a href=\"#为何使用RPC\" class=\"headerlink\" title=\"为何使用RPC\"></a>为何使用RPC</h3><ul>\n<li>服务化</li>\n<li>可重用</li>\n<li>系统间交互调用</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"其他相关\"><a href=\"#其他相关\" class=\"headerlink\" title=\"其他相关\"></a>其他相关</h2><ul>\n<li>Client、 Server、 calls、 replies、service、programs、procedures、version、marshalling(编组)、unmarshalling(解组)</li>\n<li>一个网络服务由一个或多个远程程序集构成</li>\n<li>一个远程程序实现一个或多个远程过程</li>\n<li>过程、过程的参数、结果在程序协议说明书中定义说明</li>\n<li>为兼容程序协议变更、一个服务端可能支持多个版本的远程程序</li>\n</ul>\n<h2 id=\"序列化工具\"><a href=\"#序列化工具\" class=\"headerlink\" title=\"序列化工具\"></a>序列化工具</h2><h3 id=\"JDK-Serializable\"><a href=\"#JDK-Serializable\" class=\"headerlink\" title=\"JDK Serializable\"></a>JDK Serializable</h3><ul>\n<li>Java自带的序列化机制，通过实现<code>java.io.Serializable</code>接口来实现对象的序列化。</li>\n</ul>\n<h3 id=\"JSON-B-JSON-P\"><a href=\"#JSON-B-JSON-P\" class=\"headerlink\" title=\"JSON-B &#x2F; JSON-P\"></a>JSON-B &#x2F; JSON-P</h3><ul>\n<li>Java EE的一部分，用于JSON数据的绑定和解析。</li>\n</ul>\n<h3 id=\"Jackson\"><a href=\"#Jackson\" class=\"headerlink\" title=\"Jackson\"></a>Jackson</h3><ul>\n<li>一个快速的JSON处理工具，可以轻松地将Java对象转换成JSON格式，并且反过来将JSON字符串转换成Java对象。</li>\n</ul>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li>Apache Thrift是一个软件框架，用于进行可扩展且跨语言的服务的开发。</li>\n</ul>\n<h3 id=\"Protobuf-Protocol-Buffers\"><a href=\"#Protobuf-Protocol-Buffers\" class=\"headerlink\" title=\"Protobuf (Protocol Buffers)\"></a>Protobuf (Protocol Buffers)</h3><ul>\n<li>由Google开发的一个数据描述语言，用于序列化结构化数据，如请求、响应、配置文件等。</li>\n</ul>\n","categories":["技术栈"],"tags":["框架","远程调用"]},{"title":"NIO","url":"/2024/09/13/NIO/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><blockquote>\n<p>NIO：可以叫做Non - Blocking IO，也可以成为New IO，<strong>非阻塞只是NIO的特点之一</strong></p>\n</blockquote>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p><strong>不用NIO情况下如何实现一个服务器</strong></p>\n<p><strong>法一</strong>：多线程</p>\n<ul>\n<li>特点：一个Socket连接，使用一个线程管理</li>\n<li>有点：一对一服务，适合连接数少的场景</li>\n<li>缺点：<ul>\n<li>内存占用高</li>\n<li>现成上下文切换成本高</li>\n</ul>\n</li>\n</ul>\n<p><strong>法二</strong>：线程池</p>\n<ul>\n<li>特点：</li>\n<li>使用线程池思想，控制线程数量</li>\n<li>优点：避免了创建大量的线程导致内存占用过高的问题，适合<strong>短连接场景</strong></li>\n<li>缺点：属于阻塞模式（即一个线程同时只能给一个 socket 连接提供服务），线程的利用率不高</li>\n</ul>\n<p><strong>法三</strong>：使用 NIO 的 Selector</p>\n<ul>\n<li>特点：用一个线程管理 Selector，Selector 去管理注册在此的通道（下面会详细介绍）</li>\n<li>优点：适合<strong>连接数多，但是流量低</strong>的场景（low traffic）</li>\n</ul>\n<p><img data-src=\"https://img.jyhmw.cn/image-20211002193300542.png\" alt=\"示意图\"></p>\n<h2 id=\"简单了解\"><a href=\"#简单了解\" class=\"headerlink\" title=\"简单了解\"></a>简单了解</h2><blockquote>\n<p>JavaNIO由三个核心组件构成</p>\n</blockquote>\n<ul>\n<li>Channel</li>\n<li>Buffer</li>\n<li>Selector</li>\n</ul>\n<p>除了这三个还有别的如Pipe、FileLock等等</p>\n<h3 id=\"NIO与BIO对比\"><a href=\"#NIO与BIO对比\" class=\"headerlink\" title=\"NIO与BIO对比\"></a>NIO与BIO对比</h3><ol>\n<li>BIO 是面向<strong>流</strong>的；NIO 面向<strong>缓冲区</strong></li>\n<li>BIO <strong>只能向后读</strong>，不能向前读；NIO <strong>可以向前也可以向后读</strong></li>\n<li>BIO 是<strong>单向的</strong>，一端要么读要么写；NIO 中通道是<strong>双向的</strong>，一端可读可写</li>\n<li>BIO 是<strong>阻塞</strong>的；NIO 是<strong>非阻塞</strong>的</li>\n</ol>\n<h3 id=\"大致过程\"><a href=\"#大致过程\" class=\"headerlink\" title=\"大致过程\"></a>大致过程</h3><p><img data-src=\"https://img.jyhmw.cn/image-20240913112720081.png\" alt=\"image-20240913112720081\"></p>\n<h1 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h1><blockquote>\n<p>Buffer缓冲区：可以理解为一个数组，通道必须与Buffer一起使用</p>\n</blockquote>\n<p>具体的实现类：</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p><strong>核心API：</strong></p>\n<ul>\n<li><code>put(value)</code>：将 <code>value</code> 写入缓存（从当前的 <code>position</code> 开始写入，并增加 <code>position</code> 的值，即<strong>相对位置的写入</strong>）</li>\n<li><code>get(arr[])</code>：读取 <code>position</code> 位置下的数据到一个数组中（如果不传参数，默认读取一个字符）</li>\n<li><code>hasRemaining()</code>：判断 <code>position</code> 与 <code>limit</code> 之间的距离，如果还有数据可以处理，那么就返回 true</li>\n<li><code>clear()</code> ：清空缓冲区（清空的原理<strong>并不是真的清空了</strong>，只是将 position 的位置为 0，limit 设置为 capacity，即<strong>切换回写模式</strong>）</li>\n<li><code>flip()</code>：可以将缓冲区<strong>由写模式切换到读模式</strong>（将 limit 设为 position 的位置，再将 position 设置为 0）</li>\n<li><code>compact()</code>：压缩，将未读取的数据（即 position 与 limit 之间的数据）向前移动，然后 position 指向最后一个未读取的数据之后，然后 limit 指向 capacity</li>\n</ul>\n<p><strong>其他API</strong>：</p>\n<ul>\n<li><code>capacity(); limit() ; position()</code>：返回当前 <code>capacity/limit/position</code> 的值</li>\n<li><code>mark()</code>：标记当前 <code>position</code> 的位置，当调用 <code>reset</code> 方法时，会重置到 mark 标记过的位置（只能在 0-position 之前）</li>\n<li><code>remaining()</code>：返回 <code>position</code> 与 <code>limit</code> 之间的距离</li>\n<li><code>reset()</code>：重置 <code>position</code> 到 <code>mark</code> 标记过的位置</li>\n<li><code>rewind()</code>：将 <code>position</code> 设置为 0（即让 position 回到初始的位置），取消 mark 标记位</li>\n</ul>\n<h2 id=\"创建Buffer\"><a href=\"#创建Buffer\" class=\"headerlink\" title=\"创建Buffer\"></a>创建Buffer</h2><ul>\n<li>allocate(long)：</li>\n<li><strong>创建一个指定大小的缓冲区</strong>；是一个静态方法；（注意：<code>buffer</code> 对象不能 <code>new</code>，只能通过 <code>allocate</code> 分配）</li>\n<li><code>warp()</code>：把已存在的数组包装为一个 Buffer 对象（无论操作两者中的哪一个，另一个也会变化，因为就是同一个数组）</li>\n</ul>\n<p>注意：</p>\n<p>这两种创建方式，都是<strong>间接的</strong>创建了一个缓冲区（间接：是指这个缓冲区在 JVM 堆中）</p>\n<blockquote>\n<p>如何将一个字符串转换为一个ByteBuffer数组</p>\n</blockquote>\n<ol>\n<li>使用 <code>ByteBuffer</code> 的 <code>wrap</code> 方法</li>\n<li>使用 <code>Charset</code></li>\n<li>创建 <code>ByteBuffer</code> 再 <code>put</code> 字符串的字节数组</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//1、使用ByteBuffer的wrap</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf1</span> <span class=\"operator\">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class=\"line\"><span class=\"comment\">//2、使用Charset</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf2</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(str);</span><br><span class=\"line\"><span class=\"comment\">//3、创建ByteBuffer再放入</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf3</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">bf3.put(str.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"属性及变化\"><a href=\"#属性及变化\" class=\"headerlink\" title=\"属性及变化\"></a>属性及变化</h2><p>Buffer 有<strong>四个重要的属性</strong>：</p>\n<ul>\n<li><code>capacity</code>：表示当前 Buffer 的容量大小；创建时指定，创建后不能修改；如果写满了 capacity，那么需要等清空后才能写入数据</li>\n<li><code>position</code>：表示当前的位置，初始时为 0，每读写一个数据，<code>position</code> 就 + 1，最大为 <code>capacity-1</code></li>\n<li><code>limit</code>：指第一个不能被读或写的位置（即可以表示只能读取或写入多少个数据）</li>\n<li><code>mark</code>：设置一个标记位，当进行 <code>reset</code> 时，会将 <code>position</code> 的值变为 <code>mark</code> 原本标记的值</li>\n</ul>\n<p>四个属性有这样的大小关系：<code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>\n<p>下面有个图，可以清晰的表示整个过程</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20210920130513661.png\" alt=\"buffer存储过程\"></p>\n<p>结合代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> fc.read(bf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bf.flip(); </span><br><span class=\"line\">    <span class=\"comment\">//1、转换为读模式！将limit设为position，再将position设置为0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bf.hasRemaining())&#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> bf.get();</span><br><span class=\"line\">        <span class=\"comment\">//2、每读取一个字节，就将position+1</span></span><br><span class=\"line\">        System.out.print((<span class=\"type\">char</span>) b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bf.clear();</span><br><span class=\"line\">    <span class=\"comment\">//3、转换为写模式！将position的位置为0，limit设置为capacity</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"直接缓冲区\"><a href=\"#直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区\"></a>直接缓冲区</h2><p>首先要明确一个概念：<strong>只有 byteBuffer 才有资格参与 IO 操作</strong>，因为数据全为 01，只有 byteBuffer 存储的才是 01 二进制，所以只有它才能 IO 操作</p>\n<blockquote>\n<p>为什么要用直接缓冲区？</p>\n</blockquote>\n<p>使用非直接缓冲区<strong>可能会导致性能损耗</strong>（多一次拷贝过程）</p>\n<p>假设给一个通道传入了一个非直接缓冲区，那么通道会先创建一个<strong>临时的直接缓冲区</strong>，将<strong>非直接缓冲区的数据复制到临时的直接缓冲区</strong>，使用这个临时的直接缓冲区去执行 IO 操作（多一次拷贝，增大了开销）</p>\n<blockquote>\n<p>直接缓存区存在的问题：</p>\n</blockquote>\n<ul>\n<li><strong>直接缓存区绕过了 JVM 的堆栈</strong>，不受 JVM 控制，所以有可能我们创建的直接缓存区代价会更高</li>\n<li><strong>直接缓存区分配会较慢</strong>，因为 Java 需要调用 OS 的函数进行分配，所以会较慢</li>\n</ul>\n<blockquote>\n<p>如何创建一块直接缓冲区？</p>\n</blockquote>\n<p>调用 <code>ByteBuffer.allocateDirect(1024)</code> 即可</p>\n<h2 id=\"分散读与集中写\"><a href=\"#分散读与集中写\" class=\"headerlink\" title=\"分散读与集中写\"></a>分散读与集中写</h2><blockquote>\n<p>这主要是<strong>两种思想</strong></p>\n<p>分散读就是把原本的数据一次读到多个 buffer 中，集中写就是将多个 buffer 的内容一次性写入</p>\n</blockquote>\n<p>这两种思想分别有两个接口代表：<code>ScatteringByteChannel</code>（有 read 方法）、<code>GatheringByteChannel</code>（有 write 方法）</p>\n<p>都可以传入一个 <code>ByteBuffer</code> 的数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf1</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf2</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf3</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分散读</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">FileChannel</span> <span class=\"variable\">fc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>).getChannel()) &#123;</span><br><span class=\"line\">    fc.read(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;bf1, bf2, bf3&#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 这个read方法传入的是一个ByteBuffer数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以将数据分别读入三个缓冲区中</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>集中写同理</p>\n<h2 id=\"TCP粘包问题\"><a href=\"#TCP粘包问题\" class=\"headerlink\" title=\"TCP粘包问题\"></a>TCP粘包问题</h2><blockquote>\n<p>什么是粘包问题？</p>\n</blockquote>\n<ol>\n<li>以接收端来看：因为 <strong>TCP 是面向流的协议，所以不会保持输入数据的边界</strong>，导致接收端很可能<strong>一下子收到多个应用层报文</strong>，需要应用开发者自己分开，有些人觉得这样不合理，就起名为<strong>粘包</strong></li>\n<li>以发送端来看：用户数据被 TCP 发送时，会根据 Nagle 算法，将小的数据封装在一个报文段发送出去，导致不同的报文段黏在了一起</li>\n</ol>\n<blockquote>\n<p>如何解决</p>\n</blockquote>\n<ol>\n<li><p>发送方关闭Nagle方法</p>\n<ul>\n<li>设置<code>TCP_NODELAY</code>关闭Nagle算法</li>\n<li>最好不使用</li>\n</ul>\n</li>\n<li><p>交给应用层：</p>\n<ul>\n<li><p><strong>固定消息长度</strong>：一条消息就发送一个固定大小的数据，然后填充空白</p>\n<ul>\n<li>缺点：浪费带宽</li>\n</ul>\n</li>\n<li><p><strong>格式化数据</strong>：每条数据有固定的格式（开始符，结束符），这种方法简单易行</p>\n<ul>\n<li>缺点：但是这种方法需要保证传输的字符中没有该开始符与结束符，而且因为需要挨个遍历，传输速度不是很快</li>\n</ul>\n</li>\n<li><p><strong>TLV 格式</strong>：即 Type 类型、Length 长度、Value 数据，在类型和长度已知的情况下就可以方便的知道消息大小，分配合适的 buffer</p>\n<ul>\n<li>缺点：buffer 需要提前分配，如果分配过大，影响 server 的吞吐量</li>\n<li>HTTP1.1 是 TLV 格式（先传输类型）</li>\n<li>HTTP2.0 是 LTV 格式（先传输长度）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>此处举一个例子：（这里属于格式化数据的一种方式，使用到 <code>\\n</code> 作为分隔符）</p>\n</blockquote>\n<p> 网络上有多条数据发送给服务端。数据之间使用 <code>\\n</code> 进行分隔，但由于某种原因这些数据在接收时，被进行了重新组合。</p>\n<p>例如原始数据有 3 条为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello,world\\n</span><br><span class=\"line\">I<span class=\"string\">&quot;m zhangsan\\n</span></span><br><span class=\"line\"><span class=\"string\">How are you?\\n</span></span><br></pre></td></tr></table></figure>\n\n<p>变成了下面的两个 <code>byteBuffer</code>(黏包，半包)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello,world\\nI<span class=\"string\">&quot; m zhangsan\\nHo</span></span><br><span class=\"line\"><span class=\"string\">w are you?\\n</span></span><br></pre></td></tr></table></figure>\n\n<p>如何解决？（但这种方法需要对字节挨个遍历，所以<strong>效率不是很高</strong>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 模拟粘包</span></span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;Hello,world\\nI&#x27; m zhangsan\\nHo&quot;</span>.getBytes());</span><br><span class=\"line\">    spilt(source);</span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;w are you?\\n&quot;</span>.getBytes());</span><br><span class=\"line\">    spilt(source);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理粘包</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">spilt</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">    source.flip();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>)&#123;<span class=\"comment\">// 带索引的get方法不会改变position的值</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span> - source.position();</span><br><span class=\"line\">            <span class=\"comment\">// 计算要分配的缓冲长度</span></span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(len);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">                target.put(source.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    source.compact();</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里不能用clear</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h1><blockquote>\n<p>Channel：通道，类似于IO流，但是与流不同的是Channel是双向的</p>\n</blockquote>\n<p>IO流：如 <code>InputStream</code>、<code>OutputStream</code> 要么输入（读），要么输出（写）</p>\n<p>但是 Channel 是<strong>双向</strong>的，实现类如下</p>\n<ul>\n<li><code>FileChannel</code>：从文件中读写数据</li>\n<li><code>DatagramChannel</code>：通过 UDP 读写网络数据</li>\n<li><code>SocketChannel</code>：通过 TCP 读写网络数据</li>\n<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，就像 Web 服务器一样，对每一个新连接都会建立一个 <code>SocketChannel</code></li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>通道的<strong>操作是双向的</strong>（可以只读、可以只写、还可以读写）</li>\n<li>通道可以操作的数据种类很多（可以是文件 IO、网络 Socket 都可以操作）</li>\n<li>通道的操作是<strong>异步</strong>的</li>\n<li>不能直接访问通道，<strong>需要与 Buffer 合作</strong>（通道读必须从一个 Buffer 读、通道写必须写到一个 Buffer 内）</li>\n<li>通道<strong>不能复用</strong>！关闭了就没了</li>\n</ul>\n<p>具体在 Java 中，就是一个接口，有两个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Channel</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Closeable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//检测通道是否正常打开</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isOpen</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关闭这个通道：（如果通道关闭了，对这个通道的操作都会抛出异常）    </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"FileChannel\"><a href=\"#FileChannel\" class=\"headerlink\" title=\"FileChannel\"></a>FileChannel</h2><p>用来对<strong>文件</strong>进行操作的通道</p>\n<h3 id=\"获取FileChannel\"><a href=\"#获取FileChannel\" class=\"headerlink\" title=\"获取FileChannel\"></a>获取FileChannel</h3><p>获取 <code>FileChannel</code> 的方式：（不能 new 来获取，有<strong>三种获取方式</strong>）</p>\n<ul>\n<li>获取 <code>FileChannel</code> 可以使用 <code>RandomAccessFile</code> 这个类</li>\n<li>也可以使用 <code>InputStream</code>（这样创建的 FileChannel 只能读）</li>\n<li>也可以使用 <code>OutputStream</code>（这样创建的 FileChannel 只能写）</li>\n</ul>\n<h3 id=\"读到Buffer中\"><a href=\"#读到Buffer中\" class=\"headerlink\" title=\"读到Buffer中\"></a>读到Buffer中</h3><p><code>FileChannel</code> 读取数据到Buffer中</p>\n<ul>\n<li>通道的 <code>read()</code> 方法，<strong>必须读入到一个缓存中</strong>，而且会返回<strong>读取到的字节数</strong>（或者说是，缓冲区中的字节数有多少）</li>\n<li>需要在缓冲的 <code>buffer.hasRemaining()</code> 的循环中使用</li>\n<li>如果读完，会返回 - 1</li>\n</ul>\n<p>Demo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此文件有21字节，设置模式为读写均可</span></span><br><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 使用RandomAccessFile类的getChannel方法获得此文件的通道</span></span><br><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> rw.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关于buffer的内容先不做介绍，此处为分配一个大小为10字节的缓存</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通道的read方法会返回读取到的字节数，因为我的文件21字节，所以需要读三次</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次：10字节、第二次10字节、第三次1字节</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br><span class=\"line\"><span class=\"comment\">// 这一步是不会阻塞的！会继续向下执行</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (read != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;读取了：&quot;</span>+ read);</span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (buffer.hasRemaining())&#123;</span><br><span class=\"line\">        System.out.println((<span class=\"type\">char</span>)buffer.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buffer.clear();</span><br><span class=\"line\">    read = channel.read(buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rw.close();</span><br><span class=\"line\">channel.close();</span><br></pre></td></tr></table></figure>\n\n<p><strong>读文件大致Demo</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>))&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JDK7 新特性</span></span><br><span class=\"line\">    <span class=\"comment\">//在 try 的后边可以增加一个 ()，在括号中可以定义流对象，</span></span><br><span class=\"line\">    <span class=\"comment\">//那么这个流对象的作用域就在 try 有效，try 中的代码执行完毕，会把流对象自动释放，不用写 finally</span></span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">fc</span> <span class=\"operator\">=</span> rw.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> fc.read(bf);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bf.flip();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (bf.hasRemaining())&#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> bf.get();</span><br><span class=\"line\">            System.out.print((<span class=\"type\">char</span>) b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bf.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写到通道中\"><a href=\"#写到通道中\" class=\"headerlink\" title=\"写到通道中\"></a>写到通道中</h3><ul>\n<li>write方法，需要传入缓冲</li>\n<li>需要在缓冲的<code>buffer.hasRemaining()</code>的循环中使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> rw.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">15</span>);</span><br><span class=\"line\">buffer.clear();</span><br><span class=\"line\"><span class=\"type\">byte</span>[] bytes = <span class=\"string\">&quot;I love you too&quot;</span>.getBytes();</span><br><span class=\"line\">System.out.println(bytes.length);</span><br><span class=\"line\">buffer.put(bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">buffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (buffer.hasRemaining())&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> channel.write(buffer);</span><br><span class=\"line\">    <span class=\"comment\">// 返回写入的字节，与读取一样，并不能确定一次会写入多少字节</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以需要在循环内执行write方法，并且要用hasRemaining方法判断是否有剩余</span></span><br><span class=\"line\">    System.out.println(write);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭</span></span><br><span class=\"line\">channel.close();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><ul>\n<li><code>positon()</code>：返回从文件开头位置到当前位置的字节数</li>\n<li><code>position(long)</code>：设置当前位置（注意：如果指定的位置超过了文件当前的位置，然后进行了写入，会<strong>导致文件中间部分没有被写（文件空洞）</strong>）</li>\n<li><code>size()</code>：返回文件大小</li>\n<li><code>truncate(long)</code>：截取前指定大小的数据，后面的数据将会被删除</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> rw.getChannel();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> channel.position();</span><br><span class=\"line\"><span class=\"comment\">// 初始位置为 0</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> channel.size();</span><br><span class=\"line\">System.out.println(size);</span><br><span class=\"line\">channel.position(pos+size);</span><br><span class=\"line\"><span class=\"comment\">// 指定从什么位置开始，这里指定了当前位置+文件大小，就是文件的末尾开始写</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">30</span>);</span><br><span class=\"line\">buffer.put(<span class=\"string\">&quot; but she don&#x27;t fond of me&quot;</span>.getBytes());</span><br><span class=\"line\">buffer.flip();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (buffer.hasRemaining())&#123;</span><br><span class=\"line\">    channel.write(buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rw.close();</span><br><span class=\"line\">channel.close();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"force与RandomAccessFile\"><a href=\"#force与RandomAccessFile\" class=\"headerlink\" title=\"force与RandomAccessFile\"></a>force与RandomAccessFile</h3><ul>\n<li><code>force(boolean)</code> 方法：<ul>\n<li>此方法是为了<strong>保证对文件的所有更新操作都写回磁盘</strong></li>\n<li>参数为 <code>false</code> 表示只写回<strong>文件内容</strong></li>\n<li>参数为 <code>true</code> 表示既要写回<strong>文件内容</strong>，又要写回<strong>元数据信息</strong>（即文件的权限信息等）</li>\n</ul>\n</li>\n<li><code>RandomAccessFile(fileName, mode)</code>：传入一个文件的路径以及一个模式，此处的模式有四种<ul>\n<li><code>r</code>：只读，如果调用 write 会抛出异常</li>\n<li><code>rw</code>：可读可写；如果文件不存在，将会被创建</li>\n<li><code>rws</code>：可读可写，并且所有的更新操作每次都会被<strong>同步的写入磁盘</strong>，会<strong>写入文件内容以及元数据</strong>（即带有 <code>force(true)</code> 的 rw 模式）</li>\n<li><code>rwd</code>：可读可写，并且所有的更新操作每次都会被<strong>同步的写入磁盘</strong>，会<strong>写入文件内容</strong>（即带有 <code>force(false)</code> 的 rw 模式）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通道间通信\"><a href=\"#通道间通信\" class=\"headerlink\" title=\"通道间通信\"></a>通道间通信</h3><p>通道之间可以<strong>传输数据</strong>，这两个方法<strong>仅仅是方向不同而已</strong></p>\n<p>（通道之间传输数据没有用到缓存，不知道底层实现是否用到了缓存）</p>\n<ul>\n<li><code>transferFrom(ReadableByteChannel src, long position, long count)</code>：三个参数，第一个传入另外一个通道，第二个为起始位置，第三个传入想要传输的字节数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;d:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channelFrom</span> <span class=\"operator\">=</span> rw1.getChannel();</span><br><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">rw2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;d:\\\\temp2.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileChannel</span> <span class=\"variable\">channelTo</span> <span class=\"operator\">=</span> rw2.getChannel();</span><br><span class=\"line\"><span class=\"comment\">// 这样就将temp的文件写入到了temp2</span></span><br><span class=\"line\">channelTo.transferFrom(channelFrom, <span class=\"number\">0</span>, channelFrom.size());</span><br><span class=\"line\"><span class=\"comment\">// channelFrom.transferTo(0, channelFrom.size(), channelTo);</span></span><br><span class=\"line\"><span class=\"comment\">// 也可以这么实现，两个方法只不过是方向反了一下</span></span><br><span class=\"line\">channelFrom.close();</span><br><span class=\"line\">channelTo.close();</span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>transferTo</code> 方法是有上限的（最大为 2G，超过这个范围，那么只会传输 2g 的内容，剩下的数据就不会再传输了）</p>\n<p>可以这样实现传输大于 2g 的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">fc1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>).getChannel();</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">fc2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;D:\\\\temp1.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>).getChannel()</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 重点在这里：</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> fc1.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> size; left &gt; <span class=\"number\">0</span> ;) &#123;</span><br><span class=\"line\">        left -= fc1.transferTo(size-left, left, fc2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Socket通道\"><a href=\"#Socket通道\" class=\"headerlink\" title=\"Socket通道\"></a>Socket通道</h2><p>此处的 <strong>Socket 通道</strong>泛指了三个实现了 <code>AbstractSelectableChannel</code> 的类：<code>SocketChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code></p>\n<blockquote>\n<p>为什么引入Socket通道？</p>\n</blockquote>\n<p>传统的 <code>Socket</code> 会为每个 <code>Socket</code> 连接创建一个线程，但是 <strong>Socket 通道</strong>仅仅只开辟一个或几个线程就可以提供成百上千的服务，大大提高了性能！</p>\n<p>好处：</p>\n<p>1、节省了线程切换的上下文开销</p>\n<p>2、便于管理</p>\n<blockquote>\n<p>Socket 通道的特点</p>\n</blockquote>\n<ul>\n<li><p><code>ServerSocketChannel</code>只负责： （不负责读写）</p>\n<ol>\n<li>监听传入的连接</li>\n<li>创建 <code>SocketChannel</code> 对象</li>\n</ol>\n</li>\n<li><p><code>DatagramChannel</code>与<code>SocketChannel</code>负责真正的读写操作</p>\n<ul>\n<li>Socket 通道可以被<strong>重复使用</strong></li>\n</ul>\n</li>\n<li><p>Socket 通道可以设置为<strong>非阻塞模式</strong></p>\n</li>\n</ul>\n<h3 id=\"ServerSocketChannel\"><a href=\"#ServerSocketChannel\" class=\"headerlink\" title=\"ServerSocketChannel\"></a>ServerSocketChannel</h3><blockquote>\n<p>ServerSocketChannel：可以理解为一个<strong>实现了非阻塞模式的 ServerSocket</strong></p>\n</blockquote>\n<p>特点：</p>\n<ul>\n<li><code>socket()</code>：可以获得 <code>ServerSocket</code> 对象，然后调用其 <code>bind()</code> 方法去绑定一个端口（注意：<code>ServerSocketChannel</code> 本身<strong>没有 <code>bind</code> 方法</strong>！！（JDK1.7 有了 bind 方法，默认绑定本地地址））</li>\n<li><code>ServerSocketChannel</code> 有 <code>accept()</code> 方法，会返回一个 <code>SocketChannel</code> 对象；但是使用 <code>ServerSocket</code> 的 <code>accept()</code> 方法就还是阻塞的<ul>\n<li>如果返回的对象为 <code>null</code>，说明当前没有连接</li>\n</ul>\n</li>\n<li>因为继承了 <code>AbstractSelectableChannel</code> 类，所以可以设置为<strong>非阻塞模式</strong></li>\n</ul>\n<blockquote>\n<p>ServerSocketChannel 对象的创建：</p>\n</blockquote>\n<p>不能 new，需要调用 <code>ServerSocketChannel</code> 的静态方法 <code>open()</code></p>\n<blockquote>\n<p>核心API</p>\n</blockquote>\n<ul>\n<li><code>accepct()</code>：方法是阻塞方法（如果不设置为非阻塞）</li>\n<li><code>bind()</code>：绑定一个端口</li>\n<li><code>configureBlocking(boolean)</code>：默认为 true（阻塞模式）</li>\n</ul>\n<blockquote>\n<p>使用单线程 + Channel 实现服务器：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0. byteBuffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建服务器</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">ssc.configureBlocking(<span class=\"literal\">false</span>);<span class=\"comment\">// 设置为非阻塞模式</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定端口</span></span><br><span class=\"line\">ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3. 连接集合</span></span><br><span class=\"line\">ArrayList&lt;SocketChannel&gt; channels = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. SSC建立与客户端的连接，sc与客户端通信</span></span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();<span class=\"comment\">// 设置为非阻塞，不会再阻塞运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sc != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">        sc.configureBlocking(<span class=\"literal\">false</span>);<span class=\"comment\">// sc也设置为非阻塞</span></span><br><span class=\"line\">        channels.add(sc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 5. 遍历集合处理请求</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SocketChannel channel : channels) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(bf);<span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            bf.flip();</span><br><span class=\"line\">            readBuffer(bf);<span class=\"comment\">// 此方法简单的输出了一下buffer（模拟实际操作）</span></span><br><span class=\"line\">            bf.clear();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;after read...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>缺点：我们使用了死循环来一次次判断连接情况（这样也会浪费 CPU 的资源）</p>\n<p>因此有了 Selector 来解决这个问题（使用 Seletor 后，代码的逻辑会发生变化）</p>\n<h3 id=\"ScoketChannel\"><a href=\"#ScoketChannel\" class=\"headerlink\" title=\"ScoketChannel\"></a>ScoketChannel</h3><blockquote>\n<p>SocketChannel：用来连接到TCP套接字的通道</p>\n</blockquote>\n<p>特点：</p>\n<ul>\n<li>实现了<strong>可选择通道，可以被多路复用</strong></li>\n<li>基于 <strong>TCP 传输协议</strong></li>\n<li>支持两种模式：阻塞与非阻塞（同样也是通过 <code>configureBlocking</code> 调节）</li>\n</ul>\n<blockquote>\n<p>创建SocketChannel</p>\n</blockquote>\n<ul>\n<li><code>ServerSocket</code> 对象的 <code>accept</code> 方法会返回 <code>SocketChannel</code> 对象</li>\n<li>直接使用 <code>SocketChannel.open()</code> 也可以创建 SocketChannel 对象</li>\n</ul>\n<blockquote>\n<p>核心API</p>\n</blockquote>\n<ul>\n<li><code>configureBlocking(boolean)</code>：默认为 true（阻塞模式）</li>\n<li><code>read(ByteBuffer)</code>：读</li>\n<li><code>write(ByteBuffer)</code>：写</li>\n</ul>\n<h1 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h1><blockquote>\n<p>提供了一种选择执行已经就绪的任务的能力</p>\n</blockquote>\n<p>允许单线程处理多个通道，大大提高了效率</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>每个Channel都在Selector上注册</li>\n<li>注册后会返回一个选择键，选择键代表了当前通道是否已经就绪的信息</li>\n<li>每执行一次select方法，都会更新所有的选择键，然后选择一个已经就绪的通道</li>\n</ol>\n<p><img data-src=\"https://img.jyhmw.cn/image-20210920151712340.png\" alt=\"选择示意图\"></p>\n<p>注意：</p>\n<ul>\n<li>这些 Channel <strong>必须是 <code>SelectableChannel</code> 的子类</strong>（比如：<code>FileChannel</code> 就不是其子类，也就不能被选择）</li>\n</ul>\n<h2 id=\"有关的类\"><a href=\"#有关的类\" class=\"headerlink\" title=\"有关的类\"></a>有关的类</h2><ul>\n<li><code>Selector</code>：<strong>选择器类</strong>负责管理在此注册的通道的集合信息以及他们的就绪状态</li>\n<li><code>SelectableChannel</code>：<strong>可选择通道</strong>，是一个抽象类，继承这个类的类为可以进行选择的类（FileChannel 就没有继承这个类）</li>\n<li><code>SelectionKey</code>：选择键类，封装了通道与选择器之间的注册关系，含有两个比特集（一个代表注册关系所关心的通道操作，一个代表通道已经就绪的操作）</li>\n</ul>\n<h2 id=\"建立Selector系统\"><a href=\"#建立Selector系统\" class=\"headerlink\" title=\"建立Selector系统\"></a>建立Selector系统</h2><p><strong>创建 Selector</strong>：不能 new，需要调用 <code>Selector.open()</code> 方法</p>\n<p>2、<strong>设置通道为非阻塞</strong>（只有非阻塞的通道才能注册到选择器）</p>\n<p>3、<strong>通道注册</strong>：调用 <code>register(selector, OP)</code> 进行注册，两个参数，第一个为选择器，第二个参数为想让选择器关心的操作，会返回一个 <strong>SelectionKey 对象</strong></p>\n<p>此处可以设置的关心的操作 OP 有：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SelectionKey.OP_READ = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>; <span class=\"comment\">// 是否有可读的通道就绪</span></span><br><span class=\"line\">SelectionKey.OP_WRITE = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>; <span class=\"comment\">// 是否有可写的通道就绪</span></span><br><span class=\"line\">SelectionKey.OP_CONNECT = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>; <span class=\"comment\">// 是否有新的通道连接到服务器</span></span><br><span class=\"line\">SelectionKey.OP_ACCEPT = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>; <span class=\"comment\">// 是否有新的连接（只有ServerSocketChannel有这个操作）</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们想要关心多个操作，可以通过 <code>|</code> 位或运算符将 OP 连接起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE)</span><br></pre></td></tr></table></figure>\n\n<p>4、<strong>select () 轮询</strong>：查看是否有就绪的通道，会返回当前就绪通道的数量</p>\n<h2 id=\"Selector三个集合\"><a href=\"#Selector三个集合\" class=\"headerlink\" title=\"Selector三个集合\"></a>Selector三个集合</h2><ul>\n<li><code>keys()</code>：此集合保存<strong>已注册的键</strong>（此集合不能修改！）</li>\n<li><code>selectedKeys()</code>：此集合保存关心事件发生的键，此集合我们只能移除，不能添加（添加是自动进行的）<ul>\n<li>注意这个集合的<strong>特点</strong>：会自动添加集合，但是不会自动删除集合</li>\n<li>因此我们在处理<strong>完成后要主动 <code>remove</code> 掉</strong>，要不然会报异常</li>\n</ul>\n</li>\n<li>已取消键的集合，使用 <code>cancel()</code> 方法后的键都会放在这里</li>\n</ul>\n<blockquote>\n<p>Selector 的核心就是 <code>select</code> 方法，它的执行过程为：</p>\n</blockquote>\n<ol>\n<li><strong>检查已取消集合</strong>：如果集合非空，就将集合内所有的键从另外两个集合中移除，然后注销其相关的通道</li>\n<li><strong>检查 selectedKeys 集合</strong>：确定每个通道所关心的操作是否已经就绪</li>\n<li><strong>返回值</strong>：返回上一次调用 select 后进入就绪状态的通道的数量</li>\n</ol>\n<h2 id=\"SelectionKey\"><a href=\"#SelectionKey\" class=\"headerlink\" title=\"SelectionKey\"></a>SelectionKey</h2><blockquote>\n<p>选择键： 表示<strong>通道与 Selector 之间的注册关系</strong>，注册一个通道就会返回一个 SelectionKey</p>\n</blockquote>\n<p>相关 API：</p>\n<ul>\n<li><code>channel</code>：返回对应的通道</li>\n<li><code>selector</code>：返回通道注册的选择器</li>\n<li><code>cancel</code>：取消注册关系</li>\n<li><code>isValid()</code>：判断注册关系是否有效</li>\n<li><code>interestOps()</code>：以整数的形式，返回所关心操作的 bit 掩码，可以用此来判断选择器是否关心通道的某个操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Boolean</span> <span class=\"variable\">isAccept</span> <span class=\"operator\">=</span> interestOps &amp; SelectionKey.OP_ACCEPT == SelectionKey.OP_ACCEPT;</span><br><span class=\"line\"><span class=\"comment\">// 判断一下与的结果是否与Accept相等</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>isAccept()</code> 等操作：上面的这种方式判断太麻烦了，API 直接就有相关判断方法</li>\n</ul>\n<h2 id=\"关于Selector\"><a href=\"#关于Selector\" class=\"headerlink\" title=\"关于Selector\"></a>关于Selector</h2><blockquote>\n<p>select 方法什么时候会不阻塞，向下执行？</p>\n</blockquote>\n<p>总共用如下几种情况：</p>\n<ol>\n<li>发生事件时<ul>\n<li>客户端发起连接请求，触发 accept 事件</li>\n<li>客户端发送数据、正常关闭、异常关闭都会触发 read 事件</li>\n<li>如果要发送的数据大于缓冲区，会触发多次 read 事件</li>\n<li>channel 可写，触发 write 事件</li>\n<li>在 Linux 下 nio bug 发生时</li>\n</ul>\n</li>\n<li>调用 <code>selector.wakeup()</code></li>\n<li>调用 <code>selector.close()</code></li>\n<li>selector 所在线程 <code>interrupt</code></li>\n</ol>\n<blockquote>\n<p>事件可以不处理吗？</p>\n</blockquote>\n<p>不可以，事件要么就 <code>remove</code>，要么就 <code>cancel</code>，不可以不进行处理</p>\n<p>如果不进行处理，<code>select</code> 每次都会返回这个事件，白白浪费 CPU 的资源</p>\n<blockquote>\n<p>用完 key 为什么要 remove？</p>\n</blockquote>\n<p>elector 维护的集合 SelectedKeys 添加是自动的，删除需要我们手动进行，一旦有我们关心的事件发生，那么 Selector 就会将此 key 添加到这个集合内</p>\n<p> 如果我们用完 key，没有 remove，那么此集合内就还会存在这个 key，在使用这个 key 进行操作的时候，就可能会出现异常（比如空指针异常）</p>\n<p>注意：remove 只是将这个集合内的该键删除了，如果对应的事件还会继续发生，那么这里光删除集合内的 key 是没有用的，应该 cancel 掉对应的事件</p>\n<blockquote>\n<p>处理read事件要注意的事情</p>\n</blockquote>\n<p>【一】处理好客户端的正常与异常断开</p>\n<p>正常断开依靠 read 方法返回值</p>\n<p>异常断开依靠 catch 抓住异常后，将此 key 取消掉</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class=\"line\">    int read = channel.read(buffer);//如果客户端正常断开，这里会返回-1</span><br><span class=\"line\">    // 【处理客户端正常断开】</span><br><span class=\"line\">    if(read == -1)&#123;</span><br><span class=\"line\">        key.cancel();</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;catch (IOException e)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    // 【处理客户端异常断开】</span><br><span class=\"line\">    key.cancel();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>【二】处理好<strong>消息边界</strong></p>\n<p>例如我们开辟一块 <code>buffer</code> 为 4 字节的缓冲区，客户端传输两个汉字 “中国”，默认字符集 UTF-8 对于 1 个汉字占用 3 个字节，就要处理好消息边界的问题！</p>\n<p>（如何解决消息边界问题下一节详细介绍）</p>\n<blockquote>\n<p>处理write事件要注意的事情</p>\n</blockquote>\n<p>我们发送的数据可能不是一次性发送的！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class=\"line\"><span class=\"comment\">//【1】 write不能保证一次性就将所有的数据写入，有一个返回值，表示实际写入的字节数</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (buffer.hasRemaining())&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 【2】返回值代表一次性可以发送的位数</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里一次性可以发送多少，涉及到了OS对于TCP的发送缓存与接收缓存的实现</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> sc.write(buffer);</span><br><span class=\"line\">    System.out.println(write);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样处理虽然可以保证数据全部发完，但是<strong>不符合 NIO 非阻塞的思想</strong></p>\n<p>好的处理方式应该是，如果我们一次性发不完，可以先去处理其他事情（避免一直发送导致发送缓冲区满，导致轮询）</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    selector.select();</span><br><span class=\"line\">    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">            sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"type\">SelectionKey</span> <span class=\"variable\">scKey</span> <span class=\"operator\">=</span> sc.register(selector, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 向客户端发送消息</span></span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">30000</span>; i++) &#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">            sc.write(buffer);</span><br><span class=\"line\">            <span class=\"comment\">//【1】 一次发送完最好</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (buffer.hasRemaining())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//【2】 如果发送不完，就关注写事件</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意：要拿到原本关注的事件再|上此事件（+ |都可以）</span></span><br><span class=\"line\">                scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE);</span><br><span class=\"line\">                <span class=\"comment\">//【3】把没有写完的数据写回，利用附件的形式</span></span><br><span class=\"line\">                scKey.attach(buffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 【4】从附件取出，继续写</span></span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">            sc.write(buffer);</span><br><span class=\"line\">            <span class=\"comment\">// 【5】如果此次还没有写完，由于我们已经关注了可写事件，所以下一次会继续写</span></span><br><span class=\"line\">            <span class=\"comment\">// 【6】清理操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!buffer.hasRemaining())&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 清掉附件</span></span><br><span class=\"line\">                key.attach(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 去掉关注的事件</span></span><br><span class=\"line\">                key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理消息边界\"><a href=\"#处理消息边界\" class=\"headerlink\" title=\"处理消息边界\"></a>处理消息边界</h2><blockquote>\n<p>比如粘包问题</p>\n</blockquote>\n<h3 id=\"异常情况\"><a href=\"#异常情况\" class=\"headerlink\" title=\"异常情况\"></a>异常情况</h3><blockquote>\n<p>消息边界：发送一个消息可能有三种异常情况</p>\n</blockquote>\n<ol>\n<li>buffer的大小不足以放下一个完整的消息。<ul>\n<li>这种情况下，<strong>只能将 buffer 扩容</strong></li>\n</ul>\n</li>\n<li><code>buffer</code> 空间足够，但是只放了 1.5 个消息，剩下的半个消息我们需要进行拼接（在 Buffer 一节，我们介绍了一个利用 <code>\\n</code> 来截断消息的步骤）</li>\n</ol>\n<blockquote>\n<p>如果 buffer 空间不足（即一条消息的大小就超过了 buffer），nio 是如何进行处理的呢？</p>\n</blockquote>\n<p>例如：buffer 空间为 8 字节，传输一条 10 字节的消息</p>\n<p>服务器收到 read 事件，将数据读到 8 字节的缓存中，然后打印输出</p>\n<p>然后，服务器会再次收到 read 事件，将剩下 2 个字节读入，打印输出</p>\n<p>（即：服务器会变为<strong>多次 read 事件读取消息</strong>，因此对于这种情况我们需要扩容）</p>\n<h3 id=\"如何扩容buffer\"><a href=\"#如何扩容buffer\" class=\"headerlink\" title=\"如何扩容buffer\"></a>如何扩容buffer</h3><blockquote>\n<p>buffer 不能是局部变量</p>\n</blockquote>\n<p>最开始我们的代码是这样的，但是如果我们想要给一个 buffer 扩容，buffer 就不能是一个局部变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//收到read事件</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里的buffer是局部变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        key.cancel();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        spilt(buffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    key.cancel();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>那么，不能是局部变量，我提到最外面可以不可以呢？</p>\n</blockquote>\n<p>不可以，我们要<strong>保证一个线程的 buffer 是私有的</strong>，如果我们提到最外面，那么多个线程操控一个 buffer，这就乱套了（线程不安全）</p>\n<p>因此我们要借助<strong>附件 attachment</strong></p>\n<blockquote>\n<p>注意：<strong>附件可以保证每一个线程间是私有的</strong></p>\n</blockquote>\n<p><code>regiser()</code> 传入的第三个参数就是附件，如果要获取附件，可以调用 key 的 <code>attachment()</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//6.1、accept事件</span></span><br><span class=\"line\">    <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> channel.accept();</span><br><span class=\"line\">    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 【1】将buffer以附件的形式存放到key中</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">scKey</span> <span class=\"operator\">=</span> sc.register(selector, <span class=\"number\">0</span>, buffer);</span><br><span class=\"line\">    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;sc: &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//6.2、read事件</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">        <span class=\"comment\">// 【2】从附件中获取buffer</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(byteBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            key.cancel();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            spilt(byteBuffer);</span><br><span class=\"line\">            byteBuffer.flip();</span><br><span class=\"line\">            readBuffer(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        key.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>什么时候进行扩容呢？</p>\n</blockquote>\n<p>当然是 buffer 空间不够的时候，之前我们自己实现的 <code>split()</code> 方法最后是使用的 <code>compact()</code> 方法去完成拼接</p>\n<p>如果一个消息大于 buffer，那么他的 <code>\\n</code> 的索引依然会大于 limit</p>\n<p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">buffer大小8字节</span><br><span class=\"line\">传输一个数据：0123456789\\n（11字节）</span><br><span class=\"line\">-----------------&gt;</span><br><span class=\"line\">执行spilt()方法，最后buffer内的数据为01234567，此时position为8，limit也为8</span><br></pre></td></tr></table></figure>\n\n<p>因此，扩容的时机就是 <code>position==limit</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\"><span class=\"comment\">// 从附件中获取buffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(byteBuffer);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    key.cancel();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    System.out.println(byteBuffer);</span><br><span class=\"line\">    <span class=\"comment\">// 【1】判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(byteBuffer.position() == byteBuffer.limit())&#123;</span><br><span class=\"line\">        <span class=\"comment\">//【2】 分配一个double容量的buffer</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">newByteBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(byteBuffer.capacity() * <span class=\"number\">2</span>);</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        newByteBuffer.put(byteBuffer);<span class=\"comment\">//【3】 copy</span></span><br><span class=\"line\">        key.attach(newByteBuffer);<span class=\"comment\">// 【4】替换原有的byteBuffer</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样两次 read 事件，就能把消息拼接到一起了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">buffer大小<span class=\"number\">8</span>字节</span><br><span class=\"line\">传输一个数据：0123456789\\n（<span class=\"number\">11</span>字节）</span><br><span class=\"line\">---------解释---------</span><br><span class=\"line\">【第一次read事件】：</span><br><span class=\"line\">执行spilt()方法</span><br><span class=\"line\">buffer1内的数据：<span class=\"number\">01234567</span></span><br><span class=\"line\">此时position=<span class=\"number\">8</span>, limit = <span class=\"number\">8</span> </span><br><span class=\"line\">因此创建buffer2，容量为<span class=\"number\">8</span>*<span class=\"number\">2</span>字节，并放入附件中</span><br><span class=\"line\">【第二次read事件】：</span><br><span class=\"line\">buffer2数据为：<span class=\"number\">01234567</span></span><br><span class=\"line\">spilt()将<span class=\"number\">89</span>\\n拼接到buffer2</span><br><span class=\"line\">此时buffer2数据为：0123456789\\n</span><br></pre></td></tr></table></figure>\n\n<p>此处我们的扩容简单的进行了翻倍扩容，这是比较简单的实现，在 Netty 中，就设计的比较优秀了，此处我们只是抛砖引玉</p>\n<blockquote>\n<p>buffer 大小如何抉择有两种思路：</p>\n</blockquote>\n<p>ByteBuffer 需要设计为可变的 buffer：</p>\n<ul>\n<li>思路一：首先分配一个较小的 buffer，如果不够用，再分配一个更大的 buffer，并将原本的 buffer 数据 copy 到新 buffer 内<ul>\n<li>优点：消息连续好处理</li>\n<li>缺点：数据 copy 消耗性能</li>\n</ul>\n</li>\n<li>思路二：用多个数组组成 buffer，一个数组不够，就将多出来的内容写入新的数组<ul>\n<li>优点：避免了 copy 消耗性能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NIO服务器Demo\"><a href=\"#NIO服务器Demo\" class=\"headerlink\" title=\"NIO服务器Demo\"></a>NIO服务器Demo</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1、创建Selector对象</span></span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"comment\">//2、注册ssc，返回SelectionKey对应关系</span></span><br><span class=\"line\">        <span class=\"type\">SelectionKey</span> <span class=\"variable\">sscKey</span> <span class=\"operator\">=</span> ssc.register(selector, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//3、SelectionKey设置关心的操作</span></span><br><span class=\"line\">        sscKey.interestOps(SelectionKey.OP_ACCEPT);<span class=\"comment\">// 这个键只关心其ACCEPT事件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//4、调用select方法，如果没有事件发生，是阻塞的！如果有事件才会恢复执行</span></span><br><span class=\"line\">            selector.select();</span><br><span class=\"line\">            <span class=\"comment\">//5、处理事件（因为我们涉及到删除，所以要用迭代器遍历）</span></span><br><span class=\"line\">            <span class=\"comment\">//   注意：事件必须要处理，要么remove要么cancel，要不然select会一直有这个事件，浪费CPU资源</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class=\"line\">                <span class=\"comment\">// 7、要记得删除此事件！可以一开始就删，也可以最后再删除</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里一开始就删除了，特别强调！！一定要删除</span></span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                <span class=\"comment\">// 6、区分时间类型进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//6.1、accept事件</span></span><br><span class=\"line\">                    <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> channel.accept();</span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 将buffer以附件的形式存放到key中</span></span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">scKey</span> <span class=\"operator\">=</span> sc.register(selector, <span class=\"number\">0</span>, buffer);</span><br><span class=\"line\">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;sc: &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//6.2、read事件</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"comment\">// 从附件中获取buffer</span></span><br><span class=\"line\">                        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(byteBuffer);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(byteBuffer);</span><br><span class=\"line\">                            <span class=\"comment\">// 判断是否需要扩容</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(byteBuffer.position() == byteBuffer.limit())&#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 分配一个double容量的buffer</span></span><br><span class=\"line\">                                <span class=\"type\">ByteBuffer</span> <span class=\"variable\">newByteBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(byteBuffer.capacity() * <span class=\"number\">2</span>);</span><br><span class=\"line\">                                byteBuffer.flip();</span><br><span class=\"line\">                                newByteBuffer.put(byteBuffer);<span class=\"comment\">// copy</span></span><br><span class=\"line\">                                key.attach(newByteBuffer);<span class=\"comment\">// 替换原有的byteBuffer</span></span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//6.3、write事件</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readBuffer</span><span class=\"params\">(ByteBuffer bf)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> bf.position(); i &lt; bf.limit(); i++) &#123;</span><br><span class=\"line\">            System.out.print((<span class=\"type\">char</span>) bf.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">spilt</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">        source.flip();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;<span class=\"comment\">// 带索引的get方法不会改变position的值</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span> - source.position();</span><br><span class=\"line\">                <span class=\"comment\">// 计算要分配的缓冲长度</span></span><br><span class=\"line\">                <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(len);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">                    target.put(source.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        source.compact();</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里不能用clear</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多线程优化\"><a href=\"#多线程优化\" class=\"headerlink\" title=\"多线程优化\"></a>多线程优化</h2><h3 id=\"如何优化\"><a href=\"#如何优化\" class=\"headerlink\" title=\"如何优化\"></a>如何优化</h3><p>前面我们都是使用单线程，即将所有的事件全部放在一个线程内进行操作，不能发挥多线程的优势</p>\n<p>所以我们可以进行<strong>多线程优化</strong>：（这也是 Netty 的实现原则）</p>\n<blockquote>\n<p>优化的手段</p>\n</blockquote>\n<p>可以将 ACCEPT 请求与读写请求分开，如图：</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20211005142906453.png\" alt=\"多线程优化\"></p>\n<p>有两类线程：</p>\n<ul>\n<li>boss 线程：专门负责处理 <code>ACCEPT</code> 事件</li>\n<li>worker 线程：处理 <code>READ</code> 与 <code>WRITE</code> 事件</li>\n</ul>\n<p>boss 线程只有一个，而 worker 线程可以根据服务器的 CPU 核心数来确定，并且可以加入负载均衡策略，让每一个 worker 线程一起出力。</p>\n<blockquote>\n<p>优化手段总结：</p>\n</blockquote>\n<p>1、按事件分类，分给不同的线程执行</p>\n<p>2、worker 间实现负载均衡</p>\n<h3 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h3><p>boss 线程一开始就有，worker 线程是慢慢创建的，具体的逻辑如下</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20211005143453665.png\" alt=\"实现逻辑\"></p>\n<p>值得注意的是：要让 <code>select</code> 与注册全让 <code>worker</code> 线程来执行，通过<strong>消息队列 +<code>wakeup()</code> 方法</strong> 来进行传输消息（即我标为黄色的部分）</p>\n<p>这样可以避免出现执行顺序不正确带来的顺序问题。</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiThreadServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// boss负责管理连接事件</span></span><br><span class=\"line\">        Thread.currentThread().setName(<span class=\"string\">&quot;boss&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        <span class=\"type\">SelectionKey</span> <span class=\"variable\">bossKey</span> <span class=\"operator\">=</span> ssc.register(boss, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8888</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1、创建固定数量的worker并初始化</span></span><br><span class=\"line\">        Worker[] workers = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>[Runtime.getRuntime().availableProcessors()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class=\"line\">            workers[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">&quot;worker-&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            boss.select();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                <span class=\"comment\">// ACCEPT事件</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connected...&#123;&#125;&quot;</span>, sc.getRemoteAddress());</span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//2、关联selector</span></span><br><span class=\"line\">                    <span class=\"comment\">// 轮流使用worker，达到负载均衡</span></span><br><span class=\"line\">                    workers[index.getAndIncrement() % workers.length].initial(sc);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Worker类负责读写操作</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;<span class=\"comment\">//保证只创建一个</span></span><br><span class=\"line\">        <span class=\"comment\">// 作为消息队列，让boss线程给worker线程传消息</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化线程和selector</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initial</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!start) &#123;</span><br><span class=\"line\">                thread = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">                selector = Selector.open();</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                thread.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue.add(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClosedChannelException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            selector.wakeup();</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒selector，让其可以将READ事件注册</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    selector.select(); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">                    <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (task != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                        <span class=\"comment\">// 真正是在这里执行了注册方法  sc.register(selector, SelectionKey.OP_READ, null);</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                        iterator.remove();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">                            <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                            <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                                key.cancel();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;&#123;&#125; executing...&quot;</span>, name);</span><br><span class=\"line\">                            <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">                                System.out.print((<span class=\"type\">char</span>) buffer.get());</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            buffer.clear();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"零拷贝（未完）\"><a href=\"#零拷贝（未完）\" class=\"headerlink\" title=\"零拷贝（未完）\"></a>零拷贝（未完）</h2>","categories":["技术栈","NIO"],"tags":["Java","NIO","异步"]},{"title":"Netty","url":"/2024/05/30/Netty/","content":"<h1 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h1><h2 id=\"Netty概述\"><a href=\"#Netty概述\" class=\"headerlink\" title=\"Netty概述\"></a>Netty概述</h2><blockquote>\n<p>Netty是什么？</p>\n<p>Netty是一个基于Java NIO的网络编程框架，提供了一套高效的、事件驱动的异步网络通信机制。简化了网络应用程序的开发过程，提供了可靠的、高性能的网络传输。</p>\n</blockquote>\n<h2 id=\"Netty的特点？\"><a href=\"#Netty的特点？\" class=\"headerlink\" title=\"Netty的特点？\"></a>Netty的特点？</h2><blockquote>\n<p>什么是事件驱动？<br>事件驱动的方式是一种<strong>编程范式</strong>，其中程序的执行流程是由外部事件（如用户操作、传感器变化、消息传递等）触发的，而不是由程序内部的逻辑顺序控制。在事件驱动的架构中，程序的控制权在不同的时间点由不同的事件处理程序来管理。以下是事件驱动编程的几个关键特点：</p>\n<ol>\n<li><strong>非阻塞性</strong>：程序不会在等待某个操作完成时阻塞，而是可以继续执行其他任务或等待其他事件。</li>\n<li><strong>异步处理</strong>：事件的产生和处理是分开的，事件可以在没有即时响应的情况下被处理。</li>\n<li><strong>回调机制</strong>：当一个事件发生时，通常会调用一个回调函数或触发一个事件处理器来处理该事件。</li>\n<li><strong>松耦合</strong>：事件的产生者和消费者之间是松散耦合的，它们不需要直接相互了解。</li>\n<li><strong>可扩展性</strong>：系统可以通过添加更多的事件处理器来响应不同类型的事件，从而提高系统的可扩展性。</li>\n<li><strong>响应性</strong>：系统可以快速响应用户的输入或其他外部事件，提供更加流畅的用户体验。</li>\n<li><strong>状态管理</strong>：事件驱动的程序通常需要维护状态信息，以便在事件发生时做出正确的响应。</li>\n</ol>\n<p>在事件驱动的编程模型中，通常会有一个事件循环（event loop），它不断地检查事件队列，当检测到事件时，它会从队列中取出事件并分派给相应的事件处理器。这种方式在很多现代应用程序中非常普遍，特别是在需要处理大量并发操作的网络应用和用户界面编程中。</p>\n<p>例如，在Web开发中，服务器可能会使用事件驱动的方式来处理多个客户端请求，而在图形用户界面（GUI）编程中，应用程序会响应用户的点击、滚动和其他交互操作。Netty 框架就是基于事件驱动模型来构建高性能网络应用的一个例子。</p>\n</blockquote>\n<ol>\n<li>异步和事件驱动：Netty使用异步的、非阻塞的I&#x2F;O模型，通过事件驱动的方式处理网络操作。Netty能够高效地处理并发连接和大量的并发请求。</li>\n<li>高性能：Netty采用了一系列优化策略，如零拷贝技术、内存池和可定制的线程模型等，以提供出色的性能和吞吐量。能处理高负载和大规模并发</li>\n<li>多协议支持：Netty提供了丰富的协议支持，包括常用的网络协议（如HTTP、WebSocket、TCP和UDP）以及自定义协议。具备灵活的编解码器和处理器，简化了协议的实现和交互。</li>\n<li>可扩展和灵活：Netty的架构和组件设计具有高度的可扩展性和灵活性。它提供了一组可重用的组件，可以根据应用需求进行定制和扩展。</li>\n<li>安全性：Netty提供了强大的安全性支持，包括SSL&#x2F;TLS的集成、加密和认证等机制，可以保护网络通信的安全性。</li>\n<li>易于使用和学习：提供了清晰简洁的API和文档，易于使用和学习。它还具有丰富的示例和教程，帮助开发人员快速上手和构建可靠的网络应用。</li>\n</ol>\n<p>这里又联系到<strong>NIO</strong>的知识</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240530103823306.png\" alt=\"image-20240530103823306\"></p>\n<h2 id=\"Netty核心组件\"><a href=\"#Netty核心组件\" class=\"headerlink\" title=\"Netty核心组件\"></a>Netty核心组件</h2><ol>\n<li>BootStrap（启动类）<br>用于启动和配置网络应用程序配置类。通过Bootstrap可以绑定启动IP、端口，配置EventLoopGroup、选择传输协议（Channel）、配置ChannelHandler、参数调优设置等。Bootstrap通常与ServerBootstrap配合使用。ServerBootstrap用于服务端，Bootstrap用于客户端。</li>\n<li>EventLoop（事件循环）<br>Netty为了避免线程与线程之间产生并发冲突，采用的策略。负责处理所有的I&#x2F;O事件，如接收连接、读取数据、写入数据等。EventLoop在一个线程中循环执行，通过事件驱动的方式处理事件。一个EventLoop可以关联一个或多个Channel，但一个Channel只能关联一个EventLoop。EventLoop通常在服务端需要实例化2个对象，一个用于接受处理客户端的连接请求，另一个用户处理I&#x2F;O读写事件。</li>\n<li>Channel（通道）<br>一个与实际数据传输相关的连接。可以理解为数据在客户端和服务器之间的通道。Channel提供了异步的I&#x2F;O操作，如读取、写入和关闭等。</li>\n<li>ChannelHandler（通道处理器）<br>最核心的组件之一，负责处理输入输出数据的逻辑。可以接收入站事件（如数据接收）和出站事件（如数据发送），并执行相应的处理逻辑。ChannelHandler被添加到ChannelPipeline中，形成处理链。</li>\n<li>ChannelHandlerContext（通道处理器上下文）<br>ChannelHandler的上下文环境。包含与ChannelHandler相关联的各种信息，如Channel、EventLoop、ChannelPipeline等。ChannelHandlerContext提供了丰富的方法，以便于ChannelHandler与其他组件进行交互。例如：区分谁是入站、出站就需要ChannelHandlerContext来维护管理</li>\n<li>ChannelPipeline（通道管道）<br>ChannelPipeline是一个双向链表，拦截和处理事件的链式结构。ChannelPipeline中的ChannelHandler是一个传播链，ChannelPipeline管理ChannelHandler并协调它们的处理顺序。当数据通过Channel时，它会依次经过每个ChannelHandler进行处理。<br>ChannelPipeline还提供了方便的操作方法，如添加、移除和替换ChannelHandler。<br>Channel与ChannelPipeline组成关系：一个Channel 包含了一个ChannelPipeline,而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。</li>\n<li>ByteBuf（字节缓冲区）<br>数据传输的基本单元，用于处理二进制数据的数据结构。ByteBuf提供了灵活的API，可以高效地读取、写入和操作数据。</li>\n<li>Codec（编解码器）<br>用于处理数据的编码和解码的组件。Netty提供了一系列的编解码器，可以帮助开发者简化数据的编解码过程。常见的编解码器有字符串编解码器、对象序列化编解码器等。</li>\n<li>ChannelFuture<br>异步操作的结果，例如连接的建立和关闭等。ChannelFuture提供了丰富的方法，用于检查操作的状态、添加监听器以便在操作完成时接收通知，并对操作的结果进行处理。</li>\n<li>ChannelOption（通道选项）<br>调优参数，可对Netty高并发的情况下进行调优。</li>\n</ol>\n<h2 id=\"Netty核心组件运转流程\"><a href=\"#Netty核心组件运转流程\" class=\"headerlink\" title=\"Netty核心组件运转流程\"></a>Netty核心组件运转流程</h2><ol>\n<li>客户端启动<ul>\n<li>创建 <code>Bootstrap</code> 实例，并配置 EventLoopGroup、Channel 类型和处理器。</li>\n<li><code>EventLoopGroup</code> 是一个线程池，由多个 <code>EventLoop</code> 组成，用于处理网络事件。</li>\n<li><code>EventLoop</code> 是 Netty 的核心组件之一，它负责处理所有的 I&#x2F;O 事件，包括接收连接、读取数据、写入数据等。</li>\n<li><code>Bootstrap</code> 负责引导客户端启动，它会将连接请求交给 <code>EventLoopGroup</code> 处理。</li>\n<li>调用 <code>bootstrap.connect()</code> 发起连接请求。</li>\n<li><code>EventLoopGroup</code> 选择一个 <code>EventLoop</code> 来处理连接请求，并与服务端建立连接。</li>\n<li>当连接成功建立时，<code>ChannelFuture</code> 的回调方法被触发。</li>\n</ul>\n</li>\n<li>服务端启动<ul>\n<li>创建 <code>ServerBootstrap</code> 实例，并配置 EventLoopGroup、Channel 类型和处理器。</li>\n<li><code>EventLoopGroup</code> 是一个线程池，由多个 <code>EventLoop</code> 组成，用于处理网络事件。</li>\n<li><code>EventLoop</code> 是 Netty 的核心组件之一，它负责处理所有的 I&#x2F;O 事件，包括接收连接、读取数据、写入数据等。</li>\n<li><code>ServerBootstrap</code> 负责引导服务端启动，它会将连接请求交给 <code>EventLoopGroup</code> 处理。</li>\n<li>调用 <code>serverBootstrap.bind()</code> 绑定服务器端口。</li>\n<li><code>EventLoopGroup</code> 选择一个 <code>EventLoop</code> 来处理绑定操作，并开始监听绑定的端口。</li>\n<li>当绑定成功时，<code>ChannelFuture</code> 的回调方法被触发。</li>\n</ul>\n</li>\n<li>连接建立<ul>\n<li>当客户端与服务端成功建立连接时，由 <code>EventLoop</code> 处理连接事件。</li>\n<li><code>EventLoop</code> 会创建一个 <code>Channel</code> 对象来表示连接，该对象维护了与连接相关的状态和属性。</li>\n<li>在客户端和服务端的 <code>ChannelHandler</code> 中的 <code>channelActive()</code> 方法会被调用。</li>\n<li>在客户端，该方法可以用于发送首次请求或认证信息。</li>\n<li>在服务端，该方法可以用于记录连接日志、管理连接数等操作。</li>\n</ul>\n</li>\n<li>数据传输<ul>\n<li>客户端通过 <code>channel.writeAndFlush()</code> 发送数据到服务端。</li>\n<li><code>EventLoop</code> 监听到写事件，并将数据发送给对应的 <code>Channel</code>。</li>\n<li><code>ChannelPipeline</code> 是 Netty 的另一个核心组件，它由一系列的 <code>ChannelHandler</code> 组成，用于处理入站和出站数据。</li>\n<li>在服务端的 <code>ChannelHandler</code> 中的 <code>channelRead0()</code> 方法接收并处理客户端发送的数据。</li>\n<li>服务端可以对接收到的数据进行处理，并根据业务逻辑选择将响应数据发送给特定客户端或广播给所有客户端。</li>\n<li>在客户端的 <code>ChannelHandler</code> 中的 <code>channelRead()</code> 方法接收到服务端发送的数据。</li>\n<li>客户端可以对接收到的数据进行处理，例如打印到控制台或进行其他操作。</li>\n</ul>\n</li>\n<li>数据处理<ul>\n<li>接收到的数据在 <code>ChannelHandler</code> 中被处理。</li>\n<li>在服务端和客户端的 <code>ChannelHandler</code> 中，可以进行数据解码、编码、业务逻辑处理等操作。</li>\n<li>可以使用内置的解码器和编码器，如 <code>StringDecoder</code> 和 <code>StringEncoder</code> 来处理字符串数据的解码和编码。</li>\n<li>自定义的 <code>ChannelHandler</code> 可以根据具体的业务需求进行数据处理。</li>\n</ul>\n</li>\n<li>数据发送<ul>\n<li>服务端通过 <code>ChannelGroup</code> 将响应数据发送给特定客户端或广播给所有客户端。</li>\n<li><code>ChannelGroup</code> 是一个用于管理多个 <code>Channel</code> 的容器，可以对其中的 <code>Channel</code> 进行批量操作。</li>\n<li>客户端通过 <code>channel.writeAndFlush()</code> 发送数据到服务端。</li>\n</ul>\n</li>\n<li>连接关闭<ul>\n<li>当连接关闭时，由 <code>EventLoop</code> 处理连接关闭事件。</li>\n<li>在客户端和服务端的 <code>ChannelHandler</code> 中的 <code>channelInactive()</code> 方法会被调用。</li>\n<li>在客户端，该方法可以用于重新连接服务器或执行一些清理操作。</li>\n<li>在服务端，该方法可以用于记录连接关闭日志、管理连接数等操作。</li>\n</ul>\n</li>\n<li>优雅关闭<ul>\n<li>在客户端和服务端关闭时，需要执行优雅关闭的操作，释放资源。</li>\n<li>调用 <code>group.shutdownGracefully()</code> 关闭 <code>EventLoopGroup</code>。</li>\n<li>这将释放所有的线程和资源，并确保所有的连接都已关闭。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Netty应用场景\"><a href=\"#Netty应用场景\" class=\"headerlink\" title=\"Netty应用场景\"></a>Netty应用场景</h2><p>Netty应用于构建高性能、可扩展的网络应用程序。例如分布式开源框架doubbo、zookeeper、rocketmq底层rpc通讯使用都是Netty。</p>\n<ul>\n<li>服务器和客户端之间的实时通信，如聊天服务器、游戏服务器等。</li>\n<li>高性能的服务器，如Web服务器、代理服务器等。</li>\n<li>分布式系统之间的通信，如分布式缓存、消息队列等。</li>\n</ul>\n<h2 id=\"Netty的高并发高性能架构设计精髓\"><a href=\"#Netty的高并发高性能架构设计精髓\" class=\"headerlink\" title=\"Netty的高并发高性能架构设计精髓\"></a>Netty的高并发高性能架构设计精髓</h2><ol>\n<li>主从Reactor线程模型：采用主从Reactor线程模型，其中包括一个主线程组负责接收客户端连接，多个从线程组负责处理客户端请求。这种设计利用多线程的优势实现了并发处理，提高了系统的吞吐量和响应性能。</li>\n<li>NIO多路复用非阻塞：Netty使用Java的NIO（Non-blocking I&#x2F;O）机制，基于Selector实现了多路复用的非阻塞I&#x2F;O操作。这种方式使得单个线程可以同时处理多个连接的I&#x2F;O事件，避免了阻塞等待，提高了系统的并发能力和性能。</li>\n<li>无锁串行化设计思想：Netty的设计中尽可能避免了锁的使用，采用了无锁的数据结构和并发设计思想，减少了锁竞争和线程阻塞，提高了并发性能和可伸缩性。当我们需要多个线程并发地访问共享数据时，传统的做法是使用锁来确保每个线程的访问是安全的。但是，锁的使用会引入竞争和阻塞，导致性能下降。而无锁串行化的思想就是为了解决这个问题。在Netty中，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。</li>\n<li>支持高性能序列化协议：Netty提供了对多种高性能序列化协议的支持，如Google Protocol Buffers、MessagePack等。这些协议具有高效的编解码性能和数据压缩能力，提升了网络传输的效率和速度。</li>\n<li>零拷贝：Netty通过使用直接内存（Direct Memory）实现了零拷贝的特性。它通过将数据直接从操作系统的内存缓冲区传输到网络中，避免了不必要的数据复制，提高了数据传输的效率。</li>\n<li>ByteBuf内存池设计：Netty使用了可配置的ByteBuf内存池，避免了频繁的内存分配和释放操作，减少了内存管理的开销，提高了内存的使用效率和性能。</li>\n<li>灵活的TCP参数配置能力：Netty提供了灵活的TCP参数配置能力，开发人员可以根据实际需求调整TCP的各种参数，如TCP缓冲区大小、TCP_NODELAY选项等，以优化网络连接的性能和可靠性。</li>\n<li>并发优化：Netty在设计上考虑了并发操作的优化。它采用了基于事件驱动的异步编程模型，通过回调和Future等机制实现非阻塞的并发处理。同时，它还提供了多种并发安全的组件和工具类，简化了并发编程的复杂性。</li>\n</ol>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"如何引入？\"><a href=\"#如何引入？\" class=\"headerlink\" title=\"如何引入？\"></a>如何引入？</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.39.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写一个demo\"><a href=\"#编写一个demo\" class=\"headerlink\" title=\"编写一个demo\"></a>编写一个demo</h3><ol>\n<li><p>编写Server服务端启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sjchen.netty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NettyServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            bind();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建boss线程组，用于接收连接</span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">bossGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建worker线程组，用于处理连接上的I/O操作，含有子线程NioEventGroup个数为CPU核数大小的2倍</span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">workerGroup</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建ServerBootstrap实例，服务器启动对象</span></span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 使用链式编程配置参数</span></span><br><span class=\"line\">            <span class=\"comment\">// 将boss线程组和worker线程组暂存到ServerBootstrap</span></span><br><span class=\"line\">            bootstrap.group(bossGroup, workerGroup);</span><br><span class=\"line\">            <span class=\"comment\">// 设置服务端Channel类型为NioServerSocketChannel作为通道实现</span></span><br><span class=\"line\">            bootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\"></span><br><span class=\"line\">            bootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> socketChannel.pipeline();</span><br><span class=\"line\">                    <span class=\"comment\">// 添加ServerHandler到ChannelPipeline，对workerGroup的SocketChannel（客户端）设置处理器</span></span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ServerHandler</span>());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"comment\">// 设置启动参数，初始化服务器连接队列大小。服务端处理客户端连接请求是顺序处理，一个时间内只能处理一个客户端请求</span></span><br><span class=\"line\">            <span class=\"comment\">// 当有多个客户端同时来请求时，未处理的请求先放入队列中</span></span><br><span class=\"line\">            bootstrap.option(ChannelOption.SO_BACKLOG, <span class=\"number\">1024</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 绑定端口并启动服务器，bind方法是异步的，sync方法是等待异步操作执行完成，返回ChannelFuture异步对象</span></span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.bind(<span class=\"number\">8888</span>).sync();</span><br><span class=\"line\">            <span class=\"comment\">// 等待服务器关闭</span></span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 优雅地关闭boss线程组</span></span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            <span class=\"comment\">// 优雅地关闭worker线程组</span></span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写服务端处理器Handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sjchen.netty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.Unpooled;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.CharsetUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.ReferenceCountUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 已经注册到它的 EventLoop 并且能够处理 I/O 时被调用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRegistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelRegistered&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 从它的 EventLoop 注销并且无法处理任何 I/O 时被调</span></span><br><span class=\"line\"><span class=\"comment\">     * 用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelUnregistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelUnregistered&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelActive&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 离开活动状态并且不再连接它的远程节点时被调用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelInactive&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当从 Channel 读取数据时被调用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelRead&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 处理接收到的数据</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将接收到的字节数据转换为字符串</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> byteBuf.toString(CharsetUtil.UTF_8);</span><br><span class=\"line\">            <span class=\"comment\">// 打印接收到的消息</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Server端收到客户消息: &quot;</span> + message);</span><br><span class=\"line\">            <span class=\"comment\">// 发送响应消息给客户端</span></span><br><span class=\"line\">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">&quot;我是服务端，我收到你的消息啦~&quot;</span>, CharsetUtil.UTF_8));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 释放ByteBuf资源</span></span><br><span class=\"line\">            ReferenceCountUtil.release(byteBuf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 上的一个读操作完成时被调用，对通道的读取完成的事件或通知。当读取完成可通知发送方或其他的相关方，告诉他们接受方读取完成</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelReadComplete&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 ChannelnboundHandler.fireUserEventTriggered()方法被调用时被</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evt</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 userEventTriggered&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当 Channel 的可写状态发生改变时被调用。可以通过调用 Channel 的 isWritable()方法</span></span><br><span class=\"line\"><span class=\"comment\">     * * 来检测 Channel 的可写性。与可写性相关的阈值可以通过</span></span><br><span class=\"line\"><span class=\"comment\">     * * Channel.config().setWriteHighWaterMark()和 Channel.config().setWriteLowWaterMark()方法来</span></span><br><span class=\"line\"><span class=\"comment\">     * * 设置</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ctx</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelWritabilityChanged</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 channelWritabilityChanged&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行 exceptionCaught&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写客户端启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sjchen.netty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.EventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NettyClient</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建EventLoopGroup，用于处理客户端的I/O操作</span></span><br><span class=\"line\">        <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">groupThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建Bootstrap实例，客户端启动对象</span></span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.group(groupThread);</span><br><span class=\"line\">            <span class=\"comment\">// 设置服务端Channel类型为NioSocketChannel作为通道实现</span></span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            <span class=\"comment\">// 设置客户端处理</span></span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    socketChannel.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ClientHandler</span>());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"comment\">// 绑定端口</span></span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 优雅地关闭线程</span></span><br><span class=\"line\">            groupThread.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写客户端处理器Handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sjchen.netty;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.Unpooled;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.CharsetUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.util.ReferenceCountUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 连接建立时的处理，发送请求消息给服务器</span></span><br><span class=\"line\">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">&quot;你好，服务端！我是客户端，测试通道连接&quot;</span>, CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理接收到的数据</span></span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将接收到的字节数据转换为字符串</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> byteBuf.toString(CharsetUtil.UTF_8);</span><br><span class=\"line\">            <span class=\"comment\">// 打印接收到的消息</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;受到服务端响应的消息: &quot;</span> + message);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 对数据进行业务处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 释放ByteBuf资源</span></span><br><span class=\"line\">            ReferenceCountUtil.release(byteBuf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动客户端、服务端，看控制台打印结果。可以看到，客户端启动时给服务端发送一条消息，服务端收到消息后给客户端回应消息。</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240530160548240.png\" alt=\"image-20240530160548240\"><br><img data-src=\"https://img.jyhmw.cn/image-20240530160637470.png\" alt=\"image-20240530160637470\"></p>\n<p>在Netty 开发中我们主要编写handler处理器，ChannelHandler是处理入站和出站数据的应用程序逻辑的容器。ChannelHandler顶级接口中派生了两个重要的子接口ChannelInboundHandler和ChannelOutboundHandler以及适配器抽象类ChannelHandlerAdapter，使用规则如下：</p>\n<ul>\n<li>ChannelInboundHandler：用于处理入站事件，也称为输入处理器。可以处理从远程对等方（如客户端）到本地Netty服务器的事件，包括连接建立、数据接收、异常发生等。</li>\n<li>ChannelOutboundHandler：用于处理出站事件，也称为输出处理器。可以处理从本地Netty服务器到远程对等方（如服务器端）的事件，包括数据发送、连接建立、连接关闭等。</li>\n<li>ChannelInboundHandlerAdapter是一个抽象类，实现了<code>ChannelInboundHandler</code>接口，可以作为用户自定义的ChannelInboundHandler的基类。当使用时，需要覆盖其中的方法来实现自定义的处理逻辑，包括<code>channelRead()</code>、<code>channelReadComplete()</code>、<code>exceptionCaught()</code>等方法。适用于需要实现自定义的、细粒度的处理逻辑的场景。它提供了更大的灵活性，可以对接收到的事件进行完全自定义的处理。</li>\n<li>SimpleChannelInboundHandler是<code>ChannelInboundHandlerAdapter</code>的子类，提供了更高层次的抽象和简化。里面封装了消息的类型匹配和释放资源的逻辑，用户只需要关注具体的消息类型和业务逻辑的处理。当使用时，需要指定具体的泛型类型，以指定处理的消息类型。</li>\n</ul>\n</li>\n</ol>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>如果继承ChannelInboundHandlerAdapter适配处理器，在channelRead()方法中处理完业务逻辑后，如果不往下一个处理器传播，则需要自己释放资源ReferenceCountUtil.<em>release</em>(msg)，如果需要往下一个处理器传播，则调用ctx.fireChannelRead(msg)方法往后传播;</li>\n<li>在出站使用write()写方法写数据时Channel、ChannelPipeline、ChannelHandlerContext都支持写，唯一不同的是Channel、ChannelPipeline写是在整个传播链，而ChannelHandlerContext只在当前的传播链以及下一个处理事件的传播链。</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","categories":["技术栈","Netty"],"tags":["Java","RPC","异步"]},{"title":"Spring Cache","url":"/2024/05/27/SpringCache/","content":"<h1 id=\"Spring-Cache\"><a href=\"#Spring-Cache\" class=\"headerlink\" title=\"Spring Cache\"></a>Spring Cache</h1><blockquote>\n<p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需添加一个注解，就能实现缓存功能。</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><strong>Spring Cache</strong>提供了一层抽象，底层可以切换不同的cache实现。</p>\n<p>具体通过CacheManager接口统一不同的缓存技术</p>\n<p>针对不同的缓存技术需要实现不同的CacheManager<br><img data-src=\"https://img.jyhmw.cn/image-20240312194451429.png\" alt=\"image-20240312194451429\"></p>\n<h2 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><p><img data-src=\"https://img.jyhmw.cn/image-20240312194537316.png\" alt=\"image-20240312194537316\"></p>\n<p>在Spring Boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p>\n<p>例如：使用Redis作为缓存技术，只需要导入Spring data Redis的Maven坐标即可</p>\n<p>未完…<br><strong>注意：名称不能有空格不然图片会显示不出来</strong></p>\n","categories":["技术栈","Spring"],"tags":["Spring","Redis"]},{"title":"Redis","url":"/2024/03/16/Redis/","content":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"非关系型数据库\"><a href=\"#非关系型数据库\" class=\"headerlink\" title=\"非关系型数据库\"></a>非关系型数据库</h2><h3 id=\"四大非关系型数据库\"><a href=\"#四大非关系型数据库\" class=\"headerlink\" title=\"四大非关系型数据库\"></a>四大非关系型数据库</h3><ul>\n<li>键值数据库-Redis</li>\n<li>列族数据库-Hive</li>\n<li>文档数据库-MongoDB</li>\n<li>图数据库-Neo4J</li>\n</ul>\n<h3 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h3><h4 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h4><h5 id=\"C一致性\"><a href=\"#C一致性\" class=\"headerlink\" title=\"C一致性\"></a>C一致性</h5><p>一个读操作总是能读到之前完成的写操作的结果</p>\n<h5 id=\"A可用性\"><a href=\"#A可用性\" class=\"headerlink\" title=\"A可用性\"></a>A可用性</h5><p>能够快速获取数据，可以在确定的时间内返回对应的结果</p>\n<h5 id=\"P分区容忍性\"><a href=\"#P分区容忍性\" class=\"headerlink\" title=\"P分区容忍性\"></a>P分区容忍性</h5><p>部分区域出现故障，其他区域也可以继续运行</p>\n<blockquote>\n<p>CAP只可以满足其中两个，Redis就是实现了CP的代表</p>\n</blockquote>\n<h3 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h3><h4 id=\"BA基本可用\"><a href=\"#BA基本可用\" class=\"headerlink\" title=\"BA基本可用\"></a>BA基本可用</h4><p>一部分不可用，但是其他部分还是可用的</p>\n<h4 id=\"S软状态\"><a href=\"#S软状态\" class=\"headerlink\" title=\"S软状态\"></a>S软状态</h4><p>软状态指数据可以有一段时间不同步，有一定的滞后性</p>\n<h4 id=\"E最终一致性\"><a href=\"#E最终一致性\" class=\"headerlink\" title=\"E最终一致性\"></a>E最终一致性</h4><h6 id=\"强一致性\"><a href=\"#强一致性\" class=\"headerlink\" title=\"强一致性\"></a>强一致性</h6><p>修改后其他数据可以立即读到最新的数据</p>\n<h6 id=\"弱一致性\"><a href=\"#弱一致性\" class=\"headerlink\" title=\"弱一致性\"></a>弱一致性</h6><p>最终一致性就是弱一致性的一个特例，即最终要保证数据已经改变，数据可以在一段时间内不一样</p>\n<h3 id=\"关系型数据库与非关系型数据库的区别\"><a href=\"#关系型数据库与非关系型数据库的区别\" class=\"headerlink\" title=\"关系型数据库与非关系型数据库的区别\"></a>关系型数据库与非关系型数据库的区别</h3><h4 id=\"关系型数据库\"><a href=\"#关系型数据库\" class=\"headerlink\" title=\"关系型数据库\"></a>关系型数据库</h4><ol>\n<li><p>数据之间有关联</p>\n</li>\n<li><p>数据存储在磁盘上</p>\n</li>\n<li><p>表现为一个一个的表格数据</p>\n</li>\n</ol>\n<h4 id=\"非关系型数据库-1\"><a href=\"#非关系型数据库-1\" class=\"headerlink\" title=\"非关系型数据库\"></a>非关系型数据库</h4><ol>\n<li><p>数据之间没有关联</p>\n</li>\n<li><p>数据存储在内存</p>\n</li>\n<li><p>表现为key-value键值对</p>\n</li>\n</ol>\n<h2 id=\"Redis是什么\"><a href=\"#Redis是什么\" class=\"headerlink\" title=\"Redis是什么\"></a>Redis是什么</h2><h3 id=\"Remote-Dictionary-Server远程字典服务\"><a href=\"#Remote-Dictionary-Server远程字典服务\" class=\"headerlink\" title=\"Remote Dictionary Server远程字典服务\"></a>Remote Dictionary Server远程字典服务</h3><h3 id=\"是一个键值对数据库\"><a href=\"#是一个键值对数据库\" class=\"headerlink\" title=\"是一个键值对数据库\"></a>是一个键值对数据库</h3><h3 id=\"单线程但是性能很高\"><a href=\"#单线程但是性能很高\" class=\"headerlink\" title=\"单线程但是性能很高\"></a>单线程但是性能很高</h3><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>负责快速的响应用户的请求（因为是数据库的一层缓存）</li>\n<li>防止对数据库的并发冲击</li>\n</ul>\n<h2 id=\"Redis数据结构\"><a href=\"#Redis数据结构\" class=\"headerlink\" title=\"Redis数据结构\"></a>Redis数据结构</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><h5 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li>Long类型整数</li>\n<li>SDS简单动态字符串<ul>\n<li>embstr</li>\n<li>raw</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"具体结构\"><a href=\"#具体结构\" class=\"headerlink\" title=\"具体结构\"></a>具体结构</h5><ul>\n<li>如果你存储的是一个64位的整型数<br>采用int型编码，直接用RedisObejct 中的类型指针存放这个值即可，不需要SDS</li>\n<li>存储的是一个小于44字节的字符串<br>使用embstr编码，SDS直接与RedisObejct在内存上紧挨着</li>\n<li>存储的是一个大于44字节的字符串<br>使用raw编码，SDS与RedisObejct地址没有关系，通过RedisObejct中的指针指向</li>\n</ul>\n<h5 id=\"实现场景\"><a href=\"#实现场景\" class=\"headerlink\" title=\"实现场景\"></a>实现场景</h5><ul>\n<li>计数，如点赞数等等</li>\n<li>缓存</li>\n<li>使用字符串类型的列表或发布&#x2F;订阅模式可以实现简单的消息队列</li>\n</ul>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><h5 id=\"底层实现-1\"><a href=\"#底层实现-1\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li>压缩列表</li>\n<li>双向链表</li>\n</ul>\n<h5 id=\"实现场景-1\"><a href=\"#实现场景-1\" class=\"headerlink\" title=\"实现场景\"></a>实现场景</h5><p>作为一个消息队列</p>\n<h4 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h4><h5 id=\"底层实现-2\"><a href=\"#底层实现-2\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li><p>压缩列表</p>\n</li>\n<li><p>哈希表</p>\n</li>\n</ul>\n<h5 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>存储对象的多个字段和值，如用户信息、配置信息</p>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><h5 id=\"底层实现-3\"><a href=\"#底层实现-3\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li>压缩数组</li>\n<li>哈希表</li>\n</ul>\n<h5 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>去重、成员关系判断</p>\n<h4 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h4><h5 id=\"底层实现-4\"><a href=\"#底层实现-4\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li>压缩列表</li>\n<li>跳表</li>\n</ul>\n<h5 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>去重成员关系判断</p>\n<h4 id=\"有序集合-1\"><a href=\"#有序集合-1\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h4><h5 id=\"底层实现-5\"><a href=\"#底层实现-5\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h5><ul>\n<li>压缩列表</li>\n<li>跳表</li>\n</ul>\n<h5 id=\"场景-3\"><a href=\"#场景-3\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>排行榜、范围查询</p>\n<h4 id=\"三种特殊的数据结构\"><a href=\"#三种特殊的数据结构\" class=\"headerlink\" title=\"三种特殊的数据结构\"></a>三种特殊的数据结构</h4><h5 id=\"HyperLogLogs\"><a href=\"#HyperLogLogs\" class=\"headerlink\" title=\"HyperLogLogs\"></a>HyperLogLogs</h5><p>省内存的去统计各种计数，比如注册IP数、每日访问IP数的页面实时UV、在线用户数、共同好友数等</p>\n<h5 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h5><p>两个状态的，都可以使用Bitmaps，比如登录&#x2F;未登录，性别男&#x2F;女</p>\n<h5 id=\"geospatial\"><a href=\"#geospatial\" class=\"headerlink\" title=\"geospatial\"></a>geospatial</h5><blockquote>\n<p>底层是Zset，有序列表</p>\n</blockquote>\n<p>推算地理位置的信息，两地之间的距离，方圆几里的人</p>\n<h5 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h5><p>用于消息队列和发布&#x2F;订阅模式</p>\n<h3 id=\"数据类型底层的数据结构\"><a href=\"#数据类型底层的数据结构\" class=\"headerlink\" title=\"数据类型底层的数据结构\"></a>数据类型底层的数据结构</h3><h4 id=\"SDS\"><a href=\"#SDS\" class=\"headerlink\" title=\"SDS\"></a>SDS</h4><blockquote>\n<p>Redis专门实现的一个结构体</p>\n<p>有三个字段：len、free、buf[]分别用来标记长度，剩余长度，存储的字符</p>\n</blockquote>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li><p>保证二进制安全，因为C语言使用’\\0’来判断字符是否结束的，但是SDS使用len来表示长度的</p>\n</li>\n<li><p>O(1)级别获取字符串长度，因为用len来记录长度</p>\n</li>\n<li><p>减少字符串的内存重新分配的次数</p>\n<ul>\n<li><p>预先分配+惰性空间释放</p>\n<ul>\n<li><p>空间预先分配<br>字符串扩展会扩展的更大</p>\n</li>\n<li><p>惰性空间释放</p>\n<p>字符串缩小，增大free的值，但不一定会缩小buf数组</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h4><h5 id=\"什么时候会使用压缩列表？\"><a href=\"#什么时候会使用压缩列表？\" class=\"headerlink\" title=\"什么时候会使用压缩列表？\"></a>什么时候会使用压缩列表？</h5><p>数据中元素个数小于512</p>\n<p>单个元素的大小小于64字节</p>\n<h5 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>压缩列表在每个元素的开头使用了一个字节作为标识，用来标识该元素的数据类型。这个类型标识允许压缩列表在解码时正确地将字节序列转换回原始数据类型</li>\n<li>一段连续的内存存放数据，类似于C实现的数组，但是可以存储不同数据类型的数据</li>\n<li>有一个字段保存了偏移长度，很节省空间，但是遍历的时间复杂度未O(n)</li>\n</ul>\n<h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><blockquote>\n<p>与常见的双向链表一样</p>\n<p>存储了列表长度，保证O(1)级别获取长度</p>\n</blockquote>\n<h4 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h4><h5 id=\"使用高性能的murmurhash算法\"><a href=\"#使用高性能的murmurhash算法\" class=\"headerlink\" title=\"使用高性能的murmurhash算法\"></a>使用高性能的murmurhash算法</h5><h5 id=\"解决hash冲突\"><a href=\"#解决hash冲突\" class=\"headerlink\" title=\"解决hash冲突\"></a>解决hash冲突</h5><p>拉链法</p>\n<h5 id=\"扩容缩容机制\"><a href=\"#扩容缩容机制\" class=\"headerlink\" title=\"扩容缩容机制\"></a>扩容缩容机制</h5><ul>\n<li>负载因子&#x3D;已存储的元素个数&#x2F;哈希表大小</li>\n<li>&gt;1扩容  扩容为原来大小的两倍</li>\n<li>&lt;0.1缩容 缩容为当前数据量的两倍</li>\n</ul>\n<h4 id=\"整数数组\"><a href=\"#整数数组\" class=\"headerlink\" title=\"整数数组\"></a>整数数组</h4><h5 id=\"Set什么时候使用有序数组？\"><a href=\"#Set什么时候使用有序数组？\" class=\"headerlink\" title=\"Set什么时候使用有序数组？\"></a>Set什么时候使用有序数组？</h5><ul>\n<li>存储的数据都是整数</li>\n<li>存储的元素个数不超过512个</li>\n</ul>\n<h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>没有内存碎片</li>\n<li>节省空间</li>\n</ul>\n<h4 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h4><h5 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>最底层是一个链表，然后给最底层节点隔一个建立一个索引，然后再给索引建立索引，就构成的跳表</li>\n<li>查询速度为O(logn)</li>\n</ul>\n<h5 id=\"为什么使用跳表而不是红黑树？\"><a href=\"#为什么使用跳表而不是红黑树？\" class=\"headerlink\" title=\"为什么使用跳表而不是红黑树？\"></a>为什么使用跳表而不是红黑树？</h5><ul>\n<li><p>红黑树不适合范围查询</p>\n</li>\n<li><p>跳表的实现比较简单</p>\n</li>\n</ul>\n<h3 id=\"Redis底层数据结构\"><a href=\"#Redis底层数据结构\" class=\"headerlink\" title=\"Redis底层数据结构\"></a>Redis底层数据结构</h3><blockquote>\n<p>RedisObejct 是记录数据是什么类型的结构体，由两部分组成，元数据与类型指针</p>\n</blockquote>\n<h4 id=\"Redis最外层有两个全局哈希表\"><a href=\"#Redis最外层有两个全局哈希表\" class=\"headerlink\" title=\"Redis最外层有两个全局哈希表\"></a>Redis最外层有两个全局哈希表</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240317144215207.png\" alt=\"image-20240317144215207\"></p>\n<h4 id=\"解决碰撞的方式\"><a href=\"#解决碰撞的方式\" class=\"headerlink\" title=\"解决碰撞的方式\"></a>解决碰撞的方式</h4><h5 id=\"拉链法\"><a href=\"#拉链法\" class=\"headerlink\" title=\"拉链法\"></a>拉链法</h5><p><strong>如果拉链太长怎么办？</strong></p>\n<ul>\n<li>Redis进行rehash:使用两个哈希表交替，一个扩容，一个继续提供服务</li>\n<li>渐进式rehash<ul>\n<li>如果单纯使用两个哈希表，哈希表1负责扩容、哈希表2负责提供服务，那么扩容的哈希表1在copy哈希表2时，哈希表2需要进入阻塞状态，导致不能进行服务</li>\n<li>因此使用渐进式rehash过程，即在每次的请求携带一点，而不是统一的传输</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"为什么要有两个全局哈希表\"><a href=\"#为什么要有两个全局哈希表\" class=\"headerlink\" title=\"为什么要有两个全局哈希表\"></a>为什么要有两个全局哈希表</h4><ol>\n<li>因为扩容的时候可以进行渐进式扩容，可以每次的请求携带一些桶然后慢慢扩容</li>\n<li>扩容的时候能保证提供服务</li>\n</ol>\n<h2 id=\"持久化操作\"><a href=\"#持久化操作\" class=\"headerlink\" title=\"持久化操作\"></a>持久化操作</h2><h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><blockquote>\n<p>Append On File</p>\n</blockquote>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>不同于传统的WAL，AOF是写后日志，会先执行操作，然后再记录日志</p>\n<h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点:\"></a>优点:</h5><ul>\n<li>不需要检查语法是否错误</li>\n<li>可以避免记录日志影响当前操作的进度</li>\n</ul>\n<h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5><ul>\n<li>影响后续操作的速度</li>\n<li>如果执行完操作宕机了，那么日志就没有记录，使用AOF恢复的时候会丢失数据</li>\n</ul>\n<h4 id=\"写回策略\"><a href=\"#写回策略\" class=\"headerlink\" title=\"写回策略\"></a>写回策略</h4><ul>\n<li>always 每个操作都写回磁盘</li>\n<li>Everysec 每秒写回一次磁盘</li>\n<li>No 写回的时机由OS决定</li>\n</ul>\n<h4 id=\"AOF重写机制\"><a href=\"#AOF重写机制\" class=\"headerlink\" title=\"AOF重写机制\"></a>AOF重写机制</h4><ul>\n<li>AOF越来越大，就会触发AOF重写机制，即只记录可以出现最后结果的操作</li>\n<li>重写过程由另一个线程来实现</li>\n<li>主线程会fork出一个子线程去执行重写操作(注意fork的过程是阻塞的)</li>\n</ul>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><blockquote>\n<p>RedisDataBase</p>\n</blockquote>\n<h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>一定之间间隔，检测key的变化情况，然后持久化存储</li>\n<li>主线程可以自己save，也可以创建一个线程bgsave</li>\n<li>fork过程阻塞</li>\n</ul>\n<h4 id=\"复制过程中可以继续提供读写服务吗？\"><a href=\"#复制过程中可以继续提供读写服务吗？\" class=\"headerlink\" title=\"复制过程中可以继续提供读写服务吗？\"></a>复制过程中可以继续提供读写服务吗？</h4><p>可以使用cow的思想，对某部分写操作是，对这部分copy一部分</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li>AOF记录的是操作，所以每次记录的内容很简单</li>\n<li>RDB存储的是数据，恢复会很快，但是存储的容量很大</li>\n</ul>\n<p><em><strong>Redis4.0混合使用AOF与RDB</strong></em>：既保证安全也保证速度</p>\n<h4 id=\"各自适用什么场景？\"><a href=\"#各自适用什么场景？\" class=\"headerlink\" title=\"各自适用什么场景？\"></a>各自适用什么场景？</h4><ul>\n<li>RDB适用于数据库备份与迁移</li>\n<li>AOF适用于数据可靠性要求高、实时性高的场景</li>\n</ul>\n<h2 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h2><h3 id=\"Redis缓存类型\"><a href=\"#Redis缓存类型\" class=\"headerlink\" title=\"Redis缓存类型\"></a>Redis缓存类型</h3><h4 id=\"只读缓存\"><a href=\"#只读缓存\" class=\"headerlink\" title=\"只读缓存\"></a>只读缓存</h4><p>只负责读请求，对于写请求直接操作数据库</p>\n<h4 id=\"读写缓存\"><a href=\"#读写缓存\" class=\"headerlink\" title=\"读写缓存\"></a>读写缓存</h4><p>读写请求都负责，写请求会之后同步在数据库</p>\n<h5 id=\"同步策略\"><a href=\"#同步策略\" class=\"headerlink\" title=\"同步策略:\"></a>同步策略:</h5><ul>\n<li>同步直写 请求同时发送给缓存与数据库，等待两者都操作完成后，才将结果返回</li>\n<li>异步写回 缓存不等待数据库就直接返回，数据只有被淘汰的时候才会写回磁盘</li>\n</ul>\n<h3 id=\"缓存一致性问题\"><a href=\"#缓存一致性问题\" class=\"headerlink\" title=\"缓存一致性问题\"></a>缓存一致性问题</h3><h4 id=\"什么时候缓存一致？\"><a href=\"#什么时候缓存一致？\" class=\"headerlink\" title=\"什么时候缓存一致？\"></a>什么时候缓存一致？</h4><ul>\n<li>缓存中没有数据，数据库的数据是最新的</li>\n<li>缓存中有数据，且和数据库数据相同</li>\n</ul>\n<h4 id=\"如何解决缓存不一致？\"><a href=\"#如何解决缓存不一致？\" class=\"headerlink\" title=\"如何解决缓存不一致？\"></a>如何解决缓存不一致？</h4><h5 id=\"对于读写缓存\"><a href=\"#对于读写缓存\" class=\"headerlink\" title=\"对于读写缓存\"></a>对于读写缓存</h5><p>使用同步只写</p>\n<h5 id=\"对于只读缓存\"><a href=\"#对于只读缓存\" class=\"headerlink\" title=\"对于只读缓存\"></a>对于只读缓存</h5><ul>\n<li><p>新增操作<br>新增操作直接操作数据库，此时缓存内没有数据，数据库有，符合缓存一致</p>\n</li>\n<li><p>删改操作：对于删改操作，直接修改数据库，此时数据库为最新数据，而缓存中为旧数据，出现了缓存一致性问题</p>\n<p>删除缓存数据，修改数据库内的数据</p>\n</li>\n</ul>\n<p>注：主要是删除或修改操作会出现缓存不一致问题</p>\n<h4 id=\"只读删改操作怎么处理？\"><a href=\"#只读删改操作怎么处理？\" class=\"headerlink\" title=\"只读删改操作怎么处理？\"></a>只读删改操作怎么处理？</h4><h5 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h5><ol>\n<li>先删除缓存数据</li>\n<li>修改数据库数据</li>\n</ol>\n<h5 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h5><h6 id=\"问题一：任意一步出现失败\"><a href=\"#问题一：任意一步出现失败\" class=\"headerlink\" title=\"问题一：任意一步出现失败\"></a>问题一：任意一步出现失败</h6><ul>\n<li>1成功，2失败：此时缓存中没有数据，数据库中的值还是旧值；存在数据不一致问题</li>\n<li>1失败，2成功：缓存为旧值数据库为新值</li>\n</ul>\n<h5 id=\"问题二：存在并发请求\"><a href=\"#问题二：存在并发请求\" class=\"headerlink\" title=\"问题二：存在并发请求\"></a>问题二：存在并发请求</h5><blockquote>\n<p>当前有很多请求进入，你还没来得及删除缓存，另一边就直接把旧数据读走了</p>\n</blockquote>\n<h4 id=\"解决措施\"><a href=\"#解决措施\" class=\"headerlink\" title=\"解决措施\"></a>解决措施</h4><h5 id=\"解决问题一：重试机制\"><a href=\"#解决问题一：重试机制\" class=\"headerlink\" title=\"解决问题一：重试机制\"></a>解决问题一：重试机制</h5><p>把要更改或删除的数据保存在一个消息队列中，如果删除缓存或修改数据任意一步失败，那么就去消息队列中取数据重新执行</p>\n<p>如果达到一定的次数，还是失败，那么就向业务层报错</p>\n<h5 id=\"解决问题二：延迟双删\"><a href=\"#解决问题二：延迟双删\" class=\"headerlink\" title=\"解决问题二：延迟双删\"></a>解决问题二：延迟双删</h5><ol>\n<li>A线程删除缓存</li>\n<li>A线程修改数据库</li>\n<li>A线程睡一会儿：保证这段时间B线程能修改完数据库，并将最新的数据搬到redis</li>\n<li>A线程再删除一遍缓存</li>\n</ol>\n<h2 id=\"缓存淘汰策略\"><a href=\"#缓存淘汰策略\" class=\"headerlink\" title=\"缓存淘汰策略\"></a>缓存淘汰策略</h2><h3 id=\"Redis4-0有八种淘汰策略\"><a href=\"#Redis4-0有八种淘汰策略\" class=\"headerlink\" title=\"Redis4.0有八种淘汰策略\"></a>Redis4.0有八种淘汰策略</h3><h4 id=\"不进行数据淘汰\"><a href=\"#不进行数据淘汰\" class=\"headerlink\" title=\"不进行数据淘汰\"></a>不进行数据淘汰</h4><p>noeviction(默认)，缓存存满，将不会接受新的请求</p>\n<h4 id=\"进行数据淘汰策略\"><a href=\"#进行数据淘汰策略\" class=\"headerlink\" title=\"进行数据淘汰策略\"></a>进行数据淘汰策略</h4><h5 id=\"有过期时间的数据内淘汰\"><a href=\"#有过期时间的数据内淘汰\" class=\"headerlink\" title=\"有过期时间的数据内淘汰\"></a>有过期时间的数据内淘汰</h5><ul>\n<li><p>volatile-lru</p>\n<blockquote>\n<p>最近最少使用</p>\n</blockquote>\n<ul>\n<li>当内存限制达到时，根据最近最少使用(LRU)原则删除键</li>\n<li>所有导致键数量增加的操作(如SET、LPUSH等)都会返回一个错误</li>\n</ul>\n</li>\n<li><p>volatile-lfu</p>\n<blockquote>\n<p>首先根据访问次数进行淘汰，如果访问次数相同，再根据时间淘汰</p>\n</blockquote>\n<ul>\n<li>当内存限制达到时，根据使用频率计算</li>\n</ul>\n</li>\n<li><p>volatile-ttl</p>\n<blockquote>\n<p>淘汰过期时间剩余最短的</p>\n</blockquote>\n</li>\n<li><p>volatile-random</p>\n<blockquote>\n<p>设置了过期时间的随机淘汰</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"所有数据中进行淘汰\"><a href=\"#所有数据中进行淘汰\" class=\"headerlink\" title=\"所有数据中进行淘汰\"></a>所有数据中进行淘汰</h5><ul>\n<li><p>allkeys-lru</p>\n</li>\n<li><p>allkeys-lfu</p>\n</li>\n<li><p>allkeys-random</p>\n</li>\n</ul>\n<h3 id=\"LRU（Least-Recently-Used）\"><a href=\"#LRU（Least-Recently-Used）\" class=\"headerlink\" title=\"LRU（Least Recently Used）\"></a>LRU（Least Recently Used）</h3><blockquote>\n<p>RedisObject中有一个字段，存放了最近一次的访问时间戳</p>\n<p>LRU就是根据这个字段</p>\n</blockquote>\n<h4 id=\"LRU过程\"><a href=\"#LRU过程\" class=\"headerlink\" title=\"LRU过程\"></a>LRU过程</h4><ol>\n<li>首先随机选择N个数据，组成一个候选淘汰集合，然后将最早访问的数据淘汰</li>\n<li>然后每一次淘汰，都会挑选新的数据进入候选淘汰集合中（如何挑选：选择那些字段值比候选集合最小的数据还小的数据）</li>\n</ol>\n<h4 id=\"存在的问题-1\"><a href=\"#存在的问题-1\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p>无法解决缓存污染问题</p>\n<ul>\n<li>即存放了很多可能长久不会访问的数据</li>\n<li>比如业务层遍历了很多数据一次，此时LRU算法根本判断不出来这些数据中哪些数据访问的频次会高一点</li>\n</ul>\n<h3 id=\"LFU（Least-Frequently-Used）\"><a href=\"#LFU（Least-Frequently-Used）\" class=\"headerlink\" title=\"LFU（Least Frequently Used）\"></a>LFU（Least Frequently Used）</h3><ol>\n<li>首先根据访问次数进行淘汰</li>\n<li>如果访问次数相同，再依据时间戳淘汰</li>\n</ol>\n<h2 id=\"其他缓存问题\"><a href=\"#其他缓存问题\" class=\"headerlink\" title=\"其他缓存问题\"></a>其他缓存问题</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><h4 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h4><p>即缓存无法解决大量的数据访问，导致更多的数据访问了数据库，数据库压力增大</p>\n<h4 id=\"原因两个\"><a href=\"#原因两个\" class=\"headerlink\" title=\"原因两个\"></a>原因两个</h4><ol>\n<li>可能是相同过期时间的数据同时过期，导致缓存中数据都没有，都去访问数据库</li>\n<li>缓存主库宕机</li>\n</ol>\n<h4 id=\"解决措施-1\"><a href=\"#解决措施-1\" class=\"headerlink\" title=\"解决措施\"></a>解决措施</h4><ol>\n<li>情况一<ul>\n<li>给数据设置不同的过期时间：比如一个固定值+一个随机值</li>\n<li>服务降级<ul>\n<li>即缓存先去满足核心业务</li>\n<li>非核心业务先返回预定值或是null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>情况二<ul>\n<li>服务熔断 缓存暂时停止使用，防止造成连锁反应导致其他的服务也失败</li>\n<li>请求限流机制 前端进行限流，控制每秒进入的请求数QPS</li>\n<li>主从替换 使用从库代替主库，继续进行服务</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><h4 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿?\"></a>什么是缓存击穿?</h4><p>访问非常热的请求，无法处理传到了数据库</p>\n<h4 id=\"出现的原因\"><a href=\"#出现的原因\" class=\"headerlink\" title=\"出现的原因\"></a>出现的原因</h4><p>往往是给热请求数据设置了过期时间</p>\n<h4 id=\"如何解决？\"><a href=\"#如何解决？\" class=\"headerlink\" title=\"如何解决？\"></a>如何解决？</h4><p>对于非常热的请求不要设置缓存时间</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><h4 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h4><p>访问缓存与数据库根本不存在的数据</p>\n<h4 id=\"出现的原因-1\"><a href=\"#出现的原因-1\" class=\"headerlink\" title=\"出现的原因\"></a>出现的原因</h4><ul>\n<li>业务层误操作</li>\n<li>被故意访问不存在的数据</li>\n</ul>\n<h4 id=\"解决措施-2\"><a href=\"#解决措施-2\" class=\"headerlink\" title=\"解决措施\"></a>解决措施</h4><ul>\n<li>缓存空值或缺省值</li>\n<li>布隆过滤器 </li>\n<li>前端控制</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><blockquote>\n<p>多个hash函数+一个bit(位)数组</p>\n</blockquote>\n<p>存储一个数据就将其多次hash后，将对应的位置设为1</p>\n<p>检查元素是否存在时，同样使用这些哈希函数，如果所有对应位置都是1，则认为元素可能存在，但凡有一个不是1就一定不存在</p>\n<h2 id=\"Redis主从机制\"><a href=\"#Redis主从机制\" class=\"headerlink\" title=\"Redis主从机制\"></a>Redis主从机制</h2><h3 id=\"为什么要建立主从机制\"><a href=\"#为什么要建立主从机制\" class=\"headerlink\" title=\"为什么要建立主从机制\"></a>为什么要建立主从机制</h3><blockquote>\n<p>RDB、AOF的fork阶段会阻塞，让Redis停止服务，如果Redis越来越大，那么fork所用的时间会越来越长</p>\n<p>确保主库宕机后，从库还可以继续提供服务</p>\n</blockquote>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ul>\n<li>主库 负责读与写服务</li>\n<li>从库 只负责读服务和持久化操作</li>\n<li>哨兵<ul>\n<li>监听 监听主库从库状态</li>\n<li>选择主库 从从库中选择备用主库</li>\n<li>通过发布订阅系统发送通知</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第一次主从建立联系\"><a href=\"#第一次主从建立联系\" class=\"headerlink\" title=\"第一次主从建立联系\"></a>第一次主从建立联系</h3><ol>\n<li>从库发起请求连接</li>\n<li>主库同意其连接，并发送RDB文件给从库</li>\n<li>以后每次都发的是增量的修改</li>\n</ol>\n<h3 id=\"发布订阅系统\"><a href=\"#发布订阅系统\" class=\"headerlink\" title=\"发布订阅系统\"></a>发布订阅系统</h3><p>主库有发布订阅系统，订阅统一频道的节点可以发布与获取消息</p>\n<h3 id=\"主从库之间如何判断复制的延迟？\"><a href=\"#主从库之间如何判断复制的延迟？\" class=\"headerlink\" title=\"主从库之间如何判断复制的延迟？\"></a>主从库之间如何判断复制的延迟？</h3><p>通过缓存repl_backlog_buffer，这是一个环状缓存，里面有主库从库的当前指针，通过判断主从库之间的指针位置就能知道当前从库差主库多少数据</p>\n<h3 id=\"哨兵集群的建立过程\"><a href=\"#哨兵集群的建立过程\" class=\"headerlink\" title=\"哨兵集群的建立过程\"></a>哨兵集群的建立过程</h3><ol>\n<li>哨兵本质就是一个运行在特殊模式下的Redis进程</li>\n<li>哨兵创建后，互相之间是不知道彼此的存在的</li>\n<li>哨兵与主库建立连接后，可以利用主库的发布订阅系统，将自己的Ip传出去，这样其他哨兵就可以通过订阅频道来获取其IP，最终哨兵之间也就能联系了</li>\n</ol>\n<h3 id=\"哨兵怎么监听主从库是否正常？\"><a href=\"#哨兵怎么监听主从库是否正常？\" class=\"headerlink\" title=\"哨兵怎么监听主从库是否正常？\"></a>哨兵怎么监听主从库是否正常？</h3><ol>\n<li>哨兵会按时给主从库发送ping请求，并要求其在一定时间内回应</li>\n<li>如果从库没有回应，就标记为客观下线</li>\n<li>如果主库没有相响应，就标记为主观下线，然后哨兵会给其他哨兵发送信息询问是否认为主库下线，然后进行投票，多数赢少数认为主库客观下线</li>\n</ol>\n<h3 id=\"哨兵怎么选择新的主库？\"><a href=\"#哨兵怎么选择新的主库？\" class=\"headerlink\" title=\"哨兵怎么选择新的主库？\"></a>哨兵怎么选择新的主库？</h3><ol>\n<li>筛选 选择那些网络好的从库，确保他们是在线的</li>\n<li>评分 根据三方面来打分：从库优先级、从库复制进度、从库ID号<ul>\n<li>一般会给内存大的从库设置一个较大的优先级</li>\n<li>与主库复制进度差距最小的得分高</li>\n<li>当前面两个都一样的时候，会选择ID小的作为主库</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"哨兵怎么通知其他设备切换了新主库？\"><a href=\"#哨兵怎么通知其他设备切换了新主库？\" class=\"headerlink\" title=\"哨兵怎么通知其他设备切换了新主库？\"></a>哨兵怎么通知其他设备切换了新主库？</h3><ol>\n<li>通过Redis提供的发布订阅系统</li>\n<li>哨兵只要和主库建立连接，就可以发布消息和订阅消息了，只需要把消息发布一下，从库就会收到信息</li>\n<li>哨兵向主库发起INFO命令，然后主库就会返回一个从库列表，然后哨兵就知道了从库的IP</li>\n</ol>\n<h2 id=\"Redission锁\"><a href=\"#Redission锁\" class=\"headerlink\" title=\"Redission锁\"></a>Redission锁</h2><blockquote>\n<p>在分布式系统中，会涉及到多个节点操作同一个资源的问题，这时候就需要锁</p>\n</blockquote>\n<p>Redission是一个在Java中，用于操作Redis的框架，提供了一系列API来处理分布式场景下的各种需求。</p>\n<h3 id=\"特点-4\"><a href=\"#特点-4\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li><p>简单易用</p>\n<p>Redission提供了简单直观的API获取和释放分布式锁。<br>在Java代码中，只需要创建一个Redission客户端实例，就可以操作获取和释放锁的方法。</p>\n</li>\n<li><p>可重入性<br>Redission锁是可重入的，意味着如果一个线程已经获取了锁，那么可以在不释放锁的情况下再次获取锁</p>\n</li>\n<li><p>锁自动续期</p>\n<p>当一个线程获取到Redission分布式锁后，如果该线程执行时间长，超过了最初设定的锁过期时间，Redission会自动为锁续期</p>\n</li>\n</ol>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><ol>\n<li><p>获取锁</p>\n<p>获取锁时，会向Redis发送SETNX命令或其他类似原子操作命令来尝试获取锁。如果获得成功，会在Redis中设置锁的相关信息，包括锁的持有者、锁的过期时间等等。<strong>同时</strong>：后台会启动一个任务，检查锁是否要续期</p>\n</li>\n<li><p>锁的可重入实现<br>对于可重入性，Redis会根据一个线程重复获取锁的次数，进行记录。当一个线程重复获取锁时，会增加锁的记录次数。释放锁时，这个数字减为0才会真正释放。</p>\n</li>\n<li><p>释放锁<br>当线程完成任务要释放锁时，Redission会向Redis发送释放锁相关键值对的命令。释放锁之前，会检查当前线程是否为锁的持有者，如果是才会执行释放操作。确保了获取到锁的线程才能释放锁，避免了锁被错误释放的操作。</p>\n</li>\n</ol>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"存放数字最好不要使用String，而去使用hashmap\"><a href=\"#存放数字最好不要使用String，而去使用hashmap\" class=\"headerlink\" title=\"存放数字最好不要使用String，而去使用hashmap\"></a>存放数字最好不要使用String，而去使用hashmap</h3><ol>\n<li>因为String浪费空间很严重，假如去存放一个数字，String的RedisObejct占16字节，它的DictEntry占24字节，这就使用了40字节，而你有效的存储只用了8字节</li>\n<li>如果用hashmap，在存储数字时，它会使用压缩列表的结构，可以存放很多很多数组，浪费空间还很小！</li>\n</ol>\n<h3 id=\"Redis是单线程的吗？\"><a href=\"#Redis是单线程的吗？\" class=\"headerlink\" title=\"Redis是单线程的吗？\"></a>Redis是单线程的吗？</h3><p>Redis严格意义上来说并不是单线程的，所谓的单线程指的是从网络IO到键值对获取这个过程是单线程的</p>\n<h3 id=\"Redis为什么这么快？\"><a href=\"#Redis为什么这么快？\" class=\"headerlink\" title=\"Redis为什么这么快？\"></a>Redis为什么这么快？</h3><ol>\n<li><p>单线程，无需加锁，十分快速</p>\n</li>\n<li><p>底层数据结构优化的很好</p>\n<ul>\n<li>跳表</li>\n<li>两个全局哈希表，交替扩容，渐进式rehas</li>\n</ul>\n</li>\n<li><p>IO多路复用</p>\n<ul>\n<li><p>采用linux的epoll模型</p>\n</li>\n<li><p>epoll模型相较于select、poll</p>\n<ul>\n<li><p>不受文件描述符的限制</p>\n</li>\n<li><p>支持水平触发和边缘触发两种方式<br>水平触发（select只提供这种）  持续通知 没有被处理会一直通知</p>\n<p>边缘触发 通知一次 只会通知一次</p>\n</li>\n</ul>\n</li>\n<li><p>只支持linux操作系统</p>\n</li>\n<li><p>fd每次需要遍历所有的fd，epoll只需要遍历那些就绪的fd</p>\n</li>\n</ul>\n</li>\n</ol>\n","categories":["八股","数据库"],"tags":["数据库","Redis"]},{"title":"Spring","url":"/2024/04/07/Spring/","content":"<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><blockquote>\n<p>还不完全，不是从基础开始的，慢慢补充</p>\n</blockquote>\n<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><blockquote>\n<p>Inversion of Control，控制反转</p>\n</blockquote>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>Ioc是一种设计思想，将对象的创建和依赖关系的管理从程序代码中转移到容器（也就是Spring容器）中。</li>\n<li>简单类比来说，类似于做饭和点外卖的区别。</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><blockquote>\n<p>Aspect - Oriented Programming，面向切面编程</p>\n</blockquote>\n<h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>AOP是一种编程范式，允许将横切关注点（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来。在传统的面向对象编程中，这些横切关注点往往会分散在各个业务逻辑方法中，导致代码混乱难以维护。</li>\n<li>例如，在一个电商系统中，每次调用订单处理的业务方法都需要记录日志。没有AOP，可能需要再每个订单处理方法中添加日志记录代码。使用AOP后，可以将日志记录代码集中到一个切面（Aspect）中，然后通过配置来决定在哪些业务方法（切点，PointCut）执行前、执行后或者执行过程中（通知，Advice）来执行日志记录的操作。</li>\n</ul>\n<h3 id=\"切面、切点、通知\"><a href=\"#切面、切点、通知\" class=\"headerlink\" title=\"切面、切点、通知\"></a>切面、切点、通知</h3><ul>\n<li><p>切面<br>一个模块化的横切关注点，包含了切点和通知。可以把切面想象成一个包含了特定功能（如日志记录功能的模块）。例如，一个日志记录切面包含了记录日志的通知和定义了哪些方法需要记录日志的切点。</p>\n</li>\n<li><p>切点<br>用于定义在哪些连接点上应用切面的通知。例如，可以定义一个切点为“所有以create开头的方法”，那么只要方法名符合这个规则，切面的通知就会在这些方法的相应位置执行。</p>\n</li>\n<li><p>通知</p>\n<p>定义了切面在切点所指定的连接点上要执行的具体操作。主要有以下几种类型：</p>\n<ul>\n<li>前置通知：在目标方法执行之前执行。例如，在调用订单创建方法之前，可以在前置通知中进行权限检查。</li>\n<li>后置通知：在目标方法执行之后执行，无论方法是否抛出异常。可以用于清理资源等操作。</li>\n<li>返回通知：在目标方法正常返回后执行。比如可以在订单查询方法正常返回后记录查询结果。</li>\n<li>异常通知：在目标方法抛出异常后执行。例如，在订单处理方法抛出异常后，可以在异常通知中记录异常信息。</li>\n<li>环绕通知：环绕目标方法执行，可以在方法执行前后都进行操作，并且可以控制目标方法是否真正执行。比如在事务管理中，环绕通知可以控制事务的开启、提交和回滚。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><ol>\n<li><p>@Aspect</p>\n<p>定义一个类为切面类，表名这个类包含了横切关注点的逻辑，如日志记录、事务管理等。</p>\n</li>\n<li><p>@Before<br>定义前置通知，即在目标方法执行之前执行切面中的方法。</p>\n</li>\n<li><p>@After</p>\n<p>定义后置通知，在目标方法执行之后执行，无论目标方法是否抛出异常。</p>\n</li>\n<li><p>@AterReturning</p>\n<p>定义返回通知，在目标方法正常返回后执行。</p>\n</li>\n<li><p>@AfterThrowing<br>定义异常通知，在目标方法抛出异常后执行。</p>\n</li>\n<li><p>@Around<br>定义环绕通知，环绕目标方法执行，可以在方法执行前后都进行操作，并且可以控制目标方法是否真正执行。</p>\n</li>\n<li><p>@PointCut</p>\n<p>用于定义可复用的切点表达式。可以将复杂的切点表达式提取出来，在多个通知中重复使用。</p>\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userServiceMethods</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;userServiceMethods()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method execution in UserService&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>首先通过<code>@Pointcut</code>定义了一个名为<code>userServiceMethods</code>的切点，表示<code>UserService</code>类中的所有方法。然后在<code>@Before</code>通知中可以直接引用这个切点，这样如果需要修改切点表达式，只需要在<code>@Pointcut</code>定义处修改，而不需要在每个通知中都修改。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"bean自动装配\"><a href=\"#bean自动装配\" class=\"headerlink\" title=\"bean自动装配\"></a>bean自动装配</h2><blockquote>\n<p>开启自动装配，只需要在xml配置文件&lt;bean&gt;中定义”autowire”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;customer&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Customer&quot;</span> autowire=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>autowire</strong>属性五种装配方式</p>\n<ul>\n<li><p>no-缺省情况下，自动配置是通过”ref”属性手动设定<br>手动装配：以value或ref的方式明确指定属性值都是手动装配。<br>需要通过’ref’属性来连接bean。</p>\n</li>\n<li><p>byName-根据bean的属性名称进行自动装配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cutomer的属性名称是person, Spring会将bean id为person的bean通过setter方法进行自动装配</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;customer&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Customer&quot;</span> autowire=<span class=\"string\">&quot;byName&quot;</span>/&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;person&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Person&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>byType-根据bean的类型名称进行自动装配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cutomer的属性person的类型为Person Spring会将Person类型通过setter方法进行自动装配</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;customer&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Customer&quot;</span> autowire=<span class=\"string\">&quot;byType&quot;</span>/&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;person&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Person&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constructor-类似byType，不过是应用于构造器的参数。如果一个bean于构造器参数的类型相同，则进行自动装配，否则导致异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Customer构造函数的参数person类型为Person，Spring会将Person类型通过构造方法进行自动装配</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;customer&quot;</span> class=<span class=\"string\">&quot;com.xxx.xxx.Customer&quot;</span> autowire=<span class=\"string\">&quot;constructor&quot;</span>/&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;person class=&quot;</span>com.xxx.xxx.Person<span class=\"string\">&quot;/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配</p>\n</li>\n</ul>\n<p>@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用</p>\n<h2 id=\"SpringMVC工作流程\"><a href=\"#SpringMVC工作流程\" class=\"headerlink\" title=\"SpringMVC工作流程\"></a>SpringMVC工作流程</h2><ol>\n<li>用户发送请求至前端控制器DispatcherServlet</li>\n<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>\n<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li>\n<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>\n<li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫作后端控制器）</li>\n<li>Controller执行完成返回ModelAndView</li>\n<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>\n<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>\n<li>ViewReslover解析后返回具体View</li>\n<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li>\n<li>DispatcherServlet响应用户</li>\n</ol>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240604170420580.png\" alt=\"image-20240604170420580\"></p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240604171610045.png\" alt=\"image-20240604171610045\"></p>\n<h2 id=\"SpringBoot自动配置原理\"><a href=\"#SpringBoot自动配置原理\" class=\"headerlink\" title=\"SpringBoot自动配置原理\"></a>SpringBoot自动配置原理</h2><p>@import + @Configuration + Spring spi</p>\n<p>自动配置类由各个starter提供，使用@Configuration  @Bean定义配置类，放到META-INF&#x2F;spring.factories下</p>\n<p>使用Spring spi扫描META-INF&#x2F;spring.factories下的配置类<br>使用@Import导入自动配置类<br><img data-src=\"https://img.jyhmw.cn/image-20240604172730738.png\" alt=\"image-20240604172730738\"></p>\n<p><strong>如何理解starter？</strong></p>\n<p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</p>\n<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF&#x2F;spring.factories中写入该配置类，springboot会按照约定来加载该配置类</p>\n<p>开发人员只需要将相应的starter包依赖进引用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot-starter，spring-boot-starter-redis</p>\n<h2 id=\"关于Tomcat\"><a href=\"#关于Tomcat\" class=\"headerlink\" title=\"关于Tomcat\"></a>关于Tomcat</h2><p>springboot已经内置了tomcat.jar，运行main方法时回去启动tomcat，并利用tomcat的spi机制加载springmvc</p>\n<h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><ol>\n<li><p>实例化Bean</p>\n<ul>\n<li>两个容器<ul>\n<li>ApplicationContext  一次性载入所有容器</li>\n<li>BeanFactory  延迟加载</li>\n</ul>\n</li>\n<li>主要任务：将类实例化为对象<ul>\n<li>调用对象的构造函数</li>\n<li>实例化后的对象会被封装在BeanWrapper中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设置对象属性（DI依赖注入）：给对象属性赋值</p>\n</li>\n<li><p>处理Aware接口</p>\n<blockquote>\n<p>如果对象实现了Aware接口，此时就调用</p>\n</blockquote>\n<ul>\n<li>BeanNameAware setBeanName</li>\n<li>BeanClassLoader setBeanClassLoader</li>\n<li>BeanFactoryAware setBeanFactory</li>\n<li>ApplicationContextAware setApplicationContext</li>\n</ul>\n</li>\n<li><p>BeanPostProcessor 前置处理</p>\n<ul>\n<li>实现了AOP，可以用这个接口实现一些前置处理</li>\n<li>调用的是 postProcessBeforeInitialization(Object obj, String s)方法</li>\n</ul>\n</li>\n<li><p>InitializingBean 初始化Bean </p>\n</li>\n<li><p>init-method</p>\n</li>\n<li><p>BeanPostProcessor 后置处理</p>\n</li>\n<li><p>Bean 可以使用了</p>\n</li>\n<li><p>DisposableBean bean此时进入清理阶段，如果有什么处理，就实现这个接口，调用destory方法</p>\n</li>\n<li><p>Destory-method</p>\n</li>\n</ol>\n","categories":["技术栈"],"tags":["框架","Spring"]},{"title":"Zookeeper","url":"/2024/12/05/Zookeeper/","content":"<h1 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h1><blockquote>\n<p>Zookeeper是一个开源的分布式的，伪分布式框架提供协调服务的Apache项目。ZooKeeper是一个高可用的分布式数据管理和协调框架，并且能够很好的保证分布式环境中数据的一致性。 在越来越多的分布式系统（Hadoop、HBase、Kafka）中，Zookeeper都作为核心组件使用。</p>\n</blockquote>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><p>从<strong>设计模式</strong>角度理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的哪些观察者做出相应的反应。</p>\n<p>Zookeeper &#x3D; 文件系统 + 通知机制</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>一个领导者，多个跟随者组成的集群</li>\n<li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所 以Zookeeper适合安装奇数台服务器</li>\n<li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</li>\n<li>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行</li>\n<li>数据更新原子性，一次数据更新要么成功，要么失败</li>\n<li>实时性，在一定时间范围内，Client能读到最新数据</li>\n</ol>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识。</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241205104652615.png\" alt=\"image-20241205104652615\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"统一命名服务\"><a href=\"#统一命名服务\" class=\"headerlink\" title=\"统一命名服务\"></a>统一命名服务</h3><p>在分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别，例如：IP不容易记住，而域名容易记住。</p>\n<img data-src=\"https://img.jyhmw.cn/image-20241205105134315.png\" alt=\"image-20241205105134315\" style=\"zoom: 67%;\" />\n\n<h3 id=\"统一配置管理\"><a href=\"#统一配置管理\" class=\"headerlink\" title=\"统一配置管理\"></a>统一配置管理</h3><ul>\n<li><p>分布式环境下，配置文件同步非常常见</p>\n<ol>\n<li>一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群</li>\n<li>对配置文件修改后，能够快速同步到各个节点上</li>\n</ol>\n</li>\n<li><p>配置管理可交友Zookeeper实现</p>\n<ol>\n<li>将配置信息写入Zookeeper上的一个Znode</li>\n<li>各个客户端服务器监听这个Znode</li>\n<li>一旦Znode中的数据被修改，Zookeeper将通知各个客户端服务器</li>\n</ol>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241205105434906.png\" alt=\"image-20241205105434906\"></p>\n</li>\n</ul>\n<h3 id=\"统一集群管理\"><a href=\"#统一集群管理\" class=\"headerlink\" title=\"统一集群管理\"></a>统一集群管理</h3><ul>\n<li>分布式环境中，实时掌握每个节点的状态，根据节点实时状态做出一些调整</li>\n<li>Zookeeper可以实现监控节点状态变化<ol>\n<li>可将节点信息写入Zookeeper上的一个Znode</li>\n<li>监听这个ZNode可获取它的实时状态的变化</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"服务器动态上下线\"><a href=\"#服务器动态上下线\" class=\"headerlink\" title=\"服务器动态上下线\"></a>服务器动态上下线</h3><p>客户端能实时观察到服务器上下线的变化</p>\n<h3 id=\"软负载均衡\"><a href=\"#软负载均衡\" class=\"headerlink\" title=\"软负载均衡\"></a>软负载均衡</h3><p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p>\n<h1 id=\"结合项目\"><a href=\"#结合项目\" class=\"headerlink\" title=\"结合项目\"></a>结合项目</h1><blockquote>\n<p>这里结合了一个rpc的项目，在此项目中使用Zookeeper作为服务注册中心</p>\n</blockquote>\n<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><ol>\n<li>构建一个ArrayList 存放的都是 RpcServiceInfo(服务名和版本信息)</li>\n<li>再把这个ArrayList + 主机号 + 端口号 封装成一个rpcProtocol</li>\n<li>使用Jackson进行序列化转换</li>\n<li>使用Curator客户端创建Zookeeper节点(路径根据工具类中规定的)</li>\n<li>给新创建的Zookeeper节点添加监听器</li>\n<li>完成注册</li>\n</ol>\n<h2 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h2><ol>\n<li>仍然是使用Curator客户端，读取节点数据</li>\n<li>反序列化为RpcProtocol</li>\n<li>读取服务地址，连接到不同的服务节点</li>\n<li>这时会更新Zookeeper信息到本地，这样才能根据不同的节点实现负载均衡</li>\n</ol>\n","categories":["技术栈"],"tags":["Zookeeper","分布式"]},{"title":"SpringCloud微服务","url":"/2024/06/03/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/","content":"<h1 id=\"架构演进\"><a href=\"#架构演进\" class=\"headerlink\" title=\"架构演进\"></a>架构演进</h1><h2 id=\"单体架构\"><a href=\"#单体架构\" class=\"headerlink\" title=\"单体架构\"></a>单体架构</h2><blockquote>\n<p>Monolithic</p>\n<p>单体只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已。</p>\n</blockquote>\n<p>​\t\t首先单体架构并不是一个“反派角色”。单体架构，在整个软件架构演进的历史进程里，是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格。“单体”这个名称，是在微服务开始流行之后才“事后追认”所形成的概念。</p>\n<p>​\t\t对于小型系统—即单台机器就足以支撑良好运行的系统，单体不仅仅易于开发、易于测试、易于部署且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（IPC，可以认为RPC属于IPC的一种特例），因此也是运行效率最高的一种架构风格，完全不应该被贴上反派角色的标签。</p>\n<h2 id=\"SOA\"><a href=\"#SOA\" class=\"headerlink\" title=\"SOA\"></a>SOA</h2><blockquote>\n<p>SOA架构（Service-Oriented Architecture）</p>\n<p>面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式</p>\n</blockquote>\n<p>​\t\tSOA，将应用程序不同功能单元（称为服务）通过定义良好的接口和契约联系起来。这些服务是独立的、可复用的组件，可以在不同的系统和应用程序中被调用，以实现特定的业务功能。</p>\n<p>​\t\t但是，在处理大规模复杂系统时，由于倾向于构建企业级的服务总线（ESB）连接各个服务，导致整个架构变得非常复杂。随着业务的增长和服务数量的增加，ESB会称为一个庞大而复杂的中心枢纽，其中包含大量的消息转换、路由规则配置，使得系统的维护和理解成本极高。</p>\n<p>​\t\t到这里，“如何使用多个独立的分布式服务共同构建一个更大型的系统”，“让开发人员不必关心服务是远程还是本地，都能够透明地调用服务或者访问资源”，引出了<strong>微服务</strong>。</p>\n<h2 id=\"微服务时代\"><a href=\"#微服务时代\" class=\"headerlink\" title=\"微服务时代\"></a>微服务时代</h2><blockquote>\n<p>微服务架构（Microservices）</p>\n<p>微服务是一种通过多个小型服务来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准构建。各个服务都可以采用不同的编程语言，不同的数据存储技术，运行在不同进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>\n</blockquote>\n<p>​\t\t一开始，微服务是作为SOA的一种变体被提出来的，后来成为了经过不停地更新、蜕变发展才有了现代微服务。文章《<a href=\"https://martinfowler.com/articles/microservices.html\">Microservices: A Definition of This New Architectural Term</a>》中是这样描写的:“通过多个小型组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维”。</p>\n<p>后面还有后微服务时代和无服务时代先不做了解。</p>\n<p>以上全是来自对 <a href=\"https://icyfenix.cn/architecture/architect-history/post-microservices.html\">凤凰架构</a>中的简单摘要，以了解为何要应用微服务，为何要学习微服务。</p>\n<h1 id=\"SpringCloud\"><a href=\"#SpringCloud\" class=\"headerlink\" title=\"SpringCloud\"></a>SpringCloud</h1><p><strong>注：</strong>暂时先将了解先不实践，了解完后需要不上实践代码以及过程。</p>\n<blockquote>\n<p>是微服务架构落地的一套技术栈，其中大多数技术都是基于Netflix（奈飞）公司的技术进行二次研发。</p>\n<p>包括以下技术点：</p>\n<ul>\n<li>Eureka-服务注册与发现</li>\n<li>Ribbin-服务负载均衡</li>\n<li>Feign-服务之间的通讯</li>\n<li>Hystrix-服务的线程隔离以及断路器</li>\n<li>Zuul-服务网关</li>\n<li>Stream-实现MQ的使用</li>\n<li>Config-动态配置</li>\n<li>Sleuth-服务追踪</li>\n</ul>\n</blockquote>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><blockquote>\n<p>服务注册中心：把所有服务的信息都告诉服务注册中心(Eureka、Consul、Nacos、Zookeeper)</p>\n<p>Eureka帮助我们维护所有服务的信息，以便服务之间的相互调用</p>\n</blockquote>\n<h2 id=\"服务负载均衡\"><a href=\"#服务负载均衡\" class=\"headerlink\" title=\"服务负载均衡\"></a>服务负载均衡</h2><blockquote>\n<p>Ribbin是帮助我们实现服务和服务负载均衡，Ribbin属于客户端负载均衡（服务端负载均衡）</p>\n<p>客户端负载均衡：customer客户模块，将2个Search模块信息全部拉取到本地的缓存，在customer中自己做一个负载均衡的策略，选中某一个服务。</p>\n<p>服务端负载均衡：在注册中心中，直接根据你指定的负载均衡策略，帮你选中一个指定的服务信息，并返回。</p>\n</blockquote>\n<h2 id=\"服务间调用\"><a href=\"#服务间调用\" class=\"headerlink\" title=\"服务间调用\"></a>服务间调用</h2><blockquote>\n<p>Feign 帮助我们实现面向接口编程，直接调用其他服务，简化开发。</p>\n</blockquote>\n<h2 id=\"服务隔离断路\"><a href=\"#服务隔离断路\" class=\"headerlink\" title=\"服务隔离断路\"></a>服务隔离断路</h2><blockquote>\n<p>Hystrix解决服务雪崩问题</p>\n<ol>\n<li>降级机制：当某一个服务出现超时，资源不足出现了异常时，可执行一个降级方法，返回一个拖底数据</li>\n<li>隔离：提供了一个Hystrix线程池，信号量，和Tomcat的线程池相互隔离</li>\n<li>熔断：当某个服务的失败率达到一定的阈值时，自动触发降级</li>\n<li>缓存：请求缓存的功能</li>\n</ol>\n</blockquote>\n<p>服务网关</p>\n<blockquote>\n<p>Zuul</p>\n<p>GateWay</p>\n<ul>\n<li>客户端维护大量的ip和port信息，直接访问指定服务</li>\n<li>认证和授权操作，需要在每一个模块中都添加认证和授权的操作</li>\n<li>项目的迭代，服务要拆分，服务要合并，需要客户端进行大量的变化</li>\n<li>统一的把安全性校验都放在Zuul中</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20241125162555869.png\" alt=\"image-20241125162555869\"></p>\n<h2 id=\"多语言支持\"><a href=\"#多语言支持\" class=\"headerlink\" title=\"多语言支持\"></a>多语言支持</h2><blockquote>\n<p>Sidecar</p>\n<p>在SpringCloud的项目中，需要接入一些非Java的程序，第三方接口，无法接入eureka，hystrix，feign等等组件。启动一个代理的微服务，代理微服务去和非Java的程序或第三方接口交流，通过代理的微服务去计入SpringCloud的相关组件。</p>\n</blockquote>\n<h2 id=\"服务间消息传递\"><a href=\"#服务间消息传递\" class=\"headerlink\" title=\"服务间消息传递\"></a>服务间消息传递</h2><blockquote>\n<p>Stream就是在消息队列的基础上，对其进行封装，让咱们更方便的去操作MQ消息队列（Kafka、RabbitMQ）。</p>\n</blockquote>\n<h2 id=\"服务的动态配置\"><a href=\"#服务的动态配置\" class=\"headerlink\" title=\"服务的动态配置\"></a>服务的动态配置</h2><blockquote>\n<ul>\n<li>配置文件分散在不同的项目中，不方便维护。</li>\n<li>配置文件的安全问题。</li>\n<li>修改完配置文件，无法立即生效。</li>\n</ul>\n<p>所以有了一个统一的动态配置</p>\n</blockquote>\n<h2 id=\"服务追踪\"><a href=\"#服务追踪\" class=\"headerlink\" title=\"服务追踪\"></a>服务追踪</h2><blockquote>\n<p>在整个微服务架构中，微服务很多，一个请求可能需要调用很多很多的服务，最终才能完成一个功能，如果说，整个功能出现了问题，在这么多的服务中，如何去定位到问题的所在点，出现问题的原因是什么。</p>\n<p>Sleuth可以获得到整个服务链路的信息。</p>\n<p>Zipkin通过图形化界面去看到信息。</p>\n<p>Sleuth将日志信息存储到数据库中。</p>\n</blockquote>\n<h2 id=\"架构图（大概）\"><a href=\"#架构图（大概）\" class=\"headerlink\" title=\"架构图（大概）\"></a>架构图（大概）</h2><p><img data-src=\"https://img.jyhmw.cn/image-20241125170551473.png\" alt=\"image-20241125170551473\"></p>\n","categories":["技术栈","Spring"],"tags":["Spring","微服务"]},{"title":"RpcProject","url":"/2024/04/07/RpcProject/","content":"<h1 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h1><h2 id=\"概述？\"><a href=\"#概述？\" class=\"headerlink\" title=\"概述？\"></a>概述？</h2><blockquote>\n<p>Netty是一个异步的、基于事件驱动的网络应用框架</p>\n</blockquote>\n<p>引入Netty</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependency&gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.39.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>五大部件</strong></p>\n<ol>\n<li>EventLoop &amp; EventLoopGroup</li>\n<li>Channel &amp; ChannelFuture</li>\n<li>Future &amp; Promise</li>\n<li>Handler &amp; Pipeline</li>\n<li>ByteBuf</li>\n</ol>\n<h2 id=\"EventLoop-EventLoopGroup\"><a href=\"#EventLoop-EventLoopGroup\" class=\"headerlink\" title=\"EventLoop &amp; EventLoopGroup\"></a>EventLoop &amp; EventLoopGroup</h2><blockquote>\n<p>EventLoop(事件循环)，相当于一个单线程执行器，维护了一个selector</p>\n</blockquote>\n<p>作用：内部有run方法处理channel上源源不断的IO事件</p>\n<h3 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h3><p>EventLoop的继承</p>\n<ul>\n<li>继承EventExcutor，内部有方法可以查看EventLoop属于的组，以及判断一个线程属不属于此EventLoop</li>\n</ul>\n<p><strong>核心API</strong></p>\n<ul>\n<li>可以通过EventLoop的next方法获得</li>\n<li>excute(Runnable)执行任务</li>\n<li>submit(Runnable)执行任务，返回一个Future对象</li>\n<li>scheduleAtFixedRate(Runnable, initialDelay, period, TimeUnit)执行定时任务</li>\n</ul>\n<blockquote>\n<p>EventLoopGroup(事件循环组)：内部包含一组EventLoop</p>\n</blockquote>\n<p>常用的实现类：</p>\n<ul>\n<li><code>NioEventLoopGroup</code>：负责处理 <strong>IO 事件、普通任务、定时任务</strong></li>\n<li><code>DefaultEventLoopGroup</code>：负责处理<strong>普通任务、定时任务</strong></li>\n</ul>\n<p>核心 API：</p>\n<ul>\n<li><code>new NioEventLoopGroup(int)</code>：创建一个 NioEventLoopGroup，参数是 int 类型的值，如果不传，按默认的值来设置</li>\n<li>next()：获得下一个EventLoop对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">group1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">5</span>); <span class=\"comment\">//此对象可以处理： io事件、普通任务、定时任务</span></span><br><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">group2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(); <span class=\"comment\">//此对象可以处理： 普通任务、定时任务</span></span><br><span class=\"line\">group1.execute(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行普通任务&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">group1.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行定时任务&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行IO请求\"><a href=\"#执行IO请求\" class=\"headerlink\" title=\"执行IO请求\"></a>执行IO请求</h3><p>NioEventLoopGroup可以处理三种任务：IO事件、普通任务、定时任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    <span class=\"comment\">// 这一步就是创建EventLoopGroup</span></span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    <span class=\"comment\">// 设置通道</span></span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进行处理</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    log.debug(byteBuf.toString(Charset.defaultCharset()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务分工与细化\"><a href=\"#任务分工与细化\" class=\"headerlink\" title=\"任务分工与细化\"></a>任务分工与细化</h3><h4 id=\"分工\"><a href=\"#分工\" class=\"headerlink\" title=\"分工\"></a>分工</h4><p>boss负责ACCEPT请求，worker负责写请求，在Netty的任务可以细分</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootStrap</span>()</span><br><span class=\"line\">    <span class=\"comment\">//这里可以指定两个EventLoopGroup</span></span><br><span class=\"line\">    <span class=\"comment\">//第一个就是boss，第二个就是worker</span></span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"细化\"><a href=\"#细化\" class=\"headerlink\" title=\"细化\"></a>细化</h4><blockquote>\n<p>如果有比较重量级的操作，可以单独分配一个EventLoopGroup来专门执行这种重量级操作，以免阻塞其他任务</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//【细化】让一个group专门去做耗时的工作</span></span><br><span class=\"line\"><span class=\"type\">EventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    <span class=\"comment\">// 【分工】：这里可以指定两个EventLoopGroup</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一个就是boss，第二个就是worker</span></span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"string\">&quot;handler1&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    log.debug(byteBuf.toString(Charset.defaultCharset()));</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;handler1&quot;</span>);</span><br><span class=\"line\">                    ctx.fireChannelRead(msg);<span class=\"comment\">// 这个方法可以传msg到下一个handler</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).addLast(group,<span class=\"string\">&quot;handler2&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;handler2&quot;</span>);</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Channel-ChannelFuture\"><a href=\"#Channel-ChannelFuture\" class=\"headerlink\" title=\"Channel &amp; ChannelFuture\"></a>Channel &amp; ChannelFuture</h2><blockquote>\n<p>channel：一个到实体的开放连接</p>\n<p>实体包括一个硬件设备、一个文件、一个Socket等等内容</p>\n</blockquote>\n<p>类似于NIO通道，Netty的Channel本身也是对Channel的封装</p>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li><code>close()</code> 可以用来关闭 channel</li>\n<li><code>closeFuture()</code>:用来处理 channel 的关闭，可以附加其他操作<ul>\n<li><code>sync</code> 方法作用是<strong>同步</strong>等待 channel 关闭</li>\n<li><code>addListener</code><strong>异步</strong>等待 channel 关闭</li>\n</ul>\n</li>\n<li><code>pipeline()</code>：方法<strong>添加处理器</strong></li>\n<li><code>write()</code> 方法将数据写入（<strong>写入发送缓冲区</strong>，但不一定立即发送，可能达到一定大小，才会发送出去）</li>\n<li><code>writeAndFlush()</code>:将数据立刻写入并刷出（写入缓冲区并且立即发送）<ul>\n<li>这个方法相当于调用 <code>write()</code> 与 <code>flush()</code> 两个方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ChannelFuture对象\"><a href=\"#ChannelFuture对象\" class=\"headerlink\" title=\"ChannelFuture对象\"></a>ChannelFuture对象</h3><blockquote>\n<p>ChannelFuture：异步 IO 操作的返回结果（成功、失败、或是取消）</p>\n</blockquote>\n<p>由于Netty中所有IO操作都是异步的，这意味着任何IO调用都将立即返回，但不保证请求的IO操作已经在调用结束时完成</p>\n<p>所以就有了channelFuture这个对象，用于在某个时间点确定结果</p>\n<p><strong>比如：</strong>客户端连接操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"comment\">// 获得ChannelFuture对象</span></span><br><span class=\"line\">channelFuture</span><br><span class=\"line\">    <span class=\"comment\">//.sync() // 我们现在不去调用同步方法</span></span><br><span class=\"line\">    .channel()</span><br><span class=\"line\">    .writeAndFlush(<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>执行会发现，不会给服务器发送hello world的信息</p>\n<blockquote>\n<p>？为什么</p>\n</blockquote>\n<p>因为Netty是异步非阻塞的，main线程发起调用，但其实是创建了一个新的NIO线程来执行connect()操作，这个连接操作很费时</p>\n<p>而main线程调用完后，会立即向下执行（由于非阻塞），因此获得的channel对象不是成功建立连接后的对象，发消息也就发不出去了</p>\n<blockquote>\n<p>如何解决？</p>\n</blockquote>\n<ul>\n<li>【法一】调用 <code>sync</code> 方法，这个方法会让 main 线程与运行 connect 的线程同步（即阻塞 <code>main</code> 线程直到 <code>channel</code> 创建完成）</li>\n<li>【法二】调用 <code>addListener(回调对象)</code>，传入一个 <code>GenericFutureListener</code> 接口，我们可以传入其子接口 <code>ChannelFutureListener</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">channelFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">// operationComplete方法会由执行NIO的线程执行完成后调用</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> future.channel();</span><br><span class=\"line\">        channel.writeAndFlush(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<p> <code>Channel</code> 对象的关闭与连接一样，都是由另外的线程真正执行的关闭操作，<code>Channel</code> 对象可以调用 <code>sync</code> 同步或者 <code>addListener</code> 异步来执行通道关闭后的操作</p>\n</blockquote>\n<h2 id=\"Future-Promise\"><a href=\"#Future-Promise\" class=\"headerlink\" title=\"Future&amp;Promise\"></a>Future&amp;Promise</h2><blockquote>\n<p>Future是另一种在操作完成时通知APP的方式</p>\n<p>（还有一种是回调方法，比如新的连接建立触发;channelActive()）</p>\n</blockquote>\n<p>JUC 也有 Future 对象，Netty 的 Future 继承了 JUC 的 Future，Promise 是对 Netty Future 的进一步扩展</p>\n<blockquote>\n<p>一句话：<code>Promise</code> 继承 netty<code>Future</code>；netty <code>Future</code> 继承 JUC <code>Future</code></p>\n</blockquote>\n<p>区别：</p>\n<ul>\n<li>JDK <code>Future</code> 只能同步等待任务结束，才能得到结果</li>\n<li>Netty <code>Future</code> 可以同步 &#x2F; 异步等待任务结束，然后获得结果</li>\n<li><code>Promise</code> 不仅有 Future 的功能，而且<strong>脱离了任务独立存在，作为两个线程间传递结果的容器</strong></li>\n</ul>\n<p><strong>核心API对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>JDK Future</th>\n<th>Netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cancel</code></td>\n<td>取消任务</td>\n<td>继承</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>isCanceled</code></td>\n<td>判断任务是否取消</td>\n<td>继承</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>isDone</code></td>\n<td>判断任务是否结束（成功 &#x2F; 失败）</td>\n<td>继承</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>get</code></td>\n<td>获得结果（阻塞等待）</td>\n<td>继承</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>getNow</code></td>\n<td>无</td>\n<td>获取任务结果，非阻塞，会先立即返回 null</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>await</code></td>\n<td>无</td>\n<td>等待任务结束（任务失败<strong>不会抛出异常</strong>）</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>sync</code></td>\n<td>无</td>\n<td>等待任务结束（任务失败<strong>抛出异常</strong>）</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>isSuccess</code></td>\n<td>无</td>\n<td>判断任务是否成功</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>cause</code></td>\n<td>无</td>\n<td>获取失败信息（非阻塞），如果没有失败返回 null</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>addListener</code></td>\n<td>无</td>\n<td>添加回调，异步接收结果</td>\n<td>继承</td>\n</tr>\n<tr>\n<td><code>setSuccess</code></td>\n<td>无</td>\n<td>无</td>\n<td>设置成功返回的结果</td>\n</tr>\n<tr>\n<td><code>setFailure</code></td>\n<td>无</td>\n<td>无</td>\n<td>设置失败返回的结果</td>\n</tr>\n</tbody></table>\n<h2 id=\"事件-ChannelHandler-ChannelPipeLine\"><a href=\"#事件-ChannelHandler-ChannelPipeLine\" class=\"headerlink\" title=\"事件&amp;ChannelHandler&amp;ChannelPipeLine\"></a>事件&amp;ChannelHandler&amp;ChannelPipeLine</h2><blockquote>\n<p>事件：某些动作完成时发送的消息</p>\n</blockquote>\n<p>入站端的事件比如有：连接已激活或失活、数据读取、用户事件、错误事件</p>\n<p>出站事件：打开关闭远程节点的连接、数据写到或冲刷到套接字</p>\n<blockquote>\n<p><code>ChannelHandler</code>：处理 IO 事件或拦截 IO 操作，并将其转发到其 PipeLine 中的下一个 handler（可以理解为一道工序）</p>\n</blockquote>\n<p>简单的我们可以理解为：是<strong>一个可以响应不同事件的回调方法</strong></p>\n<p>这里有个图，很好的表示了事件和 <code>ChannelHandler</code> 的关系</p>\n<p><img data-src=\"https://img.jyhmw.cn/image-20220801201224254.png\" alt=\"img\"></p>\n<p>如图所示，在一个事件发生后，会经过一系列的处理器（即 Handler）最后成功入站或出站</p>\n<blockquote>\n<p><strong>注意</strong>：Netty 服务器至少需要两部分：</p>\n<ul>\n<li>至少一个 <code>ChannelHandler</code></li>\n<li>引导：客户端 Bootstrap、服务端 ServerBootstrap</li>\n</ul>\n<p>引导的作用：为了配置服务器，比如连接服务器到指定的端口</p>\n</blockquote>\n<blockquote>\n<p><code>ChannelPipeLine</code>：一个 Handler 的列表（可以理解为一条流水线）或者说是 ChannelHander 的容器</p>\n</blockquote>\n<h3 id=\"InboundHandler\"><a href=\"#InboundHandler\" class=\"headerlink\" title=\"InboundHandler\"></a>InboundHandler</h3><p>有两种 <code>ChannelHandler</code>，分为入站、出站两种（注意是站，不是栈）</p>\n<h4 id=\"ChannelInboundHandlerAdapter\"><a href=\"#ChannelInboundHandlerAdapter\" class=\"headerlink\" title=\"ChannelInboundHandlerAdapter\"></a>ChannelInboundHandlerAdapter</h4><blockquote>\n<p><code>ChannelHandler</code> 是一个父接口，使用需要重写很多方法，所以实现时，我们可以使用他们的适配器 <code>Adapter</code> 的子类，来很快的达到目的</p>\n</blockquote>\n<p>入站处理器通常是 <code>ChannelInboundHandlerAdapter</code> 的子类，下面是它的相关事件的<strong>回调</strong></p>\n<p>（所谓回调：当触发对应事件的时候，会调用相关方法）</p>\n<ul>\n<li><code>channelRead()</code>：每个消息传入都会调用此方法</li>\n<li><code>channelReadComplete()</code>：当前批量读取的最后一条消息会触发此方法</li>\n<li><code>exceptionCaught()</code>：读取操作发生异常会调用此方法</li>\n</ul>\n<h4 id=\"SimpleChannelInboundHandler\"><a href=\"#SimpleChannelInboundHandler\" class=\"headerlink\" title=\"SimpleChannelInboundHandler\"></a>SimpleChannelInboundHandler</h4><p>此类是 <code>ChannelInboundHandlerAdapter</code> 的子类，它的相关回调有：</p>\n<ul>\n<li><code>channelActive()</code>：当连接建立后将被调用</li>\n<li><code>channelRead0()</code>：收到一条消息就被调用</li>\n<li><code>exceptionCaught()</code>：读取操作发生异常会调用此方法</li>\n</ul>\n<blockquote>\n<p>注意：<code>channelRead0</code> 可能会执行很多次，因为由服务器发送的消息可能会被分块接收。</p>\n<p>也就是说，如果服务器发送了 5 字节，那么不能保证这 5 字节会被一次性接收</p>\n</blockquote>\n<p>那么 <code>SimpleChannelInboundHandler</code> 和他的父类 <code>ChannelInboundHandlerAdapter</code> 有什么区别呢？</p>\n<p>前者会帮我们释放关于 <code>ByteBuf</code> 的内存引用，而后者没有实现。</p>\n<h3 id=\"OutboundHandler\"><a href=\"#OutboundHandler\" class=\"headerlink\" title=\"OutboundHandler\"></a>OutboundHandler</h3><p>出站处理器通常是 <code>ChannelOutboundHandlerAdapter</code> 的子类，主要用来对写回数据进行加工</p>\n<p>通过通道获取 PipeLine，通过 PipeLine 的 <code>addLast</code> 方法添加处理器</p>\n<h3 id=\"ChannelPipeline-与-Handler-的执行流程\"><a href=\"#ChannelPipeline-与-Handler-的执行流程\" class=\"headerlink\" title=\"ChannelPipeline 与 Handler 的执行流程\"></a>ChannelPipeline 与 Handler 的执行流程</h3><p>PipeLine（或者说 Handler 的执行流程）的结构就是一个<strong>双向链表</strong></p>\n<p>两个特殊的 Handler：一个 <code>head</code>，一个 <code>tail</code></p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img data-src=\"https://img.jyhmw.cn/image-20211008204203210.png\" alt=\"img\"></h3><p>注意：</p>\n<ul>\n<li><code>pipeline.addLast(xxx)</code>：会将 handler 加到 tail 之前，并不是真正的最后</li>\n<li><code>Inbound</code> 负责执行<strong>读操作</strong>，是从 <code>head</code> 开始的</li>\n<li><code>OutBound</code> 负责执行<strong>写操作</strong>，是从 <code>tail</code> 开始的</li>\n</ul>\n<blockquote>\n<p><code>Inboundhandler</code> 内一个 <code>handler</code> 如何传递对象给下一个 <code>handler</code>？</p>\n</blockquote>\n<p>可以通过调用 <code>super.channelRead(ctx,msg);</code> 方法，将想要传递的对象作为 <code>msg</code> 传递给下一个 <code>handler</code>，</p>\n<p>其<strong>内部其实调用的是 <code>fireChannelRead</code> 方法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Skip</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class=\"line\">    ctx.fireChannelRead(msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果某一个 <code>handler</code> 没有调用此方法，那么传递链就会断开</p>\n<blockquote>\n<p><code>channel</code> 的 <code>write</code> 与 <code>ctx</code> 的 <code>write</code> 的区别！（重要）</p>\n</blockquote>\n<p>这两个容易搞混，如图示：</p>\n<ul>\n<li><code>channel</code> 的 <code>write</code> 是从 tail 开始向前找到第一个 <code>Outboundhandler</code>（注意：是从 tail 开始！找的 <code>OutBoundHandler</code>，不找 <code>InboundHandler</code>）</li>\n<li><code>ctx</code> 的 <code>write</code> 是从当前 <code>handler</code> 开始向前找 <code>Outboundhandler</code>（注意：是从当前 <code>handler</code> 开始，也是找的 <code>outboundhandler</code>）</li>\n</ul>\n<h2 id=\"ByteBuf\"><a href=\"#ByteBuf\" class=\"headerlink\" title=\"ByteBuf\"></a>ByteBuf</h2><p>ByteBuf 是 netty 对 NIO ByteBuffer 的一个增强</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>创建一个 <code>ByteBuf</code> 不能直接 new，需要 <code>ByteBufAllocator</code> 来创建</p>\n<ul>\n<li>使用 <code>ByteBufAllocator.DEFAULT.buffer()</code></li>\n<li>默认字节数组长度 256 字节，可以自己指定</li>\n<li>如果存满，会自动扩容（NIO 会报错）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以传入一个Capacity，默认是256字节，而且可以扩容</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class=\"line\">System.out.println(byteBuf);</span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">300</span>; i++) &#123;</span><br><span class=\"line\">    sb.append(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">byteBuf.writeBytes(sb.toString().getBytes());</span><br><span class=\"line\">System.out.println(byteBuf);</span><br><span class=\"line\"><span class=\"comment\">/* 输出：（ridx读指针、widx写指针）</span></span><br><span class=\"line\"><span class=\"comment\">        PooledUnsafeDirectByteBuf(ridx: 0, widx: 0, cap: 256)</span></span><br><span class=\"line\"><span class=\"comment\">        PooledUnsafeDirectByteBuf(ridx: 0, widx: 300, cap: 512)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认创建的就是直接内存，也可以创建堆内存</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ByteBufAllocator.DEFAULT.buffer();<span class=\"comment\">// 默认就创建直接内存</span></span><br><span class=\"line\">ByteBufAllocator.DEFAULT.directBuffer();<span class=\"comment\">// 创建直接内存</span></span><br><span class=\"line\">ByteBufAllocator.DEFAULT.heapBuffer();<span class=\"comment\">// 创建堆内存</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>直接内存与堆内存的区别：</p>\n</blockquote>\n<p>1、管理机制不同：直接内存由 OS 管理，堆内存由 JVM 管理</p>\n<p>2、创建速度：直接内存创建比较麻烦，堆内存创建十分迅速</p>\n<p>综上：</p>\n<p>直接内存的优点是读写性能好（会少一次数据 Copy 的过程），但是创建比较慢，而且需要自己进行释放</p>\n<p>而堆内存的优点是创建速度快，但是读写性能会低一点</p>\n<h3 id=\"池化思想\"><a href=\"#池化思想\" class=\"headerlink\" title=\"池化思想\"></a>池化思想</h3><blockquote>\n<p>为什么ByteBuf 引入池化思想？</p>\n</blockquote>\n<p>Netty采用了直接内存，但是直接内存的缺点是创建比较慢，索引引入了池化思想，优化池功能在4.1前的不成熟，默认是非池化的</p>\n<p>4.1之后，默认是池化创建（非Android平台）</p>\n<p>可以配置参数设置是否开启池化</p>\n<h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><blockquote>\n<p>四部分：废弃部分、可读部分、可写部分、可扩容部分</p>\n</blockquote>\n<p><img data-src=\"https://img.jyhmw.cn/image-20240912190457295.png\" alt=\"image-20240912190457295\"></p>\n<ul>\n<li>有读指针和写指针</li>\n<li>最大容量代表int类型最大值</li>\n</ul>\n<p><strong>相比NIO Buffer， ByteBuffer的优势</strong></p>\n<ol>\n<li>可以扩容（有扩容）</li>\n<li>不必来回切换读写模式（有读指针和写指针）</li>\n</ol>\n<p><strong>扩容规则</strong></p>\n<p>写入后容量大小是否超过512</p>\n<ul>\n<li><p>超过：选择下一个2^n</p>\n</li>\n<li><p>未超过：选择下一个16的整数倍</p>\n</li>\n</ul>\n<p>（扩容不能超过最大容量）</p>\n<h3 id=\"核心API-1\"><a href=\"#核心API-1\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><blockquote>\n<p>写操作</p>\n</blockquote>\n<p>ByteBuf 给每一个基本数据类型都提供了写方法，此处捡重点说一下</p>\n<ul>\n<li><p><code>writeBoolean(boolean)</code>：ByteBuf 内部存储时，使用 0 表示 false，1 表示 true</p>\n</li>\n<li><pre><code>writeInt(int) &amp; writeIntLE(int)\n</code></pre>\n<p>：这两个方法有什么区别呢？</p>\n<ul>\n<li><code>writeInt(int)</code> 就是常用的方法，他是<strong>大端存储</strong>的</li>\n<li><code>writeIntLE(int)</code> 是小端存储的</li>\n</ul>\n</li>\n</ul>\n<p>大端存储 6，其结构就是 <code>0000 0110</code>，而小端存储为 <code>0110 0000</code></p>\n<p>（一般内存设计都是大端存储的，极个别的内存厂商使用小端存储）</p>\n<ul>\n<li><code>writeBytes(xxx)</code>：这个方法可传入的参数非常多，甚至包括 NIO 的 ByteBuf</li>\n<li><code>writeCharSequence(CharSequence子类, 字符集)</code>：这个方法可以传入字符串等等 CharSequence 的子类</li>\n</ul>\n<blockquote>\n<p>读操作</p>\n</blockquote>\n<p>读操作主要的方法有三个</p>\n<ul>\n<li><code>readByte()</code>：读取 1 个字节</li>\n<li><code>readInt()</code>：读取 4 个字节</li>\n<li><code>markReaderIndex()</code>：标记当前的读位置</li>\n<li><code>resetReaderIndex()</code>：重置读位置到标记的位置</li>\n</ul>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"RPCProject\"><a href=\"#RPCProject\" class=\"headerlink\" title=\"RPCProject\"></a>RPCProject</h1><blockquote>\n<p>什么是RPC？ 有一篇RPC简单讲述了RPC</p>\n</blockquote>\n<h2 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h2><p>RPC是构建现代分布式系统和微服务架构的关键技术之一，使得构建跨网络和跨平台的应用程序变得更加容易和高效。</p>\n<h2 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h2><ul>\n<li>Netty搭建的服务端</li>\n<li>Netty搭建的客户端</li>\n<li>一些通用类</li>\n</ul>\n<h2 id=\"服务启动流程\"><a href=\"#服务启动流程\" class=\"headerlink\" title=\"服务启动流程\"></a>服务启动流程</h2><h3 id=\"创建RpcNettyServer\"><a href=\"#创建RpcNettyServer\" class=\"headerlink\" title=\"创建RpcNettyServer\"></a>创建RpcNettyServer</h3><ul>\n<li><p>启动需要两个地址，两个地址用于创建父类NettyServer</p>\n<ul>\n<li>服务IP地址</li>\n<li>Zookeeper服务器地址（服务注册地址） 2181</li>\n</ul>\n</li>\n<li><p>实现了ApplicationContextAware </p>\n<p>重写setApplicationContext方法扫描所有带有注解@RpcService的方法</p>\n</li>\n<li><p>实现了InitializingBean，afterPropertiesSet方法中启动父类NettyServer</p>\n</li>\n<li><p>实现了DisposableBean 在服务关闭的时候，关闭NettyServer</p>\n</li>\n</ul>\n<h3 id=\"NettyServer启动\"><a href=\"#NettyServer启动\" class=\"headerlink\" title=\"NettyServer启动\"></a>NettyServer启动</h3><ul>\n<li>RpcNettyServer调用了父类NettyServer的start方法，启动Netty服务器</li>\n<li>创建NettyServerInitializer</li>\n<li>Netty启动ServerBootStrap<ul>\n<li>相关配置<ul>\n<li>Netty容器<ol>\n<li>boosGroup 处理Accept请求</li>\n<li>workerGroup 负责READ、WRITE请求</li>\n</ol>\n</li>\n<li>处理器<ol>\n<li>入站处理器<ul>\n<li>IdleStateHandler 心跳状态感知</li>\n<li>LengthFieldBasedFrameDecoder 解决TCP存在的粘包半粘包问题（负责处理基于长度字段的数据帧，RpcRequest制定了数据帧的格式）</li>\n<li>RpcMsgDecoder 反序列化，可以接入不同的序列化工具本项目使用的是Protostuff</li>\n<li>RpcServerHandler 负责执行客户端传来的请求，执行RPC调用</li>\n</ul>\n</li>\n<li>出站处理器<ul>\n<li>RpcMsgEncoder 序列化</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务注册流程\"><a href=\"#服务注册流程\" class=\"headerlink\" title=\"服务注册流程\"></a>服务注册流程</h2><h3 id=\"扫描-RpcService\"><a href=\"#扫描-RpcService\" class=\"headerlink\" title=\"扫描@RpcService\"></a>扫描@RpcService</h3><p>扫描所有的@RpcService服务，将它们放入一个名叫serviceMap的服务，并将他们放入一个名叫serviceMap的HashMap</p>\n<ul>\n<li>key 是接口名 +版本</li>\n<li>value是对应的实现类</li>\n</ul>\n<h3 id=\"遍历serviceMap\"><a href=\"#遍历serviceMap\" class=\"headerlink\" title=\"遍历serviceMap\"></a>遍历serviceMap</h3><ul>\n<li>将serviceMap里的数据拆开，封装为RpcServiceInfo对象（RpcServiceInfo对象的属性有serviceName, version）</li>\n<li>将所有的RpcServiceInfo封装到一个RpcProtocol对象内（RpcProtocol的属性<code>host</code>, <code>port</code>, <code>List&lt;RpcServiceInfo&gt;</code>）</li>\n<li>调用JsonUtil的序列化方法，使用Jackson将RpcProtocol转换为一个Json字符串</li>\n<li>使用Zookeeper的连接curatorClient<ul>\n<li>创建对应的Zookeeper路径节点创建临时顺序节点</li>\n<li>给这个节点加一个监听器，如果连接状态变为RECONNECTED，那么重新进行服务注册</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"客户端启动\"><a href=\"#客户端启动\" class=\"headerlink\" title=\"客户端启动\"></a>客户端启动</h2><p>使用一个IP启动RpcClient,会启动服务发现ServiceDiscovery，开始服务发现，服务发现结束客户端启动过程就结束</p>\n<h2 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h2><blockquote>\n<p>客户端启动时，会根据IP创建一个服务发现类</p>\n</blockquote>\n<p><strong>服务发现类创建后进行服务发现操作：</strong></p>\n<ol>\n<li>通过curatorClient，获取Zookeeper路径上的所有临时节点，读到的是一个List&lt;String&gt;</li>\n<li>遍历这个List，将所有的String序列化为RpcProtocol</li>\n<li>转换后的RpcProtocol需要存放在本地，这里涉及到一个新的类ConnectionManager<ul>\n<li>ConnectionManager是单例的，每个客户端只有一个</li>\n<li>ConnectionManager关键使用到了两个Map来保存数据<ul>\n<li>类型为CopyOnWriteArraySet的rpcProtocolSet的rpcProtocolSet<ol>\n<li>采用cow的思想，适合用在读多写少的情况</li>\n<li>存放当前所有能连接到Server的RpcProtocol</li>\n</ol>\n</li>\n<li>类型为concurrenthashMap的connectedServerNodeMap<ol>\n<li>使用了concurrent的hasMap</li>\n<li>key存放这个RpcProtocol</li>\n<li>value存放连接中获取到的RpcClienthandler</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>将RpcProtocol作为参数，调用ConnectionManager的方法，获取与更新服务<ul>\n<li>将RpcProtocol中的List&lt;RpcServiceInfo&gt;，取出来，放入set去重，然后遍历这个set<br>判断rpcProtocolSet中是否存在，如果不存在，就尝试连接这个Server节点，并将与Server的连接存放在connectedServerNodeMap，将这个RpcProtocol存放在rpcProtocolSet<ul>\n<li>启动Netty客户端，根据RpcProtocol中的host与IP创建与Server的连接</li>\n<li>客户端的Netty的处理器配置为<br><img data-src=\"https://img.jyhmw.cn/image-20240912151349099.png\" alt=\"image-20240912151349099\"></li>\n<li>使用Netty的异步ChannelFuture，连接如果完成，将可以获得到此次连接用到的处理器RpcClientHandler</li>\n<li>将RpcProtocol和获取到的RpcClientHandler存放到connectedServerNodeMap</li>\n</ul>\n</li>\n<li>遍历rpcProtocolSet，找出set中不存在的那些RpcProtocol，说明这些服务已经停止提供，删除他们的连接<ul>\n<li>connectionServerNodeMap删除对应信息</li>\n<li>rpcProtocolSet删除对应信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过curatorClient添加对应的监听器，获取事件的类型与数据，分情况进行处理<ul>\n<li>CONNECTION_RECONNECTION 重新进行服务发现</li>\n<li>CHILD_ADDED 存储这些新添加的</li>\n<li>CHILD_UPDATED</li>\n<li>CHILD_REMOVED</li>\n</ul>\n</li>\n<li>服务发现结束</li>\n</ol>\n<h2 id=\"Rpc过程\"><a href=\"#Rpc过程\" class=\"headerlink\" title=\"Rpc过程\"></a>Rpc过程</h2><h3 id=\"client过程\"><a href=\"#client过程\" class=\"headerlink\" title=\"client过程\"></a>client过程</h3><ol>\n<li><p>客户端提供了异步通信的方式，假如客户现在要进行一个远程方法调用（即客户只知道接口，但是没有实现类）</p>\n<p>需要传输</p>\n<ul>\n<li>要使用接口的class</li>\n<li>版本信息</li>\n</ul>\n</li>\n<li><p>使用动态代理ObjectProxy提交信息</p>\n<ul>\n<li>类ObjectProxy是一个实现了InvocationHandler的类（JDK动态代理）<ul>\n<li>实现了InvocationHandler，需要重写Invoke方法，三个参数，proxy，方法，参数</li>\n<li>Invoke 方法会在代理对象的其他方法执行时自动执行</li>\n<li>invoke具体过程<ol>\n<li>封装一个RpcRequest<ul>\n<li>String requestId:UUID生成</li>\n<li>String className: 当前执行方法所属class名子，通过反射的getDeclaringCalss获得</li>\n<li>String methodName: 当前方法名</li>\n<li>Class&lt;?&gt;[] parameterTypes: 当前的参数类型</li>\n<li>Object version: 版本号</li>\n</ul>\n</li>\n<li>使用类名和版本号这两个信息从ConnectionManager的connectedServerNodeMap中通过RpcProtocol找到RpcClientHandler （找的过程使用了负载均衡）</li>\n<li>调用RpcClientHandler的方法发送第一步生成的RpcRequest，客户端会得到一个RpcFuture，这是一个Futrue对象，可以异步获取结果</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Server过程\"><a href=\"#Server过程\" class=\"headerlink\" title=\"Server过程\"></a>Server过程</h3><ol>\n<li>client发送过来的RpcRequest，将进入server端的入站处理器</li>\n<li>server端过滤掉心跳信息</li>\n<li>通过传过来的rpcRequest，从serviceMap中找到执行这一个方法的class对象<ul>\n<li>通过Class对象获取到Method对象</li>\n<li>利用反射机制执行method.invoke(serviceBean, parameters)</li>\n<li>将执行完成的结果封装到RpcResponse内，返回给客户端</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>客户端收到RpcFuture对象后，执行get(3000, TimeUnit.MILLSECONDS)获得执行的结果</p>\n</blockquote>\n<h2 id=\"两个Handler\"><a href=\"#两个Handler\" class=\"headerlink\" title=\"两个Handler\"></a>两个Handler</h2><h3 id=\"RpcClientHandler\"><a href=\"#RpcClientHandler\" class=\"headerlink\" title=\"RpcClientHandler\"></a>RpcClientHandler</h3><ol>\n<li>发送RpcFuture时，会将RpcFuture异步对象放入一个ConcurrentMap的pendingRpcMap内保存<br>保存在pendingRpcMap，key为RpcRequest的ID，value是RpcFuture</li>\n<li>收到服务器返回的结果时，通过response获得request的id，然后查pendingRpcMap，并将执行结果存放在RpcFuture内</li>\n</ol>\n<h3 id=\"RpcServerHandler\"><a href=\"#RpcServerHandler\" class=\"headerlink\" title=\"RpcServerHandler\"></a>RpcServerHandler</h3><p>根据RpcRequest，利用反射执行，然后返回执行的结果RpcResponse</p>\n","categories":["项目"],"tags":["远程调用","项目"]},{"title":"Vue","url":"/2024/12/06/Vue/","content":"<h1 id=\"Vue简介\"><a href=\"#Vue简介\" class=\"headerlink\" title=\"Vue简介\"></a>Vue简介</h1><blockquote>\n<p>渐进式JavaScript框架，易学易用，性能出色，使用场景丰富的web前端框架</p>\n</blockquote>\n<p>Vue(发音为&#x2F;vju:&#x2F;，类似view)是一款用于构建用户界面的JavaScript框架。基于标椎HTML、CSS和JavaScript构建，提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue都能胜任</p>\n<h2 id=\"渐进式框架\"><a href=\"#渐进式框架\" class=\"headerlink\" title=\"渐进式框架\"></a>渐进式框架</h2><p>Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的。不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“<strong>可以被逐步集成</strong>”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue:</p>\n<ul>\n<li>无需构建步骤，渐进式增强静态的HTML</li>\n<li>在任何页面中作为Web Components嵌入</li>\n<li>单页应用(SPA)(整个项目在一个页面)</li>\n<li>全栈&#x2F;服务端渲染(SSR)</li>\n<li>JamStack&#x2F;静态站点生成(SSG)</li>\n<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>\n</ul>\n<h1 id=\"API风格\"><a href=\"#API风格\" class=\"headerlink\" title=\"API风格\"></a>API风格</h1><h2 id=\"选项式API\"><a href=\"#选项式API\" class=\"headerlink\" title=\"选项式API\"></a>选项式API</h2><blockquote>\n<p>Options API</p>\n</blockquote>\n<p>使用选项式API，我们可以用包含多个选项的对象来描述组件的逻辑，例如<code>data</code>、<code>methods</code>、<code>mounted</code>。选项所定义的属性都会暴露在函数内部<code>this</code>上，会指向当前的组件实例</p>\n<p>例如实现一个按钮累加的功能</p>\n<img data-src=\"https://img.jyhmw.cn/image-20241206094058037.png\" alt=\"image-20241206094058037\" style=\"zoom:50%;\" />\n\n<h2 id=\"组合式API\"><a href=\"#组合式API\" class=\"headerlink\" title=\"组合式API\"></a>组合式API</h2><blockquote>\n<p>Composition API</p>\n</blockquote>\n<p>通过组合式API，可以使用导入的API函数来描述组件逻辑</p>\n<img data-src=\"https://img.jyhmw.cn/image-20241206094221033.png\" alt=\"image-20241206094221033\" style=\"zoom:50%;\" />\n\n<h2 id=\"该选哪一个？\"><a href=\"#该选哪一个？\" class=\"headerlink\" title=\"该选哪一个？\"></a>该选哪一个？</h2><p>两种 API风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API是在组合式 API 的基础上实现的!关于 Vue 的基础概念和知识在它们之间都是通用的。</p>\n<p>生产项目中</p>\n<ul>\n<li>当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐<br>采用选项式 API</li>\n<li>当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API+ 单文件组件</li>\n</ul>\n<h1 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h1><p><img data-src=\"https://img.jyhmw.cn/image-20241206101118170.png\" alt=\"image-20241206101118170\"></p>\n<ul>\n<li>node_moudles   —   vue项目的运行依赖文件夹</li>\n<li>public                       —   资源文件夹（浏览器图标..）</li>\n<li>src                              —    源码文件夹</li>\n<li>.gitignore                —    git忽略文件</li>\n<li>index.html              —    入口html文件</li>\n<li>package.json          —    信息描述文件</li>\n<li>README.md           —    注释文件</li>\n<li>vite.config.js            —    Vue配置文件</li>\n</ul>\n<h1 id=\"vite构建\"><a href=\"#vite构建\" class=\"headerlink\" title=\"vite构建\"></a>vite构建</h1><blockquote>\n<p>vite是新一代前端构建工具</p>\n</blockquote>\n<ul>\n<li>轻量快速的热重载（HMR），能实现极速的服务启动</li>\n<li>对<code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用</li>\n<li>真正的按需编译，不再等待整个应用编译完成</li>\n</ul>\n<h2 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 1.创建命令</span></span></span><br><span class=\"line\">npm create vue@latest</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 2.具体配置</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 配置项目名称</span></span></span><br><span class=\"line\">√ Project name: vue3_test</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加TypeScript支持</span></span></span><br><span class=\"line\">√ Add TypeScript?  Yes</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加JSX支持</span></span></span><br><span class=\"line\">√ Add JSX Support?  No</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加路由环境</span></span></span><br><span class=\"line\">√ Add Vue Router for Single Page Application development?  No</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加pinia环境</span></span></span><br><span class=\"line\">√ Add Pinia for state management?  No</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加单元测试</span></span></span><br><span class=\"line\">√ Add Vitest for Unit Testing?  No</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加端到端测试方案</span></span></span><br><span class=\"line\">√ Add an End-to-End Testing Solution? » No</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加ESLint语法检查</span></span></span><br><span class=\"line\">√ Add ESLint for code quality?  Yes</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 是否添加Prettiert代码格式化</span></span></span><br><span class=\"line\">√ Add Prettier for code formatting?  No</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"核心语法\"><a href=\"#核心语法\" class=\"headerlink\" title=\"核心语法\"></a>核心语法</h1><h2 id=\"setup\"><a href=\"#setup\" class=\"headerlink\" title=\"setup\"></a>setup</h2><blockquote>\n<p><code>setup</code>是<code>Vue3</code>中一个新的配置项，值是一个函数，它是 <code>Composition API</code> <strong>“表演的舞台</strong><em><strong>”</strong></em>，组件中所用到的：数据、方法、计算属性、监视…等等，均配置在<code>setup</code>中</p>\n</blockquote>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li>\n<li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li>\n<li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，它是“领先”所有钩子执行的</li>\n</ul>\n<p>代码示例：</p>\n<p>注意这里由于安装了eslint插件，校验代码格式和规范，不按照它的来会直接报错。我在此之后关闭了校验。（这里是因为name用的person，不是eslint插件规定的多个单词驼峰命名—坑）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;姓名: &#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;年龄: &#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">    name: &#x27;myPerson&#x27;,</span><br><span class=\"line\">    setup() &#123;</span><br><span class=\"line\">      let name = &#x27;张三&#x27;</span><br><span class=\"line\">      let age = 18</span><br><span class=\"line\">      let tel = &#x27;13888888888&#x27;</span><br><span class=\"line\">      function changeName() &#123;</span><br><span class=\"line\">        name = &#x27;zhang-san&#x27;</span><br><span class=\"line\">        console.log(name)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      function changeAge() &#123;</span><br><span class=\"line\">        age += 1</span><br><span class=\"line\">        console.log(age)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      function showTel() &#123;</span><br><span class=\"line\">        alert(tel)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &#123;name, age, tel, changeName, changeAge, showTel&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li><p>若返回一个对象：则对象中的：属性、方法等，在模板中均可以直接使用<strong>（重点关注）</strong></p>\n</li>\n<li><p>若返回一个<strong>函数</strong>：则可以自定义渲染内容，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  return ()=&gt; &#x27;你好啊！&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"setup与OptionsAPI的关系\"><a href=\"#setup与OptionsAPI的关系\" class=\"headerlink\" title=\"setup与OptionsAPI的关系\"></a>setup与OptionsAPI的关系</h3><ul>\n<li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>…）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li>\n<li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>…）。</li>\n<li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。</li>\n</ul>\n<h3 id=\"setup语法糖\"><a href=\"#setup语法糖\" class=\"headerlink\" title=\"setup语法糖\"></a>setup语法糖</h3><p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\"> &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">  &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">  &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;showTel&quot;&gt;查看联系方式&lt;/button&gt;</span><br><span class=\"line\"> &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">    name:&#x27;Person&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">  console.log(this)</span><br><span class=\"line\">  let name = &#x27;张三&#x27;</span><br><span class=\"line\">  let age = 18</span><br><span class=\"line\">  let tel = &#x27;13888888888&#x27;</span><br><span class=\"line\">  function changeName() &#123;</span><br><span class=\"line\">    name=&#x27;李四&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changAge()&#123;</span><br><span class=\"line\">    console.log(age)</span><br><span class=\"line\">    age += 1 </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function showTel()&#123;</span><br><span class=\"line\">    alert(tel)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>扩展：</strong>上述代码还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化</p>\n<ol>\n<li><p>npm i vite-plugin-vue-setup-extend -D</p>\n</li>\n<li><p>vite.config.ts 中</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VueSetupExtend</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite-plugin-vue-setup-extend&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [ <span class=\"title class_\">VueSetupExtend</span>() ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置为script setup lang&#x3D;”ts” name&#x3D;”Person”</p>\n</li>\n</ol>\n<h2 id=\"ref创建-基本类型\"><a href=\"#ref创建-基本类型\" class=\"headerlink\" title=\"ref创建:基本类型\"></a>ref创建:基本类型</h2><blockquote>\n<p>ref基本类型的响应式数据</p>\n</blockquote>\n<ul>\n<li><strong>作用</strong>：定义响应式变量</li>\n<li><strong>语法</strong>：let xxx &#x3D; ref(初始值)</li>\n<li><strong>返回值</strong>：一个RefImpl的实例对象，简称ref对像或ref，ref对象的value属性是响应式的</li>\n<li>注意点：<ul>\n<li>ts中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可</li>\n<li>何时需要.value?模板中不需要；包裹在响应式对象里面的ref不需要；未包裹的ref需要</li>\n<li>对于let name &#x3D; ref(‘张三’)来说，name不是响应式的，name.value是响应式的</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意到此，作者JYH发现vite的好处，所以说重新用vite构建项目</strong>（目录中可以找到vite构建的步骤及好处）</p>\n</blockquote>\n<p>ref创建代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 下面的写法是setup语法糖 --&gt;</span><br><span class=\"line\">&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  let name = ref(&#x27;张三&#x27;)</span><br><span class=\"line\">  let age = ref(18)</span><br><span class=\"line\">  //tel就是一个普通的字符串不是响应式的</span><br><span class=\"line\">  let tel = &#x27;13888888888&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 方法</span><br><span class=\"line\">  function changName()&#123;</span><br><span class=\"line\">    name.value = &#x27;李四&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changAge()&#123;</span><br><span class=\"line\">    console.log(age)</span><br><span class=\"line\">    age.value += 1 //注意：此时这么修改age页面是不变化的</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function showTel()&#123;</span><br><span class=\"line\">    alert(tel)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"reactive创建-对象类型\"><a href=\"#reactive创建-对象类型\" class=\"headerlink\" title=\"reactive创建:对象类型\"></a>reactive创建:对象类型</h2><blockquote>\n<p>对象类型的响应式数据</p>\n</blockquote>\n<ul>\n<li><strong>作用</strong>：定义一个响应式对象（基本类型不要用它，要用ref，否则报错）</li>\n<li><strong>语法</strong>：let 响应式对象&#x3D;reactive(源对象)</li>\n<li><strong>返回值</strong>：一个Proxy的实例对象，简称：响应式对象</li>\n<li><strong>注意点</strong>：reactive定义的响应式数据是“深层次的”</li>\n</ul>\n<p>代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;h2&gt;测试：&#123;&#123; obj.a.b.c.d &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class=\"line\">  let car = reactive(&#123;brand:&#x27;奔驰&#x27;, price:100&#125;)</span><br><span class=\"line\">  let games = reactive([</span><br><span class=\"line\">    &#123;id:&#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27;&#125;,</span><br><span class=\"line\">    &#123;id:&#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27;&#125;,</span><br><span class=\"line\">    &#123;id:&#x27;ahsgdyfa03&#x27;, name: &#x27;原神！&#x27;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  ])</span><br><span class=\"line\">  let obj = reactive(&#123;</span><br><span class=\"line\">    a:&#123;</span><br><span class=\"line\">      b:&#123;</span><br><span class=\"line\">        c:&#123;</span><br><span class=\"line\">          d:666</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  function changeCarPrice() &#123;</span><br><span class=\"line\">    car.price += 10;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeFirstGame() &#123;</span><br><span class=\"line\">    games[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function test() &#123;</span><br><span class=\"line\">    obj.a.b.c.d = 999</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ref创建-对象类型\"><a href=\"#ref创建-对象类型\" class=\"headerlink\" title=\"ref创建:对象类型\"></a>ref创建:对象类型</h2><blockquote>\n<ul>\n<li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li>\n<li>若<code>ref</code>接收的是对象类型，内部其实也是调用了<code>reactive</code>函数。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据</span><br><span class=\"line\">let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)</span><br><span class=\"line\">let games = ref([</span><br><span class=\"line\">  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,</span><br><span class=\"line\">  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,</span><br><span class=\"line\">  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;</span><br><span class=\"line\">])</span><br><span class=\"line\">let obj = ref(&#123;</span><br><span class=\"line\">  a:&#123;</span><br><span class=\"line\">    b:&#123;</span><br><span class=\"line\">      c:&#123;</span><br><span class=\"line\">        d:666</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(car)</span><br><span class=\"line\"></span><br><span class=\"line\">function changeCarPrice() &#123;</span><br><span class=\"line\">  car.value.price += 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function changeFirstGame() &#123;</span><br><span class=\"line\">  games.value[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function test()&#123;</span><br><span class=\"line\">  obj.value.a.b.c.d = 999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ref与reactive\"><a href=\"#ref与reactive\" class=\"headerlink\" title=\"ref与reactive\"></a>ref与reactive</h2><ul>\n<li>宏观角度<ol>\n<li>ref定义：基本类型数据、对象类型数据</li>\n<li>reactive用来定义：对象类型数据</li>\n</ol>\n</li>\n<li>区别<ol>\n<li><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）</li>\n<li><code>reactive</code>重新分配一个新对象，会<strong>失去</strong>响应式</li>\n</ol>\n</li>\n<li>使用原则<ol>\n<li>若需要一个基本类型的响应式数据，必须使用<code>ref</code></li>\n<li>若需要一个响应式对象，层级不深，<code>ref</code>、<code>reactive</code>都可以</li>\n<li>若需要一个响应式对象，且层级较深，推荐使用<code>reactive</code></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"toRefs与toRef\"><a href=\"#toRefs与toRef\" class=\"headerlink\" title=\"toRefs与toRef\"></a>toRefs与toRef</h2><ul>\n<li><p>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。并且改变解构的值，也会影响到原响应式对象的值。</p>\n</li>\n<li><p>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</p>\n</li>\n<li><p>语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">    import &#123;ref, reactive, toRefs, toRef&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">    let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)</span><br><span class=\"line\">    // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span><br><span class=\"line\">    //改变name和gender的值，也会影响到person里面的值</span><br><span class=\"line\">    let &#123;name,gender&#125; = toRefs(person)</span><br><span class=\"line\">    // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力</span><br><span class=\"line\">    let age = toRef(person,&#x27;age&#x27;)</span><br><span class=\"line\">    function changeName() &#123;</span><br><span class=\"line\">        name.value += &#x27;~&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function changeAge() &#123;</span><br><span class=\"line\">        age.value += 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function changeGender() &#123;</span><br><span class=\"line\">        gender.value = &#x27;女&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h2><blockquote>\n<p>根据已有数据计算出新的数据</p>\n</blockquote>\n<ul>\n<li><p>实现同样的功能，方法function没有缓存，模板调用几次，函数就执行几次；计算属性computed有缓存，模板调用多次，实际上只执行一次<br>比如我要打印两次某个计算的结果function就要执行两次，而computed会执行第一次后缓存，只执行一次。</p>\n</li>\n<li><p>计算属性实际上是一个ref响应式对象，因此赋值的时候要加上<code>.value</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">      姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class=\"line\">      名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;</span><br><span class=\"line\">      全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class=\"line\">      全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class=\"line\">      &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class=\"line\">    import &#123;ref,computed&#125; from &#x27;vue&#x27;\t//引入computed</span><br><span class=\"line\">  </span><br><span class=\"line\">    let firstName = ref(&#x27;zhang&#x27;)</span><br><span class=\"line\">    let lastName = ref(&#x27;san&#x27;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 计算属性——只读取，不修改</span><br><span class=\"line\">    /* let fullName = computed(()=&gt;&#123;</span><br><span class=\"line\">      return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class=\"line\">    &#125;) */</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    // 计算属性——既读取又修改</span><br><span class=\"line\">    let fullName = computed(&#123;</span><br><span class=\"line\">      // 读取</span><br><span class=\"line\">      get()&#123;</span><br><span class=\"line\">        return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      // 修改</span><br><span class=\"line\">      set(val)&#123;\t1</span><br><span class=\"line\">        console.log(&#x27;有人修改了fullName&#x27;,val)</span><br><span class=\"line\">        firstName.value = val.split(&#x27;-&#x27;)[0]</span><br><span class=\"line\">        lastName.value = val.split(&#x27;-&#x27;)[1]</span><br><span class=\"line\">        //第二种写法  </span><br><span class=\"line\">        //const [str1,str2] = val.split(&#x27;-&#x27;)</span><br><span class=\"line\">        //firstName.value = str1</span><br><span class=\"line\">        //lastName.value = str2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">    function changeFullName()&#123;</span><br><span class=\"line\">      fullName.value = &#x27;li-si&#x27;\t//引起set的val变化</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><ul>\n<li>作用：监视数据的变化</li>\n<li>特点：Vue3中的watch只能监视一下四种数据<ol>\n<li>ref定义的数据</li>\n<li>reactive定义的数据</li>\n<li>函数返回一个值（getter函数）</li>\n<li>一个包含上述内容的数组</li>\n</ol>\n</li>\n</ul>\n<p>vue3中使用watch会有以下<strong>五种情况</strong></p>\n<h3 id=\"情况一\"><a href=\"#情况一\" class=\"headerlink\" title=\"情况一\"></a>情况一</h3><blockquote>\n<p>监视ref定义的基本类型数据：直接写数据名即可，监视的是其value值的改变</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  // 数据</span><br><span class=\"line\">  let sum = ref(0)</span><br><span class=\"line\">  // 方法</span><br><span class=\"line\">  function changeSum()&#123;</span><br><span class=\"line\">    sum.value += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 监视，情况一：监视【ref】定义的【基本类型】数据</span><br><span class=\"line\">  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)</span><br><span class=\"line\">    if(newValue &gt;= 10)&#123;</span><br><span class=\"line\">      stopWatch()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"情况二\"><a href=\"#情况二\" class=\"headerlink\" title=\"情况二\"></a>情况二</h3><blockquote>\n<p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p>\n<ul>\n<li>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</li>\n<li>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  // 数据</span><br><span class=\"line\">  let person = ref(&#123;</span><br><span class=\"line\">    name:&#x27;张三&#x27;,</span><br><span class=\"line\">    age:18</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 方法</span><br><span class=\"line\">  function changeName()&#123;</span><br><span class=\"line\">    person.value.name += &#x27;~&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeAge()&#123;</span><br><span class=\"line\">    person.value.age += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changePerson()&#123;</span><br><span class=\"line\">    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  /* </span><br><span class=\"line\">    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视</span><br><span class=\"line\">    watch的第一个参数是：被监视的数据</span><br><span class=\"line\">    watch的第二个参数是：监视的回调</span><br><span class=\"line\">    watch的第三个参数是：配置对象（deep、immediate等等.....） </span><br><span class=\"line\">  */</span><br><span class=\"line\">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class=\"line\">  &#125;,&#123;deep:true,immediate:true&#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"情况三\"><a href=\"#情况三\" class=\"headerlink\" title=\"情况三\"></a>情况三</h3><blockquote>\n<p>监视reactive定义的【对象类型】数据，且默认开启了深度监视，且深层监视无法关闭。</p>\n<p>无法监视地址值，因为对象地址值没有改变，本质上assign在原对象上进行的是赋值。</p>\n<p>newValue和oldValue值相同，都是新值，还是因为对象地址值没有改变，本质上assign在原对象上进行的是赋值。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class=\"line\">    &lt;hr&gt;</span><br><span class=\"line\">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  // 数据</span><br><span class=\"line\">  let person = reactive(&#123;</span><br><span class=\"line\">    name:&#x27;张三&#x27;,</span><br><span class=\"line\">    age:18</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  let obj = reactive(&#123;</span><br><span class=\"line\">    a:&#123;</span><br><span class=\"line\">      b:&#123;</span><br><span class=\"line\">        c:666</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 方法</span><br><span class=\"line\">  function changeName()&#123;</span><br><span class=\"line\">    person.name += &#x27;~&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeAge()&#123;</span><br><span class=\"line\">    person.age += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changePerson()&#123;</span><br><span class=\"line\">   \t// person = &#123; name: &#x27;李四&#x27;, age: 80 &#125;//直接修改，不行</span><br><span class=\"line\">  \t// person = reactive(&#123; name: &#x27;李四&#x27;, age: 80 &#125;)//reactive包裹修改，也不行</span><br><span class=\"line\">    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)//本质上替换了原person的每个属性值</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function test()&#123;</span><br><span class=\"line\">    obj.a.b.c = 888</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的</span><br><span class=\"line\">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  watch(obj,(newValue,oldValue)=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"情况四\"><a href=\"#情况四\" class=\"headerlink\" title=\"情况四\"></a>情况四</h3><blockquote>\n<p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p>\n</blockquote>\n<ol>\n<li>若该属性值<strong>不是</strong>【对象类型】即【基本类型】，需要写成函数形式，此时oldValue是旧值，newValue是新值。</li>\n<li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li>\n</ol>\n<ul>\n<li><p>直接写：可以监视到对象内部属性a，b…的变化，但是监视不到整体的变化。整体改变时，对象地址值变化了，所以监视不到了。</p>\n</li>\n<li><p>写函数（不开启深度监视）：监视不到对象内部属性a，b…的变化，但是可以监视到整体的变化，函数返回值监视的是对象的地址值，改变整体是产生一个新对象，所以能监视到，并且新值是新值，旧值是旧值。（不过对象内部属性a，b…的新旧值都是新值）</p>\n</li>\n<li><p>写函数（开启深度监视）推荐：既能监视到对象内部属性a，b…的变化，也可以监视到整体的变化，函数返回值监视的是对象的地址值，改变整体是产生一个新对象，所以能监视到，并且新值是新值，旧值是旧值。（不过对象内部属性a，b…的新旧值都是新值）</p>\n</li>\n</ul>\n<h3 id=\"情况五\"><a href=\"#情况五\" class=\"headerlink\" title=\"情况五\"></a>情况五</h3><blockquote>\n<p>监视上述的多个数据</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;</span><br><span class=\"line\">        &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">    import &#123; reactive,watch &#125; from &quot;vue&quot;;</span><br><span class=\"line\">    let person = reactive(&#123;</span><br><span class=\"line\">        name:&#x27;张三&#x27;,</span><br><span class=\"line\">        age:18,</span><br><span class=\"line\">        car:&#123;</span><br><span class=\"line\">            c1:&#x27;奔驰&#x27;,</span><br><span class=\"line\">            c2:&#x27;宝马&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    function changeName() &#123;</span><br><span class=\"line\">        person.name += &#x27;~&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function changeAge() &#123;</span><br><span class=\"line\">        person.age += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function changeC1()&#123;</span><br><span class=\"line\">    person.car.c1 = &#x27;奥迪&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeC2()&#123;</span><br><span class=\"line\">    person.car.c2 = &#x27;大众&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeCar()&#123;</span><br><span class=\"line\">    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  watch([() =&gt; person.name, person.car], (newValue, oldValue) =&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;person.car变化了&#x27;, newValue, oldValue)</span><br><span class=\"line\">  &#125;, &#123;deep:true&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"watchEffect\"><a href=\"#watchEffect\" class=\"headerlink\" title=\"watchEffect\"></a>watchEffect</h2><blockquote>\n<p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数</p>\n</blockquote>\n<ul>\n<li>watch对比watchEffect<ol>\n<li>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</li>\n<li>watch：要明确指出监视的数据</li>\n<li>watchEffect：不用明确指出监视的数据（函数中用到哪些属性，就监视哪些属性）</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  // 数据</span><br><span class=\"line\">  let temp = ref(0)</span><br><span class=\"line\">  let height = ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">  // 方法</span><br><span class=\"line\">  function changePrice()&#123;</span><br><span class=\"line\">    temp.value += 10</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  function changeSum()&#123;</span><br><span class=\"line\">    height.value += 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 用watch实现，需要明确的指出要监视：temp、height</span><br><span class=\"line\">  watch([temp,height],(value)=&gt;&#123;</span><br><span class=\"line\">    // 从value中获取最新的temp值、height值</span><br><span class=\"line\">    const [newTemp,newHeight] = value</span><br><span class=\"line\">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class=\"line\">    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;</span><br><span class=\"line\">      console.log(&#x27;联系服务器&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  // 用watchEffect实现，不用</span><br><span class=\"line\">  const stopWtach = watchEffect(()=&gt;&#123;</span><br><span class=\"line\">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class=\"line\">    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;</span><br><span class=\"line\">      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)</span><br><span class=\"line\">      console.log(&#x27;联系服务器&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 水温达到100，或水位达到50，取消监视</span><br><span class=\"line\">    if(temp.value === 100 || height.value === 50)&#123;</span><br><span class=\"line\">      console.log(&#x27;清理了&#x27;)</span><br><span class=\"line\">      stopWtach()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签的ref属性\"><a href=\"#标签的ref属性\" class=\"headerlink\" title=\"标签的ref属性\"></a>标签的ref属性</h2><blockquote>\n<p>用于注册模板的引用</p>\n</blockquote>\n<ul>\n<li>用在普通的DOM标签上，获取的是DOM节点</li>\n<li>用在组件标签上，获取的是组件实例对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;person&quot;&gt;</span><br><span class=\"line\">    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;br&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class=\"line\">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class=\"line\">  let title1 = ref()</span><br><span class=\"line\">  let title2 = ref()</span><br><span class=\"line\">  let title3 = ref()</span><br><span class=\"line\">  function showLog() &#123;</span><br><span class=\"line\">    //通过id获取元素</span><br><span class=\"line\">    // const t1 = document.getElementById(&#x27;title1&#x27;)</span><br><span class=\"line\">    // console.log((t1 as HTMLElement).innerText)</span><br><span class=\"line\">    // console.log((&lt;HTMLElement&gt;t1).innerText)</span><br><span class=\"line\">    // console.log(t1?.innerText)</span><br><span class=\"line\">    //通过ref获取元素</span><br><span class=\"line\">    console.log(title1.value)</span><br><span class=\"line\">    console.log(title2.value)</span><br><span class=\"line\">    console.log(title3.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>未完待续…</p>\n","categories":["技术栈","前端"],"tags":["前端","vue"]},{"title":"值得记录的视频","url":"/2024/03/19/%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A7%86%E9%A2%91/","content":"<h1 id=\"值得记录\"><a href=\"#值得记录\" class=\"headerlink\" title=\"值得记录\"></a>值得记录</h1><h2 id=\"无名者\"><a href=\"#无名者\" class=\"headerlink\" title=\"无名者\"></a>无名者</h2><p>《无名者》记录了一个孤独男人的日常形象。他在山洞里做饭、吃饭、睡觉，其余时间都在工作：他去街上捡牲畜的粪便，也许是为了丰富田地；在地里挖掘，种植玉米和蔬菜；从沟里取些雨水来灌溉土地；他还在墙上贴了农作物秸秆和泥土，但我不知道为什么，因为他不住在那里。他远离农村和城市生活，就像英国的鲁滨逊一样。他没有希望，或者他的希望只是收集更多的玉米，雨后用泥土加固洞穴的墙壁。对旁观者来说，他是一个绝望的存在，但对他来说，它只意味着简单的存在。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=1500518234&bvid=BV19S421N79c&cid=1440414539&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<h3 id=\"为什么要记录？\"><a href=\"#为什么要记录？\" class=\"headerlink\" title=\"为什么要记录？\"></a>为什么要记录？</h3><p>​\t\t首先，我并没有感觉到无名者是可怜的、可悲的如何如何。我只是想到了，虽然没有对比就没有幸福，但是简单的一日三餐、春种秋收就是他活着的动力，饭后自己卷的一根香烟就是他最大的幸福。</p>\n<p>​\t\t其次，看着无名者，我们这些大学生不是只该说出“何不食肉糜”，而是该好好考虑自己了。我们生在红旗下，长在春风里。我们应该说出的是“彼尚如此，吾辈何堪。”</p>\n<p>​\t\t是，他不是什么大英雄。可大英雄手中枪翻江倒海，抵不过饥寒穷三个字。他过去也是意气风发，风流少年，如今虽封闭在土地中，卷起烟仍然悠然自得。而我们难道就要处于麻木的智力抑制状态日复一日？</p>\n<p>​\t\t大学生大都没有经济来源的，如果要靠游戏填充课上时间度日，父母之苦为谁而受，为何而苦呢？</p>\n<p>​\t\t摆脱冷气，痛定思痛，迎难而上！命运是成功者的谦辞，而不是失败者的借口。让那些威辞恫吓之人见鬼去吧。</p>\n<h2 id=\"过昭关\"><a href=\"#过昭关\" class=\"headerlink\" title=\"过昭关\"></a>过昭关</h2><p>​\t\t《过昭关》看似记录了一个故事，其实里面有很多很多小故事，比如让我印象深刻的，父亲让小儿子上山砍柴，小儿子因偷懒不仅仅没去，还说大哥抢走的刚劈的柴。父亲闻言大怒，当着大哥儿子的面对大哥大打出手，没想到性格刚烈的大哥因此觉得受不了屈辱，一气之下喝了农药，可是农药是没有后悔药的，大哥死在了去医院的路上，父亲在悔恨中上吊自杀了，大嫂也改嫁了，小儿子本想一死了之，可想到大哥的两个孩子，只能活下去，把他们抚养成人。为了惩罚自己，他便不再说话，久而久之，就成了哑巴。<br>​\t\t上面故事，只是借给主演三轮车的哑巴堂弟的故事。是啊村里的事情有时就是离奇的，人是无法控制的。</p>\n<p>​\t\t我也是农村人，我的爷爷有一个好朋友，人到老年落得个无亲无故，无牵无挂，甚至觉得活下去也没了念想，就是自己留下的党参地还放心不下，死前写了遗书交代党参苗给了我的爷爷，他就自己结束了自己的生命。我也不知道爷爷的这位朋友经历了什么，但是他的选择或许对他来说是最正确的。像这样的故事还有很多很多，所以不要总是一点挫折就怨天尤人，向前看，活下去！即使爷爷的这位朋友结束了自己的生命，那也是本来生命就到了尽头而已。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=1752596819&bvid=BV1ex421D7pj&cid=1492562027&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n<p>​\t\t</p>\n<p>​\t\t故事的主人公爷爷也是一个经历重大挫折几近丧命活下来的人，爷爷所说的话中总有一些阅尽千帆后的淡然，这样的人才有资格评价人生，总结人生。有些年纪轻轻就总结人生的人，是否是杞人忧天呢？有些话只有经理过了，才会明白其中的深意，获取你能说出来它的意思，可你真的能体会到吗？不能。如果你觉得能，要不你就是有过经历，感同身受；要么你就是夜郎自大，侃侃而谈。</p>\n<p>​\t\t就一个这样的人，都在无时无刻帮助别人，是因为他在几近放弃活下去的念头时，有人帮助了他。曾经看过一份科研报告，对那些变态杀人狂，或者说是罪无可赦的罪犯来说，也有他们善良的一面，是因为他们不幸的童年中，有一部分是被善待的，可惜他们犯的罪过，不是一点点善就能救赎的。</p>\n<p>​\t\t主人公还说过一句话，“出门在外就需要朋友的帮助”，这口气真像我的爷爷，我的爷爷说过这么一句话“活成个人，酸甜苦辣都得吃了吧！”，这些话我都将铭记在心。<br>​\t\t主人公遇到了一个养蜂老人，小时候闹饥荒，父母为了给自己留下粮食，双双饿死，他还是坚强的活了下来，并育有儿女，儿女在城里发展的很好，可他还是不愿意回到城里，因为城里没个说话的人。<br>​\t\t主人公，总是提起过昭关的故事，把自己比作伍子胥，当时就是因为朋友的帮助才活下来，而这一趟三轮车之旅也是为了还活在世上的一个朋友，遇到在同一个年代失去父母的养蜂人，爷爷又说了起来：“咱这一本子啊，也就跟那过昭关是一样，过罢昭关又过潼关，过罢潼关还有山海关嘉峪关，关关难过 也得过呀……”。养蜂人回应道：“就剩最后这一关了”。主人公随行的孙子宁宁完全听不懂，也不知道两个老爷爷说的最后一关是什么关。</p>\n<p>​\t\t剧中很有意思的一段，宁宁爷爷历时五天终于找到的三门峡医院，找到了老朋友的病房，可一开始便认错了人。“兄弟，你现在好些了吧”。“好多了”。“我咋看你变样了？”“还那个样”“你是谁啊？”“我是福长啊”“哪个福长啊”“李福长啊”“我不认识李福长啊”“你咋不认识我了你不是韩玉堂吗？”“我不是你找错人了”。这段对白也在暗示多年未见的好友，也不敢从当时的样貌来判断，而爷爷最终也找到了真的韩玉堂。短短的几句寒暄，一罐路上养蜂人送的蜂蜜，这就是老友之间的交流。仅仅两分钟，宁宁爷爷就准备回家了，可是走到楼下，楼上传来了同病房的老人喊声：“唉，等等”。“他叫你路上慢点！”。宁宁爷爷回应道“哦，知道了”。“他说，好好好，你赶紧走吧！”。<br>​\t\t中间孩子回家找不到爷孙俩报警，找到爷孙俩的片段跳过。回去的时候，在车上爷爷语重心长的对儿子说：“说起来啊，小时候不应该总是打你”。那个年代的父母从来不会跟孩子道歉，如今爷爷含蓄的跟自己儿子说出这句话，便是又过了人生的一关。</p>\n<p>​\t\t回村后，电三轮的主任哑巴叔过完了人生的最后一关。宁宁问道：“爷爷，什么是死啊？” “爷爷现在还不知道咧，等将来啊，我就能找他们去了”“那爷爷也会变成鬼了？”“咦 那还是好事儿哩 我想见的人哪，都能见上了”。爷爷问道：“爷爷要是变成鬼了，你害怕不害怕？”最怕鬼的宁宁：“嗯…不害怕！”</p>\n<p>​\t\t暑假快结束了，宁宁不想回家，宁宁爸爸：“不回家谁管你？”。宁宁：“爷爷管”。“你爷爷都多大了？”“那爷爷死了咋办？”对宁宁来说这是一个难忘的暑假。“跟爷爷说再见”。宁宁：“不想再见”。宁宁似乎知道了爷爷的最后一关是什么。</p>\n<p>​\t\t车开出两三米，“爷爷再见”。宁宁一遍遍的喊着……</p>\n<p>​\t\t我看到一个弹幕：“每座墓碑下，都是一部长篇小说”</p>\n<p>​\t\t这是个影片，也是真实的事件，因为宁宁爷爷演的就是他自己。</p>\n","categories":["视频"],"tags":["感悟"]},{"title":"大数据分析与可视化相关概念","url":"/2024/04/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","content":"<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><blockquote>\n<p>机器学习是人工智能的一个分支，它涉及开发算法和统计模型，使计算机系统能够从数据中学习并做出预测或决策，而无需进行明确的编程</p>\n</blockquote>\n<h3 id=\"1-监督学习\"><a href=\"#1-监督学习\" class=\"headerlink\" title=\"1. 监督学习\"></a>1. 监督学习</h3><p>在这种学习中，算法从标记的训练数据中学习，每个训练示例都配有正确的输出标签。算法的目标是学习如何预测新数据的标签。</p>\n<h3 id=\"2-无监督学习\"><a href=\"#2-无监督学习\" class=\"headerlink\" title=\"2. 无监督学习\"></a>2. 无监督学习</h3><p>在无监督学习中，算法处理未标记的数据，尝试找出数据中的模式或结构。常见的无监督学习任务包括聚类和降维。</p>\n<h3 id=\"3-强化学习\"><a href=\"#3-强化学习\" class=\"headerlink\" title=\"3. 强化学习\"></a>3. 强化学习</h3><p>强化学习是一种让算法通过与环境交互来学习的方法。算法通过执行动作并接收奖励或惩罚来学习，目标是最大化累积奖励。</p>\n<p><strong>机器学习</strong>的应用非常广泛，包括但不限于图像识别、语音识别、自然语言处理、推荐系统、自动驾驶汽车、游戏玩家、欺诈检测等。</p>\n<p>机器学习的核心在于使用数据来改进系统的性能，而不需要人为地编写特定的规则来处理数据。随着数据量的增加和计算能力的提升，机器学习在许多领域变得越来越重要。</p>\n<h2 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h2><blockquote>\n<p>决策树是一种直观的决策支持工具，广泛应用于数据分析和机器学习中。它通过树状结构来表示决策过程中的分支选择，每个内部节点代表一个属性测试，每个分支代表一个测试结果，每个叶节点代表最终决策结果。</p>\n</blockquote>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li><strong>节点（Node）</strong>：决策树中的一个点，代表一个决策或属性。</li>\n<li><strong>根节点（Root Node）</strong>：决策树的起始点，通常代表整个数据集。</li>\n<li><strong>内部节点（Internal Node）</strong>：除了根节点和叶节点之外的其他节点，代表决策过程中的中间步骤。</li>\n<li><strong>叶节点（Leaf Node）</strong>：决策树的末端，代表最终决策或分类结果。</li>\n<li><strong>分支（Branch）</strong>：从一个节点到另一个节点的连接，代表决策的一个可能路径。</li>\n<li><strong>路径（Path）</strong>：从根节点到叶节点的一系列分支。</li>\n</ol>\n<h3 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"构建过程\"></a>构建过程</h3><ol>\n<li><strong>特征选择</strong>：选择一个属性作为节点，该属性能够最好地分类数据。</li>\n<li><strong>分割数据集</strong>：根据所选属性的不同结果，将数据集分割成多个子集。</li>\n<li><strong>递归构建</strong>：对每个子集重复上述过程，直到满足停止条件（如达到最小节点大小、无法进一步分割等）。</li>\n<li><strong>剪枝（Pruning）</strong>：移除一些分支以防止过拟合。</li>\n</ol>\n<h3 id=\"优-缺点\"><a href=\"#优-缺点\" class=\"headerlink\" title=\"优&#x2F;缺点\"></a>优&#x2F;缺点</h3><p><strong>优点</strong></p>\n<ul>\n<li><strong>易于理解和解释</strong>：决策树的结构清晰，易于可视化和解释，有助于理解决策过程。</li>\n<li><strong>自动特征选择</strong>：在构建过程中，决策树能够自动选择最有信息量的特征。</li>\n<li><strong>适用于分类和回归</strong>：决策树既可以用于分类问题，也可以用于回归问题。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li><strong>容易过拟合</strong>：特别是在数据特征数量很多时，决策树可能会变得非常复杂，导致过拟合。</li>\n<li><strong>对噪声和异常值敏感</strong>：决策树可能会受到噪声数据和异常值的较大影响。</li>\n<li><strong>可能不稳定</strong>：小的变化在数据中可能会导致完全不同的决策树结构。</li>\n</ul>\n<h2 id=\"交叉验证\"><a href=\"#交叉验证\" class=\"headerlink\" title=\"交叉验证\"></a>交叉验证</h2><blockquote>\n<p>交叉验证（Cross-validation），也称为“k折交叉验证”，是一种在机器学习和统计学中用于评估模型泛化能力的方法。它将数据集分成多个子集，每个子集作为一次独立的测试集，而剩余的子集合并作为训练集。这个过程重复进行多次并计算模型的平均性能指标，从而得到模型的评估结果。</p>\n</blockquote>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li><strong>数据集划分</strong>：将原始数据集随机划分为k个大小相等（或尽可能相等）的子集。</li>\n<li><strong>循环训练和测试</strong>：进行k次循环，每次循环中：<ul>\n<li>将其中一个子集作为测试集（validation set）。</li>\n<li>将剩余的k-1个子集合并作为训练集（training set）。</li>\n<li>使用训练集训练模型。</li>\n<li>使用测试集评估模型的性能。</li>\n</ul>\n</li>\n<li><strong>计算性能指标</strong>：在每次循环中，计算模型的性能指标（如准确率、召回率、F1分数等）。</li>\n<li><strong>求平均值</strong>：将k次循环中得到的性能指标求平均，得到模型的最终评估结果。</li>\n</ol>\n<h3 id=\"优-缺点-1\"><a href=\"#优-缺点-1\" class=\"headerlink\" title=\"优&#x2F;缺点\"></a>优&#x2F;缺点</h3><p><strong>优点</strong></p>\n<ul>\n<li><strong>评估更准确</strong>：交叉验证提供了比单次分割训练集和测试集更准确的模型性能估计。</li>\n<li><strong>利用全部数据</strong>：所有数据点都被用作训练和测试，这有助于充分利用有限的数据。</li>\n<li><strong>减少方差</strong>：通过多次独立测试，交叉验证减少了模型评估结果的方差。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li><strong>计算成本高</strong>：由于需要多次训练和测试模型，交叉验证的计算成本较高。</li>\n<li><strong>可能存在偏差</strong>：如果数据集中的某些类别在划分子集时分布不均匀，可能会导致模型评估结果的偏差。</li>\n</ul>\n<h3 id=\"常见方法\"><a href=\"#常见方法\" class=\"headerlink\" title=\"常见方法\"></a>常见方法</h3><ol>\n<li><strong>简单交叉验证</strong>：每次只将一个子集作为测试集，其余作为训练集。</li>\n<li><strong>留一法交叉验证（Leave-One-Out Cross-Validation, LOOCV）</strong>：对于每个数据点，将其作为测试集，其余所有点作为训练集。这种方法适用于数据量较小的情况。</li>\n<li><strong>分层交叉验证（Stratified Cross-Validation）</strong>：在类别不平衡的情况下，确保每个子集中各类别的比例与原始数据集中的比例相同。</li>\n<li><strong>时间序列交叉验证（Time Series Cross-Validation）</strong>：对于时间序列数据，按照时间顺序划分子集，以保持数据的时间顺序性。</li>\n</ol>\n<h2 id=\"GridSearchCV-方法\"><a href=\"#GridSearchCV-方法\" class=\"headerlink\" title=\"GridSearchCV 方法\"></a>GridSearchCV 方法</h2><blockquote>\n<p><code>GridSearchCV</code> 是 scikit-learn 库中的一个函数，用于通过遍历给定的参数网格，使用交叉验证来找到最佳的模型参数。</p>\n</blockquote>\n<ol>\n<li><strong>参数网格定义</strong>：首先，你需要定义一个参数字典，其中包含你想要优化的参数以及这些参数的可能值。</li>\n<li><strong>交叉验证</strong>：<code>GridSearchCV</code> 将使用交叉验证来评估每一组参数。对于参数网格中的每一个参数组合，它将执行以下操作：<ul>\n<li>将数据集分成多个子集（通常是k个子集）。</li>\n<li>对于每一组参数，使用k-1个子集作为训练集，剩下的1个子集作为验证集。</li>\n<li>使用训练集上的参数训练模型。</li>\n<li>使用验证集评估模型的性能。</li>\n</ul>\n</li>\n<li><strong>寻找最佳参数</strong>：<code>GridSearchCV</code> 将记录每一组参数的性能，并在所有参数组合中选择平均性能最好的一组参数。</li>\n<li><strong>返回最佳模型</strong>：最终，<code>GridSearchCV</code> 返回使用最佳参数训练的模型，以及这些最佳参数。</li>\n</ol>\n<h2 id=\"R-2评分\"><a href=\"#R-2评分\" class=\"headerlink\" title=\"R^2评分\"></a>R^2评分</h2><p>R2 分数，也称为决定系数，是衡量回归模型性能的指标。它基于模型预测值与实际值之间的相关程度。R2 分数的计算公式如下：</p>\n<p>𝑅2&#x3D;1−∑𝑖&#x3D;1𝑛(𝑦𝑖−𝑦^𝑖)2∑𝑖&#x3D;1𝑛(𝑦𝑖−𝑦ˉ)2<em>R</em>2&#x3D;1−∑<em>i</em>&#x3D;1<em>n</em>(<em>y**i</em>−<em>y</em>ˉ)2∑<em>i</em>&#x3D;1<em>n</em>(<em>y**i</em>−<em>y</em>^<em>i</em>)2</p>\n<p>其中：</p>\n<ul>\n<li>𝑦𝑖<em>y**i</em> 是第 i 个观测值的实际响应变量。</li>\n<li>𝑦^𝑖<em>y</em>^<em>i</em> 是模型预测的第 i 个响应变量。</li>\n<li>𝑦ˉ<em>y</em>ˉ 是所有观测值的实际响应变量的平均值。</li>\n<li>𝑛<em>n</em> 是观测值的总数。</li>\n</ul>\n<p>R2 分数的取值范围从 0 到 1：</p>\n<ul>\n<li>0 表示模型的预测与实际值之间没有相关性，模型的预测与简单使用均值预测一样好。</li>\n<li>1 表示模型的预测与实际值完全相关，模型能够完美地拟合数据。</li>\n</ul>\n","categories":["大数据"],"tags":["机器学习","大数据"]},{"title":"操作系统","url":"/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"运行模式\"><a href=\"#运行模式\" class=\"headerlink\" title=\"运行模式\"></a>运行模式</h2><h3 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h3><ul>\n<li>用户态是操作系统中较低权限的运行级别。</li>\n<li>在用户态下运行的程序不能直接访问硬件资源，也不能执行某些特定的操作，如修改操作系统内核的内存区域。</li>\n<li>用户态通常用于运行普通应用程序，这些程序对系统的控制受到限制。</li>\n</ul>\n<h3 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h3><ul>\n<li>内核态是操作系统中较高权限的运行级别。</li>\n<li>在内核态下运行的程序可以直接访问所有硬件资源，执行系统调用，以及对操作系统内核进行操作。</li>\n<li>内核态通常用于操作系统内核和某些关键的系统程序。</li>\n</ul>\n<h3 id=\"切换\"><a href=\"#切换\" class=\"headerlink\" title=\"切换\"></a>切换</h3><blockquote>\n<p>内核态和用户态之间切换的意义</p>\n</blockquote>\n<ul>\n<li><strong>安全性</strong>：通过限制用户态程序的权限，可以防止恶意软件或错误操作对系统造成严重破坏。</li>\n<li><strong>稳定性</strong>：当用户态程序出现问题时，它不会直接影响到操作系统内核的稳定性，因为内核在更高的权限级别上运行。</li>\n<li><strong>资源管理</strong>：操作系统内核可以控制对硬件资源的访问，合理分配资源给不同的用户态程序。</li>\n<li><strong>多任务处理</strong>：操作系统通过在内核态进行任务调度，可以在多个用户态程序之间切换，实现多任务处理。</li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><h3 id=\"进程、线程、协程\"><a href=\"#进程、线程、协程\" class=\"headerlink\" title=\"进程、线程、协程\"></a>进程、线程、协程</h3><h4 id=\"进程-1\"><a href=\"#进程-1\" class=\"headerlink\" title=\"进程\"></a>进程</h4><ul>\n<li>资源分配最小单位<br>进程有自己独立的代码空间和内存空间，每个进程下的线程共享进程的内存空间</li>\n<li>进程之间相互隔离<br>OS将物理内存地址分为多个虚拟地址，每个进程分配虚拟地址。并且物理地址是分开的做到了隔离，防止A进程写入到B进程。</li>\n<li>父子进程的关系<ul>\n<li>父进程可以使用fork创建一个子进程，并且可以使用if(fork()&#x3D;&#x3D;0)让子进程执行任务</li>\n<li>父子进程的虚拟地址是不同的，但是实际的内存地址指向同一位置</li>\n<li>fork操作是cow的，这意味着如果没有写入的操作，那么读取的都是同一片地址，如果有写入操作，才会给子进程copy一份父进程的资源到新的内存地址</li>\n<li>一般fork操作都会伴随着exec操作，exec操作会用新的程序替换当前的正文段、数据段、堆栈(也就是分配新的物理空间)，并在执行完成后自动退出</li>\n<li>除此外，父进程会给子进程copy一份文件描述符</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h4><ul>\n<li>执行任务最小单位</li>\n<li>线程之间共享内存地址</li>\n</ul>\n<h4 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h4><ul>\n<li>线程内部有多个协程</li>\n<li>特点<ul>\n<li>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</li>\n<li>对于某些操作来说（比如yield），线程需要进行系统调用，但是协程不需要，减少了用户态内核态的切换开销</li>\n<li>一个线程里可以运行多个协程，但本质是串行的</li>\n<li>协程拥有自己的寄存器上下文和操作栈。<ul>\n<li>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和操作栈，</li>\n<li>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><h4 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h4><blockquote>\n<p>Inner Process Communication 进程间通信</p>\n<p>为什么要进程间通信？<br>因为进程之间是相互隔离的，完成某些需要协作的任务就需要通信</p>\n</blockquote>\n<h4 id=\"进程通信方式\"><a href=\"#进程通信方式\" class=\"headerlink\" title=\"进程通信方式\"></a>进程通信方式</h4><h5 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h5><blockquote>\n<p>本质是OS内核开辟的一段可以共享的内存</p>\n</blockquote>\n<ul>\n<li>无名管道<ul>\n<li>pipe(int[2])<ul>\n<li>没有名字的管道</li>\n<li>下标0表示读端</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>只能单向通信</li>\n<li>也是一个文件，有文件描述符（读端和写端）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>有名管道<ul>\n<li>通过mkfifo()调用  有名字的管道</li>\n<li>由于有名字，所以可以使用open方式获得其文件描述符，所以可以用于非亲缘进程之间通信</li>\n<li>但是存在一个问题，就是只能单向通信，如果要双向通信，需要用两个管道</li>\n<li>不适合网状通信</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h5><blockquote>\n<p>OS开辟的一大块内存</p>\n</blockquote>\n<ul>\n<li>最快的通信方式，适合传递大量数据</li>\n<li>共享内存和管道的区别<ul>\n<li>管道小，共享内存大</li>\n<li>管道慢，共享内存块</li>\n<li>管道自己会阻塞，但是共享内存需要我们自己处理</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h5><blockquote>\n<p>锁机制的一种方式，可以传输少量信息</p>\n</blockquote>\n<h5 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h5><ul>\n<li>信号是一条小的消息，由内核或者其它进程生成并发送至目标进程，目标进程可以根据该信号来做出响应。</li>\n<li>如何发送信号<ul>\n<li>键盘输入</li>\n<li>kill命令</li>\n<li>kill函数</li>\n<li>alarm函数</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h5><ul>\n<li>就是一个双向链表</li>\n<li>每一个结点有两个部分<ul>\n<li>消息编号</li>\n<li>消息正文</li>\n</ul>\n</li>\n<li>可以很好的实现网状通信</li>\n</ul>\n<h5 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h5><p>网络通信</p>\n<h3 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h3><h4 id=\"调度准则\"><a href=\"#调度准则\" class=\"headerlink\" title=\"调度准则\"></a>调度准则</h4><p>待补充…</p>\n<h4 id=\"调度算法\"><a href=\"#调度算法\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h4><p>待补充…</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>待补充…</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>待补充…</p>\n<h2 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>0，1，2分别表示标准输入、标准输出、标准错误</p>\n<h3 id=\"如何分配\"><a href=\"#如何分配\" class=\"headerlink\" title=\"如何分配\"></a>如何分配</h3><p>扫描文件描述符表中，没有被使用的数值最小的下标，作为新打开文件的文件描述符</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>屏蔽了底层的管道，IO，把他们全部当做文件来处理</p>\n<h3 id=\"fork-exec\"><a href=\"#fork-exec\" class=\"headerlink\" title=\"fork + exec\"></a>fork + exec</h3><ul>\n<li>fork 操作会copy父进程的内存和文件描述符表</li>\n<li>exec执行操作回替换调用者的执行内存，并且执行完成后自行关闭</li>\n<li>因此经常使用fork+exec进行操作</li>\n</ul>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><blockquote>\n<p>重定向的实现原理</p>\n</blockquote>\n<h4 id=\"为什么要有重定向？\"><a href=\"#为什么要有重定向？\" class=\"headerlink\" title=\"为什么要有重定向？\"></a>为什么要有重定向？</h4><ol>\n<li><strong>分离输出</strong>：可以将程序的输出重定向到一个文件中，而不是显示到屏幕上，这对于日志记录和数据收集非常有用。</li>\n<li><strong>从文件中读取输入</strong>：可以将程序的输入重定向，使其从文件中读取，而不是从标准输入读取。</li>\n<li><strong>错误处理</strong>：可以将错误信息重定向到特定的文件或设备，以便于后续分析和调试。</li>\n<li><strong>管道</strong>：通过重定向，可以将一个程序的输出作为另一个程序的输入，这是Unix哲学中“组合简单命令行工具”的一部分。</li>\n<li><strong>控制I&#x2F;O流向</strong>：在脚本或程序中，重定向可以用来控制I&#x2F;O的流向，使得程序的行为更加灵活和可预测。</li>\n</ol>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>比如 这样一个命令 <code>cat &lt; input.txt</code> 将input.txt文件的内容作为cat 命令的参数执行</p>\n<p>执行是这样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *argv[<span class=\"number\">2</span>];</span><br><span class=\"line\">argv[<span class=\"number\">0</span>] = <span class=\"string\">&quot;cat&quot;</span>;</span><br><span class=\"line\">argv[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    close(<span class=\"number\">0</span>);</span><br><span class=\"line\">    open(<span class=\"string\">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class=\"line\">    exec(<span class=\"string\">&quot;cat&quot;</span>, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个参数数组：<code>[&quot;cat&quot;, 0]</code>（此时的 0 代表着标准输入）</li>\n<li><code>fork</code> 创建了一个子进程，这个子进程会 copy 父进程的内存，即子进程也会拥有 <code>argv</code> 这个指针以及 0、1、2 的文件描述符</li>\n<li>当 <code>fork()</code> 函数返回 0，代表 <code>if</code> 的执行体让<strong>子进程</strong>去执行</li>\n<li>关闭了 0 号文件描述符，将会回收 0（标准输入）的资源；之后 <code>open</code> 打开文件，这个文件描述符就是当前最小的一个数字，也就是刚刚回收的 0（此时的 0 代表着 <code>input.txt</code> 文件的 fd，注意父进程的 fd 表不会被改变）</li>\n<li><code>exec</code> 执行 <code>cat</code> 命令，会占用当前的内存，即会替换子进程的内存，去执行 <code>cat</code> 命令</li>\n</ol>\n<h3 id=\"管道-1\"><a href=\"#管道-1\" class=\"headerlink\" title=\"管道\"></a>管道</h3><blockquote>\n<p>实现原理</p>\n</blockquote>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ol>\n<li><strong>匿名管道（Anonymous Pipe）</strong>：是最原始的管道形式，它通常是在创建子进程时由内核自动建立的。匿名管道只存在于内存中，没有与文件系统中的文件直接关联。</li>\n<li><strong>命名管道（Named Pipe）</strong>：与匿名管道不同，命名管道存在于文件系统中，可以通过文件系统的路径进行访问。它们允许不相关的进程以先进先出（FIFO）的方式来通信。</li>\n</ol>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ol>\n<li><strong>进程间通信（IPC）</strong>：管道是进程间通信的一种方式，允许父子进程或不同进程组之间的数据传递。</li>\n<li><strong>命令行串联</strong>：在Unix和类Unix系统的shell中，可以使用管道符（<code>|</code>）将多个命令串联起来，使得前一个命令的输出成为后一个命令的输入。</li>\n<li><strong>数据过滤</strong>：管道常用于数据过滤和文本处理，如使用<code>grep</code>、<code>sort</code>等命令处理<code>ls</code>或其他命令的输出。</li>\n</ol>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><blockquote>\n<p>fork + dup + exec</p>\n<p>dup 命令是用于复制文件描述符的POSIX标准函数，它属于低级I&#x2F;O操作的一部分。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> p[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span>*argv[<span class=\"number\">2</span>];</span><br><span class=\"line\">argv[<span class=\"number\">0</span>] = <span class=\"string\">&quot;wc&quot;</span>;</span><br><span class=\"line\">argv[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">pipe(p);</span><br><span class=\"line\"><span class=\"comment\">// 此时的fd：0、1、2、3、4</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子进程此时的fd：0、1、2、3、4</span></span><br><span class=\"line\">    close(<span class=\"number\">0</span>);<span class=\"comment\">// 1、2、3、4</span></span><br><span class=\"line\">    dup(p[<span class=\"number\">0</span>]);<span class=\"comment\">// 0、1、2、3、4 (此后的0表示管道的读端)</span></span><br><span class=\"line\">    close(p[<span class=\"number\">0</span>]);<span class=\"comment\">//0、1、2、4</span></span><br><span class=\"line\">    close(p[<span class=\"number\">1</span>]);<span class=\"comment\">//0、1、2</span></span><br><span class=\"line\">    exec(<span class=\"string\">&quot;/bin/wc&quot;</span>, argv);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 父进程此时的fd：0、1、2、3、4</span></span><br><span class=\"line\">    close(p[<span class=\"number\">0</span>]); <span class=\"comment\">// 0、1、2、4</span></span><br><span class=\"line\">    write(p[<span class=\"number\">1</span>], <span class=\"string\">&quot;hello world\\n&quot;</span>, <span class=\"number\">12</span>); <span class=\"comment\">// 由写端写入数据 hello world</span></span><br><span class=\"line\">    close(p[<span class=\"number\">1</span>]); <span class=\"comment\">// 0、1、2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"多路复用\"><a href=\"#多路复用\" class=\"headerlink\" title=\"多路复用\"></a>多路复用</h2><blockquote>\n<p>IO多路复用是一种提高IO效率的技术，允许一个进程能够同时监控多个IO操作（如网络套接字、文件IO等），并在IO事件发生时及时进行处理，从而提高系统的性能和响应速度</p>\n</blockquote>\n<h3 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h3><ol>\n<li><strong>减少系统调用次数</strong>：IO多路复用通过一次系统调用监听多个IO事件，避免了频繁的系统调用，减少了内核态和用户态之间的切换开销，提高了系统的效率。</li>\n<li><strong>提高并发处理能力</strong>：通过IO多路复用，一个进程能够同时监听多个IO事件，只要有任何一个IO事件就绪，进程就能及时响应，从而实现并发处理多个IO操作的能力。</li>\n<li><strong>节省资源</strong>：相比于多线程或多进程模型，IO多路复用不需要创建多个线程或进程来处理不同的IO事件，节省了系统资源，提高了系统的稳定性和可靠性。</li>\n<li><strong>适用于高并发场景</strong>：在高并发的网络编程中，IO多路复用能够更好地管理和处理大量的IO事件，提高系统的网络性能和吞吐量。</li>\n</ol>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><h4 id=\"参数有五个\"><a href=\"#参数有五个\" class=\"headerlink\" title=\"参数有五个\"></a>参数有五个</h4><blockquote>\n<p>int select(int maxfdp1, fd_set*readset, fd_set*writeset, fd_set *exceptset, const struct timeval *timeout)</p>\n</blockquote>\n<ul>\n<li>maxfdp1要轮询的文件描述符的个数</li>\n<li>中间三个都是set，分别表示读、写、异常，如果不关心，就可以设置为null，比如rset 是一个1024bit的bitmap，每一位对应一个文件描述符的监听位，如果有数据，这个监听位就会变成1</li>\n<li>最后一个参数是超时时间，设为null表示等待直到有一个文件描述符准备好，设置值表示超时时间，设置0表示一直轮询</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>数量只有1024</li>\n<li>需要频繁的进行内核态和用户态的copy</li>\n<li>fd_set不能重用</li>\n<li>需要遍历所有的fd_set</li>\n</ol>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><h4 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct pollfd&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> df; <span class=\"comment\">//要轮询的文件描述符fd</span></span><br><span class=\"line\">    <span class=\"type\">short</span> events; <span class=\"comment\">//关心的fd事件：普通数据可读、优先级带数据可读等等</span></span><br><span class=\"line\">    <span class=\"type\">short</span> revents; <span class=\"comment\">//fd上发生的事件</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将事件分为普通数据、优先级带数据、高优先级数据三种\"><a href=\"#将事件分为普通数据、优先级带数据、高优先级数据三种\" class=\"headerlink\" title=\"将事件分为普通数据、优先级带数据、高优先级数据三种\"></a>将事件分为普通数据、优先级带数据、高优先级数据三种</h4><ul>\n<li>普通数据：正规的TCP数据，所有的UDP数据</li>\n<li>优先级带数据（带内数据）：TCP数据包中有额外参数的数据</li>\n<li>高优先级数据（带外数据）：传输一些紧急数据，比如Ctrl+c</li>\n</ul>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><ol>\n<li>需要频繁的进行内核态和用户态的copy</li>\n<li>需要遍历所有的pollfd</li>\n</ol>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><h4 id=\"三个函数\"><a href=\"#三个函数\" class=\"headerlink\" title=\"三个函数\"></a>三个函数</h4><h5 id=\"epoll-create\"><a href=\"#epoll-create\" class=\"headerlink\" title=\"epoll_create\"></a>epoll_create</h5><p>创建epoll对象</p>\n<ul>\n<li>使用红黑树与双向链表的结构<ul>\n<li>红黑树存放关心的文件描述符fd</li>\n<li>双向链表存放发生相关事件数据的fd</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"epoll-ctl\"><a href=\"#epoll-ctl\" class=\"headerlink\" title=\"epoll_ctl\"></a>epoll_ctl</h5><ul>\n<li>添加要监听的fd，及关心的事件，此时就copy epoll对象到内核中</li>\n<li>触发方式有两种<ul>\n<li>水平触发（默认）LT<ul>\n<li>事情可以处理，也可以不处理</li>\n<li>同时支持 Blocking 和 No-Blocking</li>\n<li>只要文件描述符上还有数据可读或可写，就会触发事件。</li>\n<li>当你从 epoll_wait 返回后，如果文件描述符上还有数据可读或可写，下一次调用 epoll_wait 仍然会立即返回该文件描述符上的事件，直到你采取措施来处理这些事件，即使你没有读取或写入数据。</li>\n<li>水平触发适用于处理长时间处于可读或可写状态的连接或套接字。</li>\n</ul>\n</li>\n<li>边缘触发 ET<ul>\n<li>事件必须处理</li>\n<li>只支持No-Blocking</li>\n<li>减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高</li>\n<li>仅当文件描述符上的状态发生变化时（例如，从不可读到可读或从不可写到可写），epoll 才会触发事件。</li>\n<li>边缘触发要求你在处理事件时采取措施，以确保不丢失数据。一旦你处理了一次事件并且文件描述符仍然处于可读或可写状态，epoll 不会立即再次触发事件。你需要继续读取或写入数据，直到再次触发边缘触发事件。</li>\n<li>边缘触发通常要求更谨慎的处理，但可以提供更高的性能，因为它避免了反复触发事件，直到状态发生变化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"epoll-wait\"><a href=\"#epoll-wait\" class=\"headerlink\" title=\"epoll_wait\"></a>epoll_wait</h5><ul>\n<li>系统调用，陷入内核，阻塞等待事件发生</li>\n</ul>\n<h4 id=\"解决poll存在的问题\"><a href=\"#解决poll存在的问题\" class=\"headerlink\" title=\"解决poll存在的问题\"></a>解决poll存在的问题</h4><ol>\n<li>需要频繁的进行内核态和用户态的copy而epoll不需要，只需要copy一次</li>\n<li>需要遍历所有的epollfd epoll的epoll_wait 函数有返回值，返回发生事件的fd数量</li>\n</ol>\n","categories":["八股","操作系统"],"tags":["线程","进程","协程","操作系统"]},{"title":"计算机网络","url":"/2024/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h2 id=\"七层模型（OSI模型）\"><a href=\"#七层模型（OSI模型）\" class=\"headerlink\" title=\"七层模型（OSI模型）\"></a>七层模型（OSI模型）</h2><h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><ul>\n<li>为应用软件提供网络服务，如文件传输，电子邮件和其他网络软件服务</li>\n<li>协议示例 HTTP、FTP、SMTP（简单邮件传输协议）</li>\n</ul>\n<h3 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h3><ul>\n<li>确保一个系统发送的信息能被另一个系统的应用层读取，进行数据的翻译和加密</li>\n<li>协议示例：ASCII，JPEG，SSL&#x2F;TSL（安全层协议）</li>\n</ul>\n<h3 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h3><ul>\n<li>管理和控制应用程序之间的会话，提供数据交换的同步和组织</li>\n<li>协议实例：SOCKS（代理服务器协议）、RPC</li>\n</ul>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><ul>\n<li>负责提供端到端的数据传输服务，确保数据的完整性和顺序</li>\n<li>协议示例：TCP、UDP</li>\n</ul>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><ul>\n<li>负责数据包从源到目的地的传输和路由选择，处理数据包在网络中的移动</li>\n<li>协议示例：IP、ICMP（互联网控制消息协议）</li>\n</ul>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><ul>\n<li>负责在相邻节点之间的物理链路上传输数据帧，处理帧的寻址、错误检测和纠正</li>\n<li>协议示例：Ethernet（以太网）、PPP（点对点协议）</li>\n</ul>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><ul>\n<li>负责在物理媒介上传输原始的比特流，定义了电气、机械、过程和功能标准</li>\n<li>协议示例：RS-232、V.35、Fiber Optic（光纤）</li>\n</ul>\n<blockquote>\n<p>五层模型只出现在计算机网络学习教学过程中，他是对七层模型和四层模型的一个折中，及综合了OSI和TCP&#x2F;IP 体系结构的优点，这样既简洁又能将概念阐述清楚，（主要是因为官方的7层模型太过麻烦复杂）因此主要差别是去掉了会话层和表示层，而传输层改为了运输层，因为他们觉得运输名字更贴切。</p>\n</blockquote>\n<h2 id=\"五层模型\"><a href=\"#五层模型\" class=\"headerlink\" title=\"五层模型\"></a>五层模型</h2><ul>\n<li>应用层<br>最顶层，提供应用程序与网络通信的接口，如HTTP，SMTP，FTP等协议。</li>\n<li>传输层<br>负责端到端的数据传输，提供可靠的数据传输服务，如TCP、UDP协议。</li>\n<li>网络层<br>负责在网络中建立和维护节点之间的连接，并选择最佳的路径进行数据传输，如IP协议。</li>\n<li>数据链路层<br>负责将数据帧从一个节点传输到相邻节点，提供了一些错误检测和纠正的功能，如以太网协议。</li>\n<li>物理层<br>最底层，负责传输原始比特流通过物理介质，如电缆、光纤或无线电波。</li>\n</ul>\n<h2 id=\"应用层-1\"><a href=\"#应用层-1\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><h4 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h4><ul>\n<li>本地域名服务器</li>\n<li>根域名服务器</li>\n<li>顶级域名服务器</li>\n<li>权限域名服务器</li>\n</ul>\n<h4 id=\"递归查询\"><a href=\"#递归查询\" class=\"headerlink\" title=\"递归查询\"></a>递归查询</h4><p>本地域名服务器代替我们进行DNS查询，查找到IP，或者确认ip不存在</p>\n<h4 id=\"迭代查询\"><a href=\"#迭代查询\" class=\"headerlink\" title=\"迭代查询\"></a>迭代查询</h4><p>各个级别的域名服务器分工合作，得到最终的域名服务器</p>\n<h4 id=\"当我们在地址栏输入一个网址后的过程\"><a href=\"#当我们在地址栏输入一个网址后的过程\" class=\"headerlink\" title=\"当我们在地址栏输入一个网址后的过程\"></a>当我们在地址栏输入一个网址后的过程</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240318200907799.png\" alt=\"image-20240318200907799\"></p>\n<ol>\n<li>输入网址<a href=\"https://www.xxx.xxx.xx/\">https://www.xxx.xxx.xx</a></li>\n<li>不知道ip时（只有域名），就会进行DNS查询，将域名转换为IP地址<ul>\n<li>查询浏览器缓存</li>\n<li>查询系统缓存 –》hosts文件</li>\n<li>查询路由表</li>\n<li>查询本地域名服务器，本地域名服务器代理我们访问其域名服务器<ul>\n<li>查询根域名服务器 得到顶级域名服务器地址</li>\n<li>查询顶级域名服务器 得到二级域名服务器（权威域名服务器地址）</li>\n<li>查询权威名称服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>知道ip后，开始TCP三次握手</li>\n<li>连接建立后开始TLS&#x2F;SSL握手</li>\n<li>开始安全通信</li>\n</ol>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><blockquote>\n<p>HTTP(Hyper Transfer Protocol超文本传输协议)</p>\n<p>无状态</p>\n<p>无需连接（底层需要TCP连接）</p>\n<p>半双工</p>\n</blockquote>\n<h4 id=\"HTTP报文结构\"><a href=\"#HTTP报文结构\" class=\"headerlink\" title=\"HTTP报文结构\"></a>HTTP报文结构</h4><h5 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h5><h6 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h6><ul>\n<li>结构是方法、网址、版本号：GET<a href=\"http://www.baidu.com/\">www.baidu.com</a> HTTP&#x2F;1.1</li>\n<li>RESTFUL风格方法<ul>\n<li>GET</li>\n<li>POST<ul>\n<li>GET POST的区别<ol>\n<li>get幂等安全，post不幂等不安全。幂等：请求多少次都一样，安全：请求不会更改服务器资源</li>\n<li>get参数有限，明文传输；post参数无限</li>\n<li>get没有请求体</li>\n<li>get请求会被浏览器缓存，post不会</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h6><ul>\n<li>多种字段</li>\n<li>Accept：text&#x2F;heml,image&#x2F;* 支持的数据类型</li>\n<li>Host:<a href=\"http://www.xxx.xxx.xx/\">www.xxx.xxx.xx</a> 想要访问的主机</li>\n<li>Referer：防盗链，浏览器告诉服务器自己从哪个页面而来</li>\n<li>User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT 5.0) 浏览器内核</li>\n<li>Cookie</li>\n<li>Connection：Close&#x2F;Keep-Alive  本次请求后连接是否断开</li>\n</ul>\n<h6 id=\"请求空行\"><a href=\"#请求空行\" class=\"headerlink\" title=\"请求空行\"></a>请求空行</h6><p>分隔请求头和请求体</p>\n<h6 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h6><h5 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h5><h6 id=\"响应行\"><a href=\"#响应行\" class=\"headerlink\" title=\"响应行\"></a>响应行</h6><ul>\n<li>HTTP&#x2F;1.1 200ok</li>\n<li>状态码<ul>\n<li>200 正常</li>\n<li>301 资源永久重定向</li>\n<li>302 资源临时重定向，会将 POST 转化为 GET(默认情况下，重定向请求的方法应该与原始请求的方法相同,但POST不幂等，不安全，对服务器有影响,也是为了防止重复提交)</li>\n<li>307 同302，但不会更改post为get</li>\n<li>400 请求的报文有误，是一个笼统的状态码</li>\n<li>401 需要确认身份</li>\n<li>403 禁止访问，权限不允许</li>\n<li>404 资源找不到</li>\n<li>5xx 服务端错误</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h6><ul>\n<li>Set-Cookie 设置Cookie</li>\n<li>Connection: close&#x2F;Keep-Alive  连接状态</li>\n<li>Location  跳转的网页</li>\n<li>Cache-Control: no-cache 是否设置缓存 替代Expires和Last-Modified</li>\n<li>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 上次更改时间</li>\n<li>Content-Type: text&#x2F;html; charset&#x3D;GB2312 响应数据的类型</li>\n</ul>\n<h6 id=\"响应空行\"><a href=\"#响应空行\" class=\"headerlink\" title=\"响应空行\"></a>响应空行</h6><p>分隔响应头和响应体</p>\n<h6 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h6><h5 id=\"HTTP1-0\"><a href=\"#HTTP1-0\" class=\"headerlink\" title=\"HTTP1.0\"></a>HTTP1.0</h5><h6 id=\"端口80\"><a href=\"#端口80\" class=\"headerlink\" title=\"端口80\"></a>端口80</h6><h6 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h6><ul>\n<li>非持续连接<ul>\n<li>每个请求和响应体都需要一个单独的TCP发送</li>\n<li>10张图片我们就得TCP连接10次</li>\n</ul>\n</li>\n<li>队头阻塞 有一个HTTP请求阻塞，之后的都会阻塞</li>\n<li>一次响应一次发送 只有等待第一个请求响应后，才能发送第二个请求</li>\n<li>无状态 不保存任何状态</li>\n<li>数据明文传输</li>\n</ul>\n<h5 id=\"HTTP1-1\"><a href=\"#HTTP1-1\" class=\"headerlink\" title=\"HTTP1.1\"></a>HTTP1.1</h5><h6 id=\"改进点\"><a href=\"#改进点\" class=\"headerlink\" title=\"改进点\"></a>改进点</h6><ul>\n<li>持续连接<ul>\n<li>多个请求和响应可以使用同一个TCP连接</li>\n<li>Connection:Keep-Alive</li>\n</ul>\n</li>\n<li>管道网络传输<ul>\n<li>无需等待响应就可以发出第二个</li>\n<li>没有解决队头阻塞，有一个响应出现丢包，依然会阻塞</li>\n<li>实际上没有多少浏览器支持了这项功能，而是使用其他方式</li>\n</ul>\n</li>\n<li>改进无状态 使用Cookie保存数据</li>\n</ul>\n<h6 id=\"依然存在的问题\"><a href=\"#依然存在的问题\" class=\"headerlink\" title=\"依然存在的问题\"></a>依然存在的问题</h6><ul>\n<li>队头阻塞</li>\n<li>请求响应头部很大，没有压缩，传输压力大</li>\n<li>没有请求优先级控制</li>\n<li>请求只能从客户端发起</li>\n<li>明文传输</li>\n</ul>\n<h5 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h5><h6 id=\"端口443\"><a href=\"#端口443\" class=\"headerlink\" title=\"端口443\"></a>端口443</h6><h6 id=\"加了TLS-SSL传输层安全协议\"><a href=\"#加了TLS-SSL传输层安全协议\" class=\"headerlink\" title=\"加了TLS&#x2F;SSL传输层安全协议\"></a>加了TLS&#x2F;SSL传输层安全协议</h6><h6 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h6><ul>\n<li>对称加密+非对称加密</li>\n<li>摘要算法，负责校验数据完整性</li>\n<li>数字证书，验证数据是否安全</li>\n</ul>\n<h6 id=\"SSL握手过程（发生在HTTP三次握手建立后）\"><a href=\"#SSL握手过程（发生在HTTP三次握手建立后）\" class=\"headerlink\" title=\"SSL握手过程（发生在HTTP三次握手建立后）\"></a>SSL握手过程（发生在HTTP三次握手建立后）</h6><ol>\n<li>客户端发起握手：发送ClientHello消息 包含TLS版本、加密套件、第一随机数</li>\n<li>服务器收到回应：发送ServerHello消息 包含TLS版本、加密套件、第二随机数</li>\n<li>服务器发送数字证书给客户端：发送Certificate消息（可选） 包含公钥和证书信息</li>\n<li>服务器端发送ServerKeyExchange消息 <ul>\n<li>对于RSA算法，它的公钥在证书内，不需要发送此消息</li>\n<li>对于DH算法，需要在此消息中协商DH参数</li>\n</ul>\n</li>\n<li>服务器端发送ServerHelloDone：表示消息发送完毕</li>\n<li>客户端认证证书，进行秘钥交换<ul>\n<li>浏览器收到证书，对照信任证书列表，确认是否可信</li>\n<li>如果可信，RSA算法从证书获得公钥，生成48字节的预主秘钥（第三随机数）用公钥加密，发给服务器，服务器用自己的私钥解密，得到预主秘钥</li>\n<li>预主秘钥是一个临时的对称秘钥</li>\n</ul>\n</li>\n<li>服务器和客户端都使用第一随机数和第二随机数生成对称加密秘钥，用于后续通信</li>\n</ol>\n<h5 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h5><h6 id=\"优化了之前存在的问题\"><a href=\"#优化了之前存在的问题\" class=\"headerlink\" title=\"优化了之前存在的问题\"></a>优化了之前存在的问题</h6><ul>\n<li>头部压缩 HPACK算法，即客户端和服务器各自维护一个头信息表，这样减少每次发送的头信息的大小</li>\n<li>二进制化 消息头和消息体不再明文传输，而是二进制格式发送</li>\n<li>无序发送 同一个连接里面连续的数据包，可能属于不同的回应</li>\n<li>解决队头阻塞 <ul>\n<li>可以并发进行请求，并且可以并发响应，还不用按顺序，因为数据帧有流标识符标记</li>\n<li>如何解决的？<ul>\n<li>每一个数据包称为一个数据流</li>\n<li>每一个数据流都有一个编号，客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</li>\n<li>客户端还可以指定数据流的优先级</li>\n<li>报文含有流标识符，这样解决无序响应的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>服务器可以主动推送信息</li>\n</ul>\n<h6 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h6><p>TCP性能出现短板 多个HTTP请求复用一个TCP连接，一旦TCP连接丢包，就会触发TCP的重传机制，这样所有的HTTP请求都必须等待丢包重传</p>\n<h5 id=\"HTTP3-0\"><a href=\"#HTTP3-0\" class=\"headerlink\" title=\"HTTP3.0\"></a>HTTP3.0</h5><blockquote>\n<p>基于QUIC协议</p>\n<p>本质上QUIC协议是为了取代TCP协议而出现的</p>\n<p>QUIC协议依托于UDP协议</p>\n<p>整合了TLS1.3、HTTP2.0、TCP的握手、流量控制、拥塞控制</p>\n</blockquote>\n<h6 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h6><ul>\n<li>连接建立快</li>\n<li>扛丢包能力强</li>\n<li>自带加密，多路复用</li>\n<li>握手<ul>\n<li>HTTP2.0需要TCP3次握手+TLS三次握手&#x3D;6次</li>\n<li>QUIC只需要3次</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><ul>\n<li>吃CPU性能</li>\n<li>兼容性和部署问题</li>\n</ul>\n<h6 id=\"如何使用UDP实现可靠传输？\"><a href=\"#如何使用UDP实现可靠传输？\" class=\"headerlink\" title=\"如何使用UDP实现可靠传输？\"></a>如何使用UDP实现可靠传输？</h6><p>QUIC</p>\n<p>在UDP上层封装一层协议，使用UDP进行丢失重传、流量控制、拥塞控制、加上序列号、超时机制</p>\n<h2 id=\"传输层-1\"><a href=\"#传输层-1\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>无连接</li>\n<li>尽最大努力交付，但是不一定发送成功</li>\n<li>面向报文</li>\n<li>支持一对一，一对多，多对多</li>\n</ul>\n<h4 id=\"UDP首部（8字节）\"><a href=\"#UDP首部（8字节）\" class=\"headerlink\" title=\"UDP首部（8字节）\"></a>UDP首部（8字节）</h4><ul>\n<li>源端口</li>\n<li>目的端口</li>\n<li>长度</li>\n<li>检验和<ul>\n<li>检验需要加伪首部，伪首部只用于校验是否正确，并不会具体发送<ul>\n<li>源IP</li>\n<li>目的IP</li>\n<li>全0 1个字节，全是0</li>\n<li>协议 </li>\n<li>长度</li>\n</ul>\n</li>\n<li>检验时，使用首部、伪首部、数据字段检验，三者求和取反码，将结果存入检验和字</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>需要建立连接</li>\n<li>可靠交付</li>\n<li>面向字节流</li>\n<li>只支持一对一</li>\n</ul>\n<h4 id=\"首部\"><a href=\"#首部\" class=\"headerlink\" title=\"首部\"></a>首部</h4><blockquote>\n<p>20 固定+ 40 可选<br>可选部分支持安全、时间戳等额外的功能。可选部分的长度是可变的，最多可以有 40 字节</p>\n</blockquote>\n<ul>\n<li>源端口</li>\n<li>目的端口</li>\n<li>序号 本报文段要发送的第一个字节的字节号，TCP按字节编号</li>\n<li>确认号 期望收到的下一个字节的编号 确认号为N，代表N-1全部收到</li>\n<li>数据偏移 就是首部长度</li>\n<li>保留 全为0，今后使用，目前无实际意义</li>\n<li>URG 紧急，如果为1表示此报文段优先传输  比如Ctrl+c命令</li>\n<li>ACK 确认收到</li>\n<li>PSH 推送，无需等待到缓存慢再发，直接发送</li>\n<li>PST复位，表明要断开连接，重新建立</li>\n<li>SYN 同步，建立连接使用</li>\n<li>SYN 终止：表明发送方已经发送完毕，要求终止连接</li>\n<li>窗口 接受窗口的大小</li>\n<li>检验和 同UDP的检验，需要与伪首部、首部、数据一同计算</li>\n<li>紧急指针</li>\n<li>选项（可变长度，最长是40字节）<ul>\n<li>MSS最大报文段长度 默认536（不包括头）</li>\n<li>窗口扩大选项</li>\n<li>时间戳<ul>\n<li>用于计算RTT时间（往返时间）</li>\n<li>判断序号是否重复使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"如何实现可靠传输？\"><a href=\"#如何实现可靠传输？\" class=\"headerlink\" title=\"如何实现可靠传输？\"></a>如何实现可靠传输？</h4><h5 id=\"首部字段：序号和确认号\"><a href=\"#首部字段：序号和确认号\" class=\"headerlink\" title=\"首部字段：序号和确认号\"></a>首部字段：序号和确认号</h5><ul>\n<li><p>序号本报文段要发送的第一个字节的字节号，TCP按字节编号</p>\n</li>\n<li><p>确认号</p>\n<ul>\n<li>期望收到的下一个字节的编号</li>\n<li>确认号为N，代表N-1全部收到</li>\n</ul>\n</li>\n<li><p>连续ARQ协议：规定发送方每收到一个确认请求，就将窗口向前推进一个位置；接收方进行累积确认</p>\n<p>累积确认：对按序到达的最后一个分组发送确认<br>回退N：如果丢了一个包，则需要重新发送丢包及其之后的所有包</p>\n</li>\n</ul>\n<h5 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h5><ul>\n<li>3个窗口+1门限<ul>\n<li>发送窗口</li>\n<li>接收窗口</li>\n<li>拥塞窗口</li>\n<li>慢开始门限</li>\n</ul>\n</li>\n<li>滑动窗口协议<ul>\n<li>TCP 通信双方均维护一个发送缓存与接收缓存（实现全双工）</li>\n<li>发送缓存<br>存放两种数据<ol>\n<li>还没发出去的数据</li>\n<li>已经发出去还没确认的数据</li>\n</ol>\n</li>\n<li>接收缓存<ol>\n<li>按序到达，但是尚未读取的</li>\n<li>未能按序到达的数据</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><h5 id=\"cwnd\"><a href=\"#cwnd\" class=\"headerlink\" title=\"cwnd\"></a>cwnd</h5><blockquote>\n<p>什么是cwnd？</p>\n<ul>\n<li>用于控制发送方可以发送到网络上未经确认的数据量，以避免网络拥塞。cwnd的大小会影响数据流量的控制和网络吞吐量</li>\n<li>具体来说，cwnd表示了当前发送方可以发送的数据量大小，单位为字节。发送发发送数据时，会根据cwnd的大小来控制发送的数据量，确保网络中的数据包不会过多导致拥塞</li>\n<li>TCP的拥塞控制算法使用cwnd来动态调整发送数据的速率。</li>\n</ul>\n</blockquote>\n<h5 id=\"sshresh\"><a href=\"#sshresh\" class=\"headerlink\" title=\"sshresh\"></a>sshresh</h5><blockquote>\n<p>什么是sshresh?</p>\n<ul>\n<li>sshresh(Slow Start Threshold) 是TCP拥塞控制算法中的一个参数，用于指示拥塞避免阶段的门限。当TCP进入拥塞避免阶段时，拥塞窗口cwnd的速率会由指数增长变为线性增长，而sshresh就是触发这个阶段转换的门限值</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>如何判断出现了阻塞？</p>\n<ul>\n<li>出现了超时重传（快重传）</li>\n<li>出现了丢包</li>\n<li>出现了ACK延迟或是重复</li>\n</ul>\n</li>\n<li><p>拥塞窗口cwnd</p>\n<ul>\n<li><p>发送方维持</p>\n</li>\n<li><p>拥塞控制，慢开始门限ssthresh</p>\n<ol>\n<li><p>cwnd&lt;ssthresh  (慢开始门限)  每经过一个RTT就翻倍cwnd</p>\n<ol>\n<li>cwnd&#x3D;ssthresh 二者选一</li>\n</ol>\n</li>\n<li><p>cwnd&gt;ssthresh 拥塞避免 经过一个RTT线性增长cwnd</p>\n</li>\n<li><p>出现拥塞</p>\n<ul>\n<li>将ssthresh&#x3D;cwnd&#x2F;2</li>\n<li>将cwnd &#x3D; 1</li>\n</ul>\n</li>\n<li><p>出现三个重复的ACK</p>\n<ul>\n<li><p>快重传<br>收到3个重复的确认信息，就判断当前的网络不好，要求接收方进行快重传；<br>快重传的意思是：即使是收到了乱序的报文段，也要立即发送确认；并且不要再等待缓存满再发送了，ACK要直接进行发送</p>\n</li>\n<li><p>快恢复<br>一般与快重传一起使用，会设置拥塞窗口更大一点</p>\n<p>拥塞窗口设置为当前值cwnd &#x3D; ssthresh，而不是设置为1</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"计时器\"><a href=\"#计时器\" class=\"headerlink\" title=\"计时器\"></a>计时器</h5><ul>\n<li>连接计时器</li>\n<li>重传计时器</li>\n<li>保活计时器</li>\n<li>FIN_WAIT_2计时器</li>\n<li>TIME_WAIT定时器</li>\n</ul>\n<h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240319180555403.png\" alt=\"image-20240319180555403\"></p>\n<h5 id=\"第一次握手（SYN-1，seq-x）\"><a href=\"#第一次握手（SYN-1，seq-x）\" class=\"headerlink\" title=\"第一次握手（SYN&#x3D;1，seq&#x3D;x）\"></a>第一次握手（SYN&#x3D;1，seq&#x3D;x）</h5><p>客户端发送一个TCP的SYN标志为1的包，指明客户端打算连接的服务器的端口，以及初始序号x，保存在包头的序列号字段里</p>\n<h5 id=\"第二次握手（SYN-1，ACK-1，seq-y，ACKnum-x-1）\"><a href=\"#第二次握手（SYN-1，ACK-1，seq-y，ACKnum-x-1）\" class=\"headerlink\" title=\"第二次握手（SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ACKnum&#x3D;x+1）\"></a>第二次握手（SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ACKnum&#x3D;x+1）</h5><p>服务器发回确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器端选择自己ISN序列号，放到seq域里，同时将确认序号设置为客户的ISN加1，即X+1。发送完毕后，服务器端进入SYN_RCVD状态</p>\n<h5 id=\"第三次握手（ACK-1，ACKnum-y-1）\"><a href=\"#第三次握手（ACK-1，ACKnum-y-1）\" class=\"headerlink\" title=\"第三次握手（ACK&#x3D;1，ACKnum&#x3D;y+1）\"></a>第三次握手（ACK&#x3D;1，ACKnum&#x3D;y+1）</h5><p>客户端再次发送确认包（ACK），SYN标志位0，ACK标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。</p>\n<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束</p>\n<h5 id=\"为什么是三次握手而不是两次？\"><a href=\"#为什么是三次握手而不是两次？\" class=\"headerlink\" title=\"为什么是三次握手而不是两次？\"></a>为什么是三次握手而不是两次？</h5><p>根本原因: 无法确认客户端的接收能力。</p>\n<p>如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p>\n<p>看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。</p>\n<p>看到问题的吧，这就带来了连接资源的浪费。</p>\n<h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h4><p><img data-src=\"https://img.jyhmw.cn/image-20240319182209169.png\" alt=\"image-20240319182209169\"></p>\n<h5 id=\"第一次挥手（FIN-1，seq-x）\"><a href=\"#第一次挥手（FIN-1，seq-x）\" class=\"headerlink\" title=\"第一次挥手（FIN&#x3D;1，seq&#x3D;x）\"></a>第一次挥手（FIN&#x3D;1，seq&#x3D;x）</h5><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>\n<p>发送完毕后，客户端进入 FIN_WAIT_1 状态</p>\n<h5 id=\"第二次挥手（ACK-1，ACKnum-x-1）\"><a href=\"#第二次挥手（ACK-1，ACKnum-x-1）\" class=\"headerlink\" title=\"第二次挥手（ACK&#x3D;1，ACKnum&#x3D;x+1）\"></a>第二次挥手（ACK&#x3D;1，ACKnum&#x3D;x+1）</h5><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>\n<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接</p>\n<h5 id=\"第三次挥手（FIN-1，seq-y）\"><a href=\"#第三次挥手（FIN-1，seq-y）\" class=\"headerlink\" title=\"第三次挥手（FIN&#x3D;1，seq&#x3D;y）\"></a>第三次挥手（FIN&#x3D;1，seq&#x3D;y）</h5><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1</p>\n<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK</p>\n<h5 id=\"第四次挥手（ACK-1，ACKnum-y-1）\"><a href=\"#第四次挥手（ACK-1，ACKnum-y-1）\" class=\"headerlink\" title=\"第四次挥手（ACK&#x3D;1，ACKnum&#x3D;y+1）\"></a>第四次挥手（ACK&#x3D;1，ACKnum&#x3D;y+1）</h5><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p>\n<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>\n<p><em><strong>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，在这段时间内如果客户端没有收到服务端的重发请求（没有收到服务器端的 ACK ），那么表示 ACK 成功到达，于是自己也关闭连接，进入 CLOSED 状态，挥手结束；否则客户端重发 ACK)</strong></em></p>\n<h5 id=\"为什么是四次挥手不是三次？\"><a href=\"#为什么是四次挥手不是三次？\" class=\"headerlink\" title=\"为什么是四次挥手不是三次？\"></a>为什么是四次挥手不是三次？</h5><p>因为服务端收到FIN，不会立即返回FIN，必须等到服务端所有报文发送完毕后，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p>\n<h5 id=\"如果将ACK和FIN合并为一次，即总共三次挥手会出现什么问题？\"><a href=\"#如果将ACK和FIN合并为一次，即总共三次挥手会出现什么问题？\" class=\"headerlink\" title=\"如果将ACK和FIN合并为一次，即总共三次挥手会出现什么问题？\"></a>如果将ACK和FIN合并为一次，即总共三次挥手会出现什么问题？</h5><p>等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h4 id=\"TCP和UDP的区别？\"><a href=\"#TCP和UDP的区别？\" class=\"headerlink\" title=\"TCP和UDP的区别？\"></a>TCP和UDP的区别？</h4><ul>\n<li>TCP面向流，可靠传输，需要建立连接，只支持一对一</li>\n<li>UDP面向数据包，尽最大努力交付，无需建立连接，支持一对一、一对多、多对多</li>\n</ul>\n<h4 id=\"TCP的粘包半包问题是什么？为什么会出现？怎么解决？\"><a href=\"#TCP的粘包半包问题是什么？为什么会出现？怎么解决？\" class=\"headerlink\" title=\"TCP的粘包半包问题是什么？为什么会出现？怎么解决？\"></a>TCP的粘包半包问题是什么？为什么会出现？怎么解决？</h4><ul>\n<li>粘包：多个数据包“粘在一起”，形成一个大的数据包</li>\n<li>半包：半包问题是指接收方收到的数据包不完整，只包含了部分数据。这可能是因为发送方发送的数据包在传输过程中被拆分，或者接收方的缓冲区不足以容纳整个数据包</li>\n<li>原因：<ul>\n<li>TCP是面向流的协议，它的特性就是没有边界；NAGLE算法会将小的TCP请求插到其他请求内，这就导致TCP的请求是毫无边界的</li>\n<li>Nagle算法：将小的数据报（没有达到最大报文段长度MSS）的数据包缓存起来，凑几个一起发送</li>\n</ul>\n</li>\n<li>解决：<ul>\n<li>发送方和接收方固定发送数据的大小，当字符长度不够时用空字符弥补，有了固定大小之后就知道每条消息的具体边界了，这样就没有粘包的问题了</li>\n<li>在 TCP 协议的基础上封装一层自定义数据协议，在自定义数据协议中，包含数据头（存储数据的大小）和 数据的具体内容，这样服务端得到数据之后，通过解析数据头就可以知道数据的具体长度了，也就没有粘包的问题了</li>\n<li>以特殊的字符结尾，比如以“\\n”结尾，这样我们就知道数据的具体边界了，从而避免了粘包问题</li>\n</ul>\n</li>\n</ul>\n","categories":["八股","计算机网络"],"tags":["计算机网络"]}]