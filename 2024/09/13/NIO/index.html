<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jyhmw.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java的NIO详细介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO">
<meta property="og:url" content="https://jyhmw.github.io/2024/09/13/NIO/index.html">
<meta property="og:site_name" content="MWBlog">
<meta property="og:description" content="Java的NIO详细介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.jyhmw.cn/image-20211002193300542.png">
<meta property="og:image" content="https://img.jyhmw.cn/image-20240913112720081.png">
<meta property="og:image" content="https://img.jyhmw.cn/image-20210920130513661.png">
<meta property="og:image" content="https://img.jyhmw.cn/image-20210920151712340.png">
<meta property="og:image" content="https://img.jyhmw.cn/image-20211005142906453.png">
<meta property="og:image" content="https://img.jyhmw.cn/image-20211005143453665.png">
<meta property="article:published_time" content="2024-09-12T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-13T07:43:22.719Z">
<meta property="article:author" content="Jyh">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="NIO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.jyhmw.cn/image-20211002193300542.png">


<link rel="canonical" href="https://jyhmw.github.io/2024/09/13/NIO/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jyhmw.github.io/2024/09/13/NIO/","path":"2024/09/13/NIO/","title":"NIO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NIO | MWBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MWBlog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">麻木的智力抑制状态</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&id=1822761395&auto=0&height=66"></iframe>
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3"><span class="nav-number">1.2.</span> <span class="nav-text">简单了解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO%E4%B8%8EBIO%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.1.</span> <span class="nav-text">NIO与BIO对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">大致过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Buffer"><span class="nav-number">2.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">2.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BABuffer"><span class="nav-number">2.2.</span> <span class="nav-text">创建Buffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%8F%98%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">属性及变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.4.</span> <span class="nav-text">直接缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%95%A3%E8%AF%BB%E4%B8%8E%E9%9B%86%E4%B8%AD%E5%86%99"><span class="nav-number">2.5.</span> <span class="nav-text">分散读与集中写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.</span> <span class="nav-text">TCP粘包问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Channel"><span class="nav-number">3.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FileChannel"><span class="nav-number">3.1.</span> <span class="nav-text">FileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96FileChannel"><span class="nav-number">3.1.1.</span> <span class="nav-text">获取FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%88%B0Buffer%E4%B8%AD"><span class="nav-number">3.1.2.</span> <span class="nav-text">读到Buffer中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%88%B0%E9%80%9A%E9%81%93%E4%B8%AD"><span class="nav-number">3.1.3.</span> <span class="nav-text">写到通道中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#force%E4%B8%8ERandomAccessFile"><span class="nav-number">3.1.5.</span> <span class="nav-text">force与RandomAccessFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.1.6.</span> <span class="nav-text">通道间通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket%E9%80%9A%E9%81%93"><span class="nav-number">3.2.</span> <span class="nav-text">Socket通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerSocketChannel"><span class="nav-number">3.2.1.</span> <span class="nav-text">ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScoketChannel"><span class="nav-number">3.2.2.</span> <span class="nav-text">ScoketChannel</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Selector"><span class="nav-number">4.</span> <span class="nav-text">Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">有关的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8BSelector%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.3.</span> <span class="nav-text">建立Selector系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector%E4%B8%89%E4%B8%AA%E9%9B%86%E5%90%88"><span class="nav-number">4.4.</span> <span class="nav-text">Selector三个集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SelectionKey"><span class="nav-number">4.5.</span> <span class="nav-text">SelectionKey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ESelector"><span class="nav-number">4.6.</span> <span class="nav-text">关于Selector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C"><span class="nav-number">4.7.</span> <span class="nav-text">处理消息边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5"><span class="nav-number">4.7.1.</span> <span class="nav-text">异常情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9buffer"><span class="nav-number">4.7.2.</span> <span class="nav-text">如何扩容buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO%E6%9C%8D%E5%8A%A1%E5%99%A8Demo"><span class="nav-number">4.8.</span> <span class="nav-text">NIO服务器Demo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-number">4.9.</span> <span class="nav-text">多线程优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">4.9.1.</span> <span class="nav-text">如何优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="nav-number">4.9.2.</span> <span class="nav-text">实现逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.9.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89"><span class="nav-number">4.10.</span> <span class="nav-text">零拷贝（未完）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jyh"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jyh</p>
  <div class="site-description" itemprop="description">莫听穿林打叶声，何妨吟啸且徐行。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jyhmw.github.io/2024/09/13/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jyh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MWBlog">
      <meta itemprop="description" content="莫听穿林打叶声，何妨吟啸且徐行。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="NIO | MWBlog">
      <meta itemprop="description" content="Java的NIO详细介绍">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NIO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-09-13 00:00:00 / 修改时间：15:43:22" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">技术栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/NIO/" itemprop="url" rel="index"><span itemprop="name">NIO</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">Java的NIO详细介绍</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>NIO：可以叫做Non - Blocking IO，也可以成为New IO，<strong>非阻塞只是NIO的特点之一</strong></p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>不用NIO情况下如何实现一个服务器</strong></p>
<p><strong>法一</strong>：多线程</p>
<ul>
<li>特点：一个Socket连接，使用一个线程管理</li>
<li>有点：一对一服务，适合连接数少的场景</li>
<li>缺点：<ul>
<li>内存占用高</li>
<li>现成上下文切换成本高</li>
</ul>
</li>
</ul>
<p><strong>法二</strong>：线程池</p>
<ul>
<li>特点：</li>
<li>使用线程池思想，控制线程数量</li>
<li>优点：避免了创建大量的线程导致内存占用过高的问题，适合<strong>短连接场景</strong></li>
<li>缺点：属于阻塞模式（即一个线程同时只能给一个 socket 连接提供服务），线程的利用率不高</li>
</ul>
<p><strong>法三</strong>：使用 NIO 的 Selector</p>
<ul>
<li>特点：用一个线程管理 Selector，Selector 去管理注册在此的通道（下面会详细介绍）</li>
<li>优点：适合<strong>连接数多，但是流量低</strong>的场景（low traffic）</li>
</ul>
<p><img data-src="https://img.jyhmw.cn/image-20211002193300542.png" alt="示意图"></p>
<h2 id="简单了解"><a href="#简单了解" class="headerlink" title="简单了解"></a>简单了解</h2><blockquote>
<p>JavaNIO由三个核心组件构成</p>
</blockquote>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p>除了这三个还有别的如Pipe、FileLock等等</p>
<h3 id="NIO与BIO对比"><a href="#NIO与BIO对比" class="headerlink" title="NIO与BIO对比"></a>NIO与BIO对比</h3><ol>
<li>BIO 是面向<strong>流</strong>的；NIO 面向<strong>缓冲区</strong></li>
<li>BIO <strong>只能向后读</strong>，不能向前读；NIO <strong>可以向前也可以向后读</strong></li>
<li>BIO 是<strong>单向的</strong>，一端要么读要么写；NIO 中通道是<strong>双向的</strong>，一端可读可写</li>
<li>BIO 是<strong>阻塞</strong>的；NIO 是<strong>非阻塞</strong>的</li>
</ol>
<h3 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h3><p><img data-src="https://img.jyhmw.cn/image-20240913112720081.png" alt="image-20240913112720081"></p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><blockquote>
<p>Buffer缓冲区：可以理解为一个数组，通道必须与Buffer一起使用</p>
</blockquote>
<p>具体的实现类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>核心API：</strong></p>
<ul>
<li><code>put(value)</code>：将 <code>value</code> 写入缓存（从当前的 <code>position</code> 开始写入，并增加 <code>position</code> 的值，即<strong>相对位置的写入</strong>）</li>
<li><code>get(arr[])</code>：读取 <code>position</code> 位置下的数据到一个数组中（如果不传参数，默认读取一个字符）</li>
<li><code>hasRemaining()</code>：判断 <code>position</code> 与 <code>limit</code> 之间的距离，如果还有数据可以处理，那么就返回 true</li>
<li><code>clear()</code> ：清空缓冲区（清空的原理<strong>并不是真的清空了</strong>，只是将 position 的位置为 0，limit 设置为 capacity，即<strong>切换回写模式</strong>）</li>
<li><code>flip()</code>：可以将缓冲区<strong>由写模式切换到读模式</strong>（将 limit 设为 position 的位置，再将 position 设置为 0）</li>
<li><code>compact()</code>：压缩，将未读取的数据（即 position 与 limit 之间的数据）向前移动，然后 position 指向最后一个未读取的数据之后，然后 limit 指向 capacity</li>
</ul>
<p><strong>其他API</strong>：</p>
<ul>
<li><code>capacity(); limit() ; position()</code>：返回当前 <code>capacity/limit/position</code> 的值</li>
<li><code>mark()</code>：标记当前 <code>position</code> 的位置，当调用 <code>reset</code> 方法时，会重置到 mark 标记过的位置（只能在 0-position 之前）</li>
<li><code>remaining()</code>：返回 <code>position</code> 与 <code>limit</code> 之间的距离</li>
<li><code>reset()</code>：重置 <code>position</code> 到 <code>mark</code> 标记过的位置</li>
<li><code>rewind()</code>：将 <code>position</code> 设置为 0（即让 position 回到初始的位置），取消 mark 标记位</li>
</ul>
<h2 id="创建Buffer"><a href="#创建Buffer" class="headerlink" title="创建Buffer"></a>创建Buffer</h2><ul>
<li>allocate(long)：</li>
<li><strong>创建一个指定大小的缓冲区</strong>；是一个静态方法；（注意：<code>buffer</code> 对象不能 <code>new</code>，只能通过 <code>allocate</code> 分配）</li>
<li><code>warp()</code>：把已存在的数组包装为一个 Buffer 对象（无论操作两者中的哪一个，另一个也会变化，因为就是同一个数组）</li>
</ul>
<p>注意：</p>
<p>这两种创建方式，都是<strong>间接的</strong>创建了一个缓冲区（间接：是指这个缓冲区在 JVM 堆中）</p>
<blockquote>
<p>如何将一个字符串转换为一个ByteBuffer数组</p>
</blockquote>
<ol>
<li>使用 <code>ByteBuffer</code> 的 <code>wrap</code> 方法</li>
<li>使用 <code>Charset</code></li>
<li>创建 <code>ByteBuffer</code> 再 <code>put</code> 字符串的字节数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//1、使用ByteBuffer的wrap</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf1</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line"><span class="comment">//2、使用Charset</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(str);</span><br><span class="line"><span class="comment">//3、创建ByteBuffer再放入</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">bf3.put(str.getBytes());</span><br></pre></td></tr></table></figure>

<h2 id="属性及变化"><a href="#属性及变化" class="headerlink" title="属性及变化"></a>属性及变化</h2><p>Buffer 有<strong>四个重要的属性</strong>：</p>
<ul>
<li><code>capacity</code>：表示当前 Buffer 的容量大小；创建时指定，创建后不能修改；如果写满了 capacity，那么需要等清空后才能写入数据</li>
<li><code>position</code>：表示当前的位置，初始时为 0，每读写一个数据，<code>position</code> 就 + 1，最大为 <code>capacity-1</code></li>
<li><code>limit</code>：指第一个不能被读或写的位置（即可以表示只能读取或写入多少个数据）</li>
<li><code>mark</code>：设置一个标记位，当进行 <code>reset</code> 时，会将 <code>position</code> 的值变为 <code>mark</code> 原本标记的值</li>
</ul>
<p>四个属性有这样的大小关系：<code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>
<p>下面有个图，可以清晰的表示整个过程</p>
<p><img data-src="https://img.jyhmw.cn/image-20210920130513661.png" alt="buffer存储过程"></p>
<p>结合代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fc.read(bf);</span><br><span class="line">    <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bf.flip(); </span><br><span class="line">    <span class="comment">//1、转换为读模式！将limit设为position，再将position设置为0</span></span><br><span class="line">    <span class="keyword">while</span> (bf.hasRemaining())&#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> bf.get();</span><br><span class="line">        <span class="comment">//2、每读取一个字节，就将position+1</span></span><br><span class="line">        System.out.print((<span class="type">char</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line">    bf.clear();</span><br><span class="line">    <span class="comment">//3、转换为写模式！将position的位置为0，limit设置为capacity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h2><p>首先要明确一个概念：<strong>只有 byteBuffer 才有资格参与 IO 操作</strong>，因为数据全为 01，只有 byteBuffer 存储的才是 01 二进制，所以只有它才能 IO 操作</p>
<blockquote>
<p>为什么要用直接缓冲区？</p>
</blockquote>
<p>使用非直接缓冲区<strong>可能会导致性能损耗</strong>（多一次拷贝过程）</p>
<p>假设给一个通道传入了一个非直接缓冲区，那么通道会先创建一个<strong>临时的直接缓冲区</strong>，将<strong>非直接缓冲区的数据复制到临时的直接缓冲区</strong>，使用这个临时的直接缓冲区去执行 IO 操作（多一次拷贝，增大了开销）</p>
<blockquote>
<p>直接缓存区存在的问题：</p>
</blockquote>
<ul>
<li><strong>直接缓存区绕过了 JVM 的堆栈</strong>，不受 JVM 控制，所以有可能我们创建的直接缓存区代价会更高</li>
<li><strong>直接缓存区分配会较慢</strong>，因为 Java 需要调用 OS 的函数进行分配，所以会较慢</li>
</ul>
<blockquote>
<p>如何创建一块直接缓冲区？</p>
</blockquote>
<p>调用 <code>ByteBuffer.allocateDirect(1024)</code> 即可</p>
<h2 id="分散读与集中写"><a href="#分散读与集中写" class="headerlink" title="分散读与集中写"></a>分散读与集中写</h2><blockquote>
<p>这主要是<strong>两种思想</strong></p>
<p>分散读就是把原本的数据一次读到多个 buffer 中，集中写就是将多个 buffer 的内容一次性写入</p>
</blockquote>
<p>这两种思想分别有两个接口代表：<code>ScatteringByteChannel</code>（有 read 方法）、<code>GatheringByteChannel</code>（有 write 方法）</p>
<p>都可以传入一个 <code>ByteBuffer</code> 的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分散读</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel()) &#123;</span><br><span class="line">    fc.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;bf1, bf2, bf3&#125;);</span><br><span class="line">    <span class="comment">// 这个read方法传入的是一个ByteBuffer数组</span></span><br><span class="line">    <span class="comment">// 可以将数据分别读入三个缓冲区中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集中写同理</p>
<h2 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h2><blockquote>
<p>什么是粘包问题？</p>
</blockquote>
<ol>
<li>以接收端来看：因为 <strong>TCP 是面向流的协议，所以不会保持输入数据的边界</strong>，导致接收端很可能<strong>一下子收到多个应用层报文</strong>，需要应用开发者自己分开，有些人觉得这样不合理，就起名为<strong>粘包</strong></li>
<li>以发送端来看：用户数据被 TCP 发送时，会根据 Nagle 算法，将小的数据封装在一个报文段发送出去，导致不同的报文段黏在了一起</li>
</ol>
<blockquote>
<p>如何解决</p>
</blockquote>
<ol>
<li><p>发送方关闭Nagle方法</p>
<ul>
<li>设置<code>TCP_NODELAY</code>关闭Nagle算法</li>
<li>最好不使用</li>
</ul>
</li>
<li><p>交给应用层：</p>
<ul>
<li><p><strong>固定消息长度</strong>：一条消息就发送一个固定大小的数据，然后填充空白</p>
<ul>
<li>缺点：浪费带宽</li>
</ul>
</li>
<li><p><strong>格式化数据</strong>：每条数据有固定的格式（开始符，结束符），这种方法简单易行</p>
<ul>
<li>缺点：但是这种方法需要保证传输的字符中没有该开始符与结束符，而且因为需要挨个遍历，传输速度不是很快</li>
</ul>
</li>
<li><p><strong>TLV 格式</strong>：即 Type 类型、Length 长度、Value 数据，在类型和长度已知的情况下就可以方便的知道消息大小，分配合适的 buffer</p>
<ul>
<li>缺点：buffer 需要提前分配，如果分配过大，影响 server 的吞吐量</li>
<li>HTTP1.1 是 TLV 格式（先传输类型）</li>
<li>HTTP2.0 是 LTV 格式（先传输长度）</li>
</ul>
</li>
</ul>
<blockquote>
<p>此处举一个例子：（这里属于格式化数据的一种方式，使用到 <code>\n</code> 作为分隔符）</p>
</blockquote>
<p> 网络上有多条数据发送给服务端。数据之间使用 <code>\n</code> 进行分隔，但由于某种原因这些数据在接收时，被进行了重新组合。</p>
<p>例如原始数据有 3 条为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello,world\n</span><br><span class="line">I<span class="string">&quot;m zhangsan\n</span></span><br><span class="line"><span class="string">How are you?\n</span></span><br></pre></td></tr></table></figure>

<p>变成了下面的两个 <code>byteBuffer</code>(黏包，半包)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,world\nI<span class="string">&quot; m zhangsan\nHo</span></span><br><span class="line"><span class="string">w are you?\n</span></span><br></pre></td></tr></table></figure>

<p>如何解决？（但这种方法需要对字节挨个遍历，所以<strong>效率不是很高</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">source</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 模拟粘包</span></span><br><span class="line">    source.put(<span class="string">&quot;Hello,world\nI&#x27; m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">    spilt(source);</span><br><span class="line">    source.put(<span class="string">&quot;w are you?\n&quot;</span>.getBytes());</span><br><span class="line">    spilt(source);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理粘包</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">spilt</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;<span class="comment">// 带索引的get方法不会改变position的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 计算要分配的缓冲长度</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact();</span><br><span class="line">    <span class="comment">// 注意这里不能用clear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><blockquote>
<p>Channel：通道，类似于IO流，但是与流不同的是Channel是双向的</p>
</blockquote>
<p>IO流：如 <code>InputStream</code>、<code>OutputStream</code> 要么输入（读），要么输出（写）</p>
<p>但是 Channel 是<strong>双向</strong>的，实现类如下</p>
<ul>
<li><code>FileChannel</code>：从文件中读写数据</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络数据</li>
<li><code>SocketChannel</code>：通过 TCP 读写网络数据</li>
<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，就像 Web 服务器一样，对每一个新连接都会建立一个 <code>SocketChannel</code></li>
</ul>
<p>特点：</p>
<ul>
<li>通道的<strong>操作是双向的</strong>（可以只读、可以只写、还可以读写）</li>
<li>通道可以操作的数据种类很多（可以是文件 IO、网络 Socket 都可以操作）</li>
<li>通道的操作是<strong>异步</strong>的</li>
<li>不能直接访问通道，<strong>需要与 Buffer 合作</strong>（通道读必须从一个 Buffer 读、通道写必须写到一个 Buffer 内）</li>
<li>通道<strong>不能复用</strong>！关闭了就没了</li>
</ul>
<p>具体在 Java 中，就是一个接口，有两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//检测通道是否正常打开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//关闭这个通道：（如果通道关闭了，对这个通道的操作都会抛出异常）    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>用来对<strong>文件</strong>进行操作的通道</p>
<h3 id="获取FileChannel"><a href="#获取FileChannel" class="headerlink" title="获取FileChannel"></a>获取FileChannel</h3><p>获取 <code>FileChannel</code> 的方式：（不能 new 来获取，有<strong>三种获取方式</strong>）</p>
<ul>
<li>获取 <code>FileChannel</code> 可以使用 <code>RandomAccessFile</code> 这个类</li>
<li>也可以使用 <code>InputStream</code>（这样创建的 FileChannel 只能读）</li>
<li>也可以使用 <code>OutputStream</code>（这样创建的 FileChannel 只能写）</li>
</ul>
<h3 id="读到Buffer中"><a href="#读到Buffer中" class="headerlink" title="读到Buffer中"></a>读到Buffer中</h3><p><code>FileChannel</code> 读取数据到Buffer中</p>
<ul>
<li>通道的 <code>read()</code> 方法，<strong>必须读入到一个缓存中</strong>，而且会返回<strong>读取到的字节数</strong>（或者说是，缓冲区中的字节数有多少）</li>
<li>需要在缓冲的 <code>buffer.hasRemaining()</code> 的循环中使用</li>
<li>如果读完，会返回 - 1</li>
</ul>
<p>Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此文件有21字节，设置模式为读写均可</span></span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">// 使用RandomAccessFile类的getChannel方法获得此文件的通道</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> rw.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于buffer的内容先不做介绍，此处为分配一个大小为10字节的缓存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道的read方法会返回读取到的字节数，因为我的文件21字节，所以需要读三次</span></span><br><span class="line"><span class="comment">// 第一次：10字节、第二次10字节、第三次1字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line"><span class="comment">// 这一步是不会阻塞的！会继续向下执行</span></span><br><span class="line"><span class="keyword">while</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;读取了：&quot;</span>+ read);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.clear();</span><br><span class="line">    read = channel.read(buffer);</span><br><span class="line">&#125;</span><br><span class="line">rw.close();</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<p><strong>读文件大致Demo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">// JDK7 新特性</span></span><br><span class="line">    <span class="comment">//在 try 的后边可以增加一个 ()，在括号中可以定义流对象，</span></span><br><span class="line">    <span class="comment">//那么这个流对象的作用域就在 try 有效，try 中的代码执行完毕，会把流对象自动释放，不用写 finally</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> rw.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fc.read(bf);</span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bf.flip();</span><br><span class="line">        <span class="keyword">while</span> (bf.hasRemaining())&#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> bf.get();</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        bf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写到通道中"><a href="#写到通道中" class="headerlink" title="写到通道中"></a>写到通道中</h3><ul>
<li>write方法，需要传入缓冲</li>
<li>需要在缓冲的<code>buffer.hasRemaining()</code>的循环中使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> rw.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">15</span>);</span><br><span class="line">buffer.clear();</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;I love you too&quot;</span>.getBytes();</span><br><span class="line">System.out.println(bytes.length);</span><br><span class="line">buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">    <span class="comment">// 返回写入的字节，与读取一样，并不能确定一次会写入多少字节</span></span><br><span class="line">    <span class="comment">// 所以需要在循环内执行write方法，并且要用hasRemaining方法判断是否有剩余</span></span><br><span class="line">    System.out.println(write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><code>positon()</code>：返回从文件开头位置到当前位置的字节数</li>
<li><code>position(long)</code>：设置当前位置（注意：如果指定的位置超过了文件当前的位置，然后进行了写入，会<strong>导致文件中间部分没有被写（文件空洞）</strong>）</li>
<li><code>size()</code>：返回文件大小</li>
<li><code>truncate(long)</code>：截取前指定大小的数据，后面的数据将会被删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> rw.getChannel();</span><br><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br><span class="line"><span class="comment">// 初始位置为 0</span></span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> channel.size();</span><br><span class="line">System.out.println(size);</span><br><span class="line">channel.position(pos+size);</span><br><span class="line"><span class="comment">// 指定从什么位置开始，这里指定了当前位置+文件大小，就是文件的末尾开始写</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">30</span>);</span><br><span class="line">buffer.put(<span class="string">&quot; but she don&#x27;t fond of me&quot;</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line">rw.close();</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h3 id="force与RandomAccessFile"><a href="#force与RandomAccessFile" class="headerlink" title="force与RandomAccessFile"></a>force与RandomAccessFile</h3><ul>
<li><code>force(boolean)</code> 方法：<ul>
<li>此方法是为了<strong>保证对文件的所有更新操作都写回磁盘</strong></li>
<li>参数为 <code>false</code> 表示只写回<strong>文件内容</strong></li>
<li>参数为 <code>true</code> 表示既要写回<strong>文件内容</strong>，又要写回<strong>元数据信息</strong>（即文件的权限信息等）</li>
</ul>
</li>
<li><code>RandomAccessFile(fileName, mode)</code>：传入一个文件的路径以及一个模式，此处的模式有四种<ul>
<li><code>r</code>：只读，如果调用 write 会抛出异常</li>
<li><code>rw</code>：可读可写；如果文件不存在，将会被创建</li>
<li><code>rws</code>：可读可写，并且所有的更新操作每次都会被<strong>同步的写入磁盘</strong>，会<strong>写入文件内容以及元数据</strong>（即带有 <code>force(true)</code> 的 rw 模式）</li>
<li><code>rwd</code>：可读可写，并且所有的更新操作每次都会被<strong>同步的写入磁盘</strong>，会<strong>写入文件内容</strong>（即带有 <code>force(false)</code> 的 rw 模式）</li>
</ul>
</li>
</ul>
<h3 id="通道间通信"><a href="#通道间通信" class="headerlink" title="通道间通信"></a>通道间通信</h3><p>通道之间可以<strong>传输数据</strong>，这两个方法<strong>仅仅是方向不同而已</strong></p>
<p>（通道之间传输数据没有用到缓存，不知道底层实现是否用到了缓存）</p>
<ul>
<li><code>transferFrom(ReadableByteChannel src, long position, long count)</code>：三个参数，第一个传入另外一个通道，第二个为起始位置，第三个传入想要传输的字节数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">rw1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;d:\\temp.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channelFrom</span> <span class="operator">=</span> rw1.getChannel();</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">rw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;d:\\temp2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channelTo</span> <span class="operator">=</span> rw2.getChannel();</span><br><span class="line"><span class="comment">// 这样就将temp的文件写入到了temp2</span></span><br><span class="line">channelTo.transferFrom(channelFrom, <span class="number">0</span>, channelFrom.size());</span><br><span class="line"><span class="comment">// channelFrom.transferTo(0, channelFrom.size(), channelTo);</span></span><br><span class="line"><span class="comment">// 也可以这么实现，两个方法只不过是方向反了一下</span></span><br><span class="line">channelFrom.close();</span><br><span class="line">channelTo.close();</span><br></pre></td></tr></table></figure>

<p>注意：<code>transferTo</code> 方法是有上限的（最大为 2G，超过这个范围，那么只会传输 2g 的内容，剩下的数据就不会再传输了）</p>
<p>可以这样实现传输大于 2g 的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:\\temp1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 重点在这里：</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> fc1.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size; left &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        left -= fc1.transferTo(size-left, left, fc2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket通道"><a href="#Socket通道" class="headerlink" title="Socket通道"></a>Socket通道</h2><p>此处的 <strong>Socket 通道</strong>泛指了三个实现了 <code>AbstractSelectableChannel</code> 的类：<code>SocketChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code></p>
<blockquote>
<p>为什么引入Socket通道？</p>
</blockquote>
<p>传统的 <code>Socket</code> 会为每个 <code>Socket</code> 连接创建一个线程，但是 <strong>Socket 通道</strong>仅仅只开辟一个或几个线程就可以提供成百上千的服务，大大提高了性能！</p>
<p>好处：</p>
<p>1、节省了线程切换的上下文开销</p>
<p>2、便于管理</p>
<blockquote>
<p>Socket 通道的特点</p>
</blockquote>
<ul>
<li><p><code>ServerSocketChannel</code>只负责： （不负责读写）</p>
<ol>
<li>监听传入的连接</li>
<li>创建 <code>SocketChannel</code> 对象</li>
</ol>
</li>
<li><p><code>DatagramChannel</code>与<code>SocketChannel</code>负责真正的读写操作</p>
<ul>
<li>Socket 通道可以被<strong>重复使用</strong></li>
</ul>
</li>
<li><p>Socket 通道可以设置为<strong>非阻塞模式</strong></p>
</li>
</ul>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><blockquote>
<p>ServerSocketChannel：可以理解为一个<strong>实现了非阻塞模式的 ServerSocket</strong></p>
</blockquote>
<p>特点：</p>
<ul>
<li><code>socket()</code>：可以获得 <code>ServerSocket</code> 对象，然后调用其 <code>bind()</code> 方法去绑定一个端口（注意：<code>ServerSocketChannel</code> 本身<strong>没有 <code>bind</code> 方法</strong>！！（JDK1.7 有了 bind 方法，默认绑定本地地址））</li>
<li><code>ServerSocketChannel</code> 有 <code>accept()</code> 方法，会返回一个 <code>SocketChannel</code> 对象；但是使用 <code>ServerSocket</code> 的 <code>accept()</code> 方法就还是阻塞的<ul>
<li>如果返回的对象为 <code>null</code>，说明当前没有连接</li>
</ul>
</li>
<li>因为继承了 <code>AbstractSelectableChannel</code> 类，所以可以设置为<strong>非阻塞模式</strong></li>
</ul>
<blockquote>
<p>ServerSocketChannel 对象的创建：</p>
</blockquote>
<p>不能 new，需要调用 <code>ServerSocketChannel</code> 的静态方法 <code>open()</code></p>
<blockquote>
<p>核心API</p>
</blockquote>
<ul>
<li><code>accepct()</code>：方法是阻塞方法（如果不设置为非阻塞）</li>
<li><code>bind()</code>：绑定一个端口</li>
<li><code>configureBlocking(boolean)</code>：默认为 true（阻塞模式）</li>
</ul>
<blockquote>
<p>使用单线程 + Channel 实现服务器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. byteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>);<span class="comment">// 设置为非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">ArrayList&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. SSC建立与客户端的连接，sc与客户端通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();<span class="comment">// 设置为非阻塞，不会再阻塞运行</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>);<span class="comment">// sc也设置为非阻塞</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 遍历集合处理请求</span></span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(bf);<span class="comment">// 设置为非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bf.flip();</span><br><span class="line">            readBuffer(bf);<span class="comment">// 此方法简单的输出了一下buffer（模拟实际操作）</span></span><br><span class="line">            bf.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>缺点：我们使用了死循环来一次次判断连接情况（这样也会浪费 CPU 的资源）</p>
<p>因此有了 Selector 来解决这个问题（使用 Seletor 后，代码的逻辑会发生变化）</p>
<h3 id="ScoketChannel"><a href="#ScoketChannel" class="headerlink" title="ScoketChannel"></a>ScoketChannel</h3><blockquote>
<p>SocketChannel：用来连接到TCP套接字的通道</p>
</blockquote>
<p>特点：</p>
<ul>
<li>实现了<strong>可选择通道，可以被多路复用</strong></li>
<li>基于 <strong>TCP 传输协议</strong></li>
<li>支持两种模式：阻塞与非阻塞（同样也是通过 <code>configureBlocking</code> 调节）</li>
</ul>
<blockquote>
<p>创建SocketChannel</p>
</blockquote>
<ul>
<li><code>ServerSocket</code> 对象的 <code>accept</code> 方法会返回 <code>SocketChannel</code> 对象</li>
<li>直接使用 <code>SocketChannel.open()</code> 也可以创建 SocketChannel 对象</li>
</ul>
<blockquote>
<p>核心API</p>
</blockquote>
<ul>
<li><code>configureBlocking(boolean)</code>：默认为 true（阻塞模式）</li>
<li><code>read(ByteBuffer)</code>：读</li>
<li><code>write(ByteBuffer)</code>：写</li>
</ul>
<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><blockquote>
<p>提供了一种选择执行已经就绪的任务的能力</p>
</blockquote>
<p>允许单线程处理多个通道，大大提高了效率</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>每个Channel都在Selector上注册</li>
<li>注册后会返回一个选择键，选择键代表了当前通道是否已经就绪的信息</li>
<li>每执行一次select方法，都会更新所有的选择键，然后选择一个已经就绪的通道</li>
</ol>
<p><img data-src="https://img.jyhmw.cn/image-20210920151712340.png" alt="选择示意图"></p>
<p>注意：</p>
<ul>
<li>这些 Channel <strong>必须是 <code>SelectableChannel</code> 的子类</strong>（比如：<code>FileChannel</code> 就不是其子类，也就不能被选择）</li>
</ul>
<h2 id="有关的类"><a href="#有关的类" class="headerlink" title="有关的类"></a>有关的类</h2><ul>
<li><code>Selector</code>：<strong>选择器类</strong>负责管理在此注册的通道的集合信息以及他们的就绪状态</li>
<li><code>SelectableChannel</code>：<strong>可选择通道</strong>，是一个抽象类，继承这个类的类为可以进行选择的类（FileChannel 就没有继承这个类）</li>
<li><code>SelectionKey</code>：选择键类，封装了通道与选择器之间的注册关系，含有两个比特集（一个代表注册关系所关心的通道操作，一个代表通道已经就绪的操作）</li>
</ul>
<h2 id="建立Selector系统"><a href="#建立Selector系统" class="headerlink" title="建立Selector系统"></a>建立Selector系统</h2><p><strong>创建 Selector</strong>：不能 new，需要调用 <code>Selector.open()</code> 方法</p>
<p>2、<strong>设置通道为非阻塞</strong>（只有非阻塞的通道才能注册到选择器）</p>
<p>3、<strong>通道注册</strong>：调用 <code>register(selector, OP)</code> 进行注册，两个参数，第一个为选择器，第二个参数为想让选择器关心的操作，会返回一个 <strong>SelectionKey 对象</strong></p>
<p>此处可以设置的关心的操作 OP 有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey.OP_READ = <span class="number">1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">// 是否有可读的通道就绪</span></span><br><span class="line">SelectionKey.OP_WRITE = <span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">// 是否有可写的通道就绪</span></span><br><span class="line">SelectionKey.OP_CONNECT = <span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">// 是否有新的通道连接到服务器</span></span><br><span class="line">SelectionKey.OP_ACCEPT = <span class="number">1</span>&lt;&lt;<span class="number">3</span>; <span class="comment">// 是否有新的连接（只有ServerSocketChannel有这个操作）</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要关心多个操作，可以通过 <code>|</code> 位或运算符将 OP 连接起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE)</span><br></pre></td></tr></table></figure>

<p>4、<strong>select () 轮询</strong>：查看是否有就绪的通道，会返回当前就绪通道的数量</p>
<h2 id="Selector三个集合"><a href="#Selector三个集合" class="headerlink" title="Selector三个集合"></a>Selector三个集合</h2><ul>
<li><code>keys()</code>：此集合保存<strong>已注册的键</strong>（此集合不能修改！）</li>
<li><code>selectedKeys()</code>：此集合保存关心事件发生的键，此集合我们只能移除，不能添加（添加是自动进行的）<ul>
<li>注意这个集合的<strong>特点</strong>：会自动添加集合，但是不会自动删除集合</li>
<li>因此我们在处理<strong>完成后要主动 <code>remove</code> 掉</strong>，要不然会报异常</li>
</ul>
</li>
<li>已取消键的集合，使用 <code>cancel()</code> 方法后的键都会放在这里</li>
</ul>
<blockquote>
<p>Selector 的核心就是 <code>select</code> 方法，它的执行过程为：</p>
</blockquote>
<ol>
<li><strong>检查已取消集合</strong>：如果集合非空，就将集合内所有的键从另外两个集合中移除，然后注销其相关的通道</li>
<li><strong>检查 selectedKeys 集合</strong>：确定每个通道所关心的操作是否已经就绪</li>
<li><strong>返回值</strong>：返回上一次调用 select 后进入就绪状态的通道的数量</li>
</ol>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><blockquote>
<p>选择键： 表示<strong>通道与 Selector 之间的注册关系</strong>，注册一个通道就会返回一个 SelectionKey</p>
</blockquote>
<p>相关 API：</p>
<ul>
<li><code>channel</code>：返回对应的通道</li>
<li><code>selector</code>：返回通道注册的选择器</li>
<li><code>cancel</code>：取消注册关系</li>
<li><code>isValid()</code>：判断注册关系是否有效</li>
<li><code>interestOps()</code>：以整数的形式，返回所关心操作的 bit 掩码，可以用此来判断选择器是否关心通道的某个操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">isAccept</span> <span class="operator">=</span> interestOps &amp; SelectionKey.OP_ACCEPT == SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="comment">// 判断一下与的结果是否与Accept相等</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>isAccept()</code> 等操作：上面的这种方式判断太麻烦了，API 直接就有相关判断方法</li>
</ul>
<h2 id="关于Selector"><a href="#关于Selector" class="headerlink" title="关于Selector"></a>关于Selector</h2><blockquote>
<p>select 方法什么时候会不阻塞，向下执行？</p>
</blockquote>
<p>总共用如下几种情况：</p>
<ol>
<li>发生事件时<ul>
<li>客户端发起连接请求，触发 accept 事件</li>
<li>客户端发送数据、正常关闭、异常关闭都会触发 read 事件</li>
<li>如果要发送的数据大于缓冲区，会触发多次 read 事件</li>
<li>channel 可写，触发 write 事件</li>
<li>在 Linux 下 nio bug 发生时</li>
</ul>
</li>
<li>调用 <code>selector.wakeup()</code></li>
<li>调用 <code>selector.close()</code></li>
<li>selector 所在线程 <code>interrupt</code></li>
</ol>
<blockquote>
<p>事件可以不处理吗？</p>
</blockquote>
<p>不可以，事件要么就 <code>remove</code>，要么就 <code>cancel</code>，不可以不进行处理</p>
<p>如果不进行处理，<code>select</code> 每次都会返回这个事件，白白浪费 CPU 的资源</p>
<blockquote>
<p>用完 key 为什么要 remove？</p>
</blockquote>
<p>elector 维护的集合 SelectedKeys 添加是自动的，删除需要我们手动进行，一旦有我们关心的事件发生，那么 Selector 就会将此 key 添加到这个集合内</p>
<p> 如果我们用完 key，没有 remove，那么此集合内就还会存在这个 key，在使用这个 key 进行操作的时候，就可能会出现异常（比如空指针异常）</p>
<p>注意：remove 只是将这个集合内的该键删除了，如果对应的事件还会继续发生，那么这里光删除集合内的 key 是没有用的，应该 cancel 掉对应的事件</p>
<blockquote>
<p>处理read事件要注意的事情</p>
</blockquote>
<p>【一】处理好客户端的正常与异常断开</p>
<p>正常断开依靠 read 方法返回值</p>
<p>异常断开依靠 catch 抓住异常后，将此 key 取消掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">    int read = channel.read(buffer);//如果客户端正常断开，这里会返回-1</span><br><span class="line">    // 【处理客户端正常断开】</span><br><span class="line">    if(read == -1)&#123;</span><br><span class="line">        key.cancel();</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    // 【处理客户端异常断开】</span><br><span class="line">    key.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【二】处理好<strong>消息边界</strong></p>
<p>例如我们开辟一块 <code>buffer</code> 为 4 字节的缓冲区，客户端传输两个汉字 “中国”，默认字符集 UTF-8 对于 1 个汉字占用 3 个字节，就要处理好消息边界的问题！</p>
<p>（如何解决消息边界问题下一节详细介绍）</p>
<blockquote>
<p>处理write事件要注意的事情</p>
</blockquote>
<p>我们发送的数据可能不是一次性发送的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line"><span class="comment">//【1】 write不能保证一次性就将所有的数据写入，有一个返回值，表示实际写入的字节数</span></span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">    <span class="comment">// 【2】返回值代表一次性可以发送的位数</span></span><br><span class="line">    <span class="comment">// 这里一次性可以发送多少，涉及到了OS对于TCP的发送缓存与接收缓存的实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">    System.out.println(write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样处理虽然可以保证数据全部发完，但是<strong>不符合 NIO 非阻塞的思想</strong></p>
<p>好的处理方式应该是，如果我们一次性发不完，可以先去处理其他事情（避免一直发送导致发送缓冲区满，导致轮询）</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 向客户端发送消息</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line"></span><br><span class="line">            sc.write(buffer);</span><br><span class="line">            <span class="comment">//【1】 一次发送完最好</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                <span class="comment">//【2】 如果发送不完，就关注写事件</span></span><br><span class="line">                <span class="comment">// 注意：要拿到原本关注的事件再|上此事件（+ |都可以）</span></span><br><span class="line">                scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                <span class="comment">//【3】把没有写完的数据写回，利用附件的形式</span></span><br><span class="line">                scKey.attach(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 【4】从附件取出，继续写</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            sc.write(buffer);</span><br><span class="line">            <span class="comment">// 【5】如果此次还没有写完，由于我们已经关注了可写事件，所以下一次会继续写</span></span><br><span class="line">            <span class="comment">// 【6】清理操作</span></span><br><span class="line">            <span class="keyword">if</span>(!buffer.hasRemaining())&#123;</span><br><span class="line">                <span class="comment">// 清掉附件</span></span><br><span class="line">                key.attach(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 去掉关注的事件</span></span><br><span class="line">                key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理消息边界"><a href="#处理消息边界" class="headerlink" title="处理消息边界"></a>处理消息边界</h2><blockquote>
<p>比如粘包问题</p>
</blockquote>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><blockquote>
<p>消息边界：发送一个消息可能有三种异常情况</p>
</blockquote>
<ol>
<li>buffer的大小不足以放下一个完整的消息。<ul>
<li>这种情况下，<strong>只能将 buffer 扩容</strong></li>
</ul>
</li>
<li><code>buffer</code> 空间足够，但是只放了 1.5 个消息，剩下的半个消息我们需要进行拼接（在 Buffer 一节，我们介绍了一个利用 <code>\n</code> 来截断消息的步骤）</li>
</ol>
<blockquote>
<p>如果 buffer 空间不足（即一条消息的大小就超过了 buffer），nio 是如何进行处理的呢？</p>
</blockquote>
<p>例如：buffer 空间为 8 字节，传输一条 10 字节的消息</p>
<p>服务器收到 read 事件，将数据读到 8 字节的缓存中，然后打印输出</p>
<p>然后，服务器会再次收到 read 事件，将剩下 2 个字节读入，打印输出</p>
<p>（即：服务器会变为<strong>多次 read 事件读取消息</strong>，因此对于这种情况我们需要扩容）</p>
<h3 id="如何扩容buffer"><a href="#如何扩容buffer" class="headerlink" title="如何扩容buffer"></a>如何扩容buffer</h3><blockquote>
<p>buffer 不能是局部变量</p>
</blockquote>
<p>最开始我们的代码是这样的，但是如果我们想要给一个 buffer 扩容，buffer 就不能是一个局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到read事件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 注意这里的buffer是局部变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">    <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">        key.cancel();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        spilt(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    key.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么，不能是局部变量，我提到最外面可以不可以呢？</p>
</blockquote>
<p>不可以，我们要<strong>保证一个线程的 buffer 是私有的</strong>，如果我们提到最外面，那么多个线程操控一个 buffer，这就乱套了（线程不安全）</p>
<p>因此我们要借助<strong>附件 attachment</strong></p>
<blockquote>
<p>注意：<strong>附件可以保证每一个线程间是私有的</strong></p>
</blockquote>
<p><code>regiser()</code> 传入的第三个参数就是附件，如果要获取附件，可以调用 key 的 <code>attachment()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">    <span class="comment">//6.1、accept事件</span></span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 【1】将buffer以附件的形式存放到key中</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    log.debug(<span class="string">&quot;sc: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="comment">//6.2、read事件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">// 【2】从附件中获取buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spilt(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            readBuffer(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        key.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么时候进行扩容呢？</p>
</blockquote>
<p>当然是 buffer 空间不够的时候，之前我们自己实现的 <code>split()</code> 方法最后是使用的 <code>compact()</code> 方法去完成拼接</p>
<p>如果一个消息大于 buffer，那么他的 <code>\n</code> 的索引依然会大于 limit</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer大小8字节</span><br><span class="line">传输一个数据：0123456789\n（11字节）</span><br><span class="line">-----------------&gt;</span><br><span class="line">执行spilt()方法，最后buffer内的数据为01234567，此时position为8，limit也为8</span><br></pre></td></tr></table></figure>

<p>因此，扩容的时机就是 <code>position==limit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line"><span class="comment">// 从附件中获取buffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line"><span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(byteBuffer);</span><br><span class="line"><span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">    key.cancel();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(byteBuffer);</span><br><span class="line">    <span class="comment">// 【1】判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(byteBuffer.position() == byteBuffer.limit())&#123;</span><br><span class="line">        <span class="comment">//【2】 分配一个double容量的buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">newByteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(byteBuffer.capacity() * <span class="number">2</span>);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        newByteBuffer.put(byteBuffer);<span class="comment">//【3】 copy</span></span><br><span class="line">        key.attach(newByteBuffer);<span class="comment">// 【4】替换原有的byteBuffer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样两次 read 事件，就能把消息拼接到一起了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buffer大小<span class="number">8</span>字节</span><br><span class="line">传输一个数据：0123456789\n（<span class="number">11</span>字节）</span><br><span class="line">---------解释---------</span><br><span class="line">【第一次read事件】：</span><br><span class="line">执行spilt()方法</span><br><span class="line">buffer1内的数据：<span class="number">01234567</span></span><br><span class="line">此时position=<span class="number">8</span>, limit = <span class="number">8</span> </span><br><span class="line">因此创建buffer2，容量为<span class="number">8</span>*<span class="number">2</span>字节，并放入附件中</span><br><span class="line">【第二次read事件】：</span><br><span class="line">buffer2数据为：<span class="number">01234567</span></span><br><span class="line">spilt()将<span class="number">89</span>\n拼接到buffer2</span><br><span class="line">此时buffer2数据为：0123456789\n</span><br></pre></td></tr></table></figure>

<p>此处我们的扩容简单的进行了翻倍扩容，这是比较简单的实现，在 Netty 中，就设计的比较优秀了，此处我们只是抛砖引玉</p>
<blockquote>
<p>buffer 大小如何抉择有两种思路：</p>
</blockquote>
<p>ByteBuffer 需要设计为可变的 buffer：</p>
<ul>
<li>思路一：首先分配一个较小的 buffer，如果不够用，再分配一个更大的 buffer，并将原本的 buffer 数据 copy 到新 buffer 内<ul>
<li>优点：消息连续好处理</li>
<li>缺点：数据 copy 消耗性能</li>
</ul>
</li>
<li>思路二：用多个数组组成 buffer，一个数组不够，就将多出来的内容写入新的数组<ul>
<li>优点：避免了 copy 消耗性能</li>
</ul>
</li>
</ul>
<h2 id="NIO服务器Demo"><a href="#NIO服务器Demo" class="headerlink" title="NIO服务器Demo"></a>NIO服务器Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建Selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//2、注册ssc，返回SelectionKey对应关系</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//3、SelectionKey设置关心的操作</span></span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);<span class="comment">// 这个键只关心其ACCEPT事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//4、调用select方法，如果没有事件发生，是阻塞的！如果有事件才会恢复执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//5、处理事件（因为我们涉及到删除，所以要用迭代器遍历）</span></span><br><span class="line">            <span class="comment">//   注意：事件必须要处理，要么remove要么cancel，要不然select会一直有这个事件，浪费CPU资源</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="comment">// 7、要记得删除此事件！可以一开始就删，也可以最后再删除</span></span><br><span class="line">                <span class="comment">// 这里一开始就删除了，特别强调！！一定要删除</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 6、区分时间类型进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//6.1、accept事件</span></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                    <span class="comment">// 将buffer以附件的形式存放到key中</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;sc: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//6.2、read事件</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 从附件中获取buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(byteBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(byteBuffer);</span><br><span class="line">                            <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">                            <span class="keyword">if</span>(byteBuffer.position() == byteBuffer.limit())&#123;</span><br><span class="line">                                <span class="comment">// 分配一个double容量的buffer</span></span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">newByteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(byteBuffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                                byteBuffer.flip();</span><br><span class="line">                                newByteBuffer.put(byteBuffer);<span class="comment">// copy</span></span><br><span class="line">                                key.attach(newByteBuffer);<span class="comment">// 替换原有的byteBuffer</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="comment">//6.3、write事件</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readBuffer</span><span class="params">(ByteBuffer bf)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bf.position(); i &lt; bf.limit(); i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) bf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">spilt</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;<span class="comment">// 带索引的get方法不会改变position的值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="comment">// 计算要分配的缓冲长度</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(len);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">        <span class="comment">// 注意这里不能用clear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h2><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><p>前面我们都是使用单线程，即将所有的事件全部放在一个线程内进行操作，不能发挥多线程的优势</p>
<p>所以我们可以进行<strong>多线程优化</strong>：（这也是 Netty 的实现原则）</p>
<blockquote>
<p>优化的手段</p>
</blockquote>
<p>可以将 ACCEPT 请求与读写请求分开，如图：</p>
<p><img data-src="https://img.jyhmw.cn/image-20211005142906453.png" alt="多线程优化"></p>
<p>有两类线程：</p>
<ul>
<li>boss 线程：专门负责处理 <code>ACCEPT</code> 事件</li>
<li>worker 线程：处理 <code>READ</code> 与 <code>WRITE</code> 事件</li>
</ul>
<p>boss 线程只有一个，而 worker 线程可以根据服务器的 CPU 核心数来确定，并且可以加入负载均衡策略，让每一个 worker 线程一起出力。</p>
<blockquote>
<p>优化手段总结：</p>
</blockquote>
<p>1、按事件分类，分给不同的线程执行</p>
<p>2、worker 间实现负载均衡</p>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>boss 线程一开始就有，worker 线程是慢慢创建的，具体的逻辑如下</p>
<p><img data-src="https://img.jyhmw.cn/image-20211005143453665.png" alt="实现逻辑"></p>
<p>值得注意的是：要让 <code>select</code> 与注册全让 <code>worker</code> 线程来执行，通过<strong>消息队列 +<code>wakeup()</code> 方法</strong> 来进行传输消息（即我标为黄色的部分）</p>
<p>这样可以避免出现执行顺序不正确带来的顺序问题。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// boss负责管理连接事件</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建固定数量的worker并初始化</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[Runtime.getRuntime().availableProcessors()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// ACCEPT事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    log.debug(<span class="string">&quot;connected...&#123;&#125;&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//2、关联selector</span></span><br><span class="line">                    <span class="comment">// 轮流使用worker，达到负载均衡</span></span><br><span class="line">                    workers[index.getAndIncrement() % workers.length].initial(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker类负责读写操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//保证只创建一个</span></span><br><span class="line">        <span class="comment">// 作为消息队列，让boss线程给worker线程传消息</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程和selector</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initial</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup();</span><br><span class="line">            <span class="comment">// 唤醒selector，让其可以将READ事件注册</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select(); <span class="comment">// 阻塞</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                        <span class="comment">// 真正是在这里执行了注册方法  sc.register(selector, SelectionKey.OP_READ, null);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                            <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                                key.cancel();</span><br><span class="line">                            &#125;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; executing...&quot;</span>, name);</span><br><span class="line">                            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                                System.out.print((<span class="type">char</span>) buffer.get());</span><br><span class="line">                            &#125;</span><br><span class="line">                            buffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零拷贝（未完）"><a href="#零拷贝（未完）" class="headerlink" title="零拷贝（未完）"></a>零拷贝（未完）</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a>
              <a href="/tags/NIO/" rel="tag"># NIO</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/03/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="prev" title="SpringCloud微服务">
                  <i class="fa fa-angle-left"></i> SpringCloud微服务
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">晋ICP备2024041642号-1</a> </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Jyh</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
